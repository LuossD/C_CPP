# 

---记录老师展开讲的内容，附加网上看的一些

## 小知识

### 1.endl与"\n"

cout << endl
相当于cout << "\n" + flush
回车同时刷新了缓冲区
所谓刷新缓冲区的意思如下
很简单的一个例子:

```c
代码1，输出123之后才会出现暂停提示
cout << "123"<<endl;//有endl
system("pause");
代码2，出现暂停提示之后才会输出123
cout << "123";//无endl
system("pause");
```

cout << '\n' 只是单纯换行，没有清除缓冲
cout<<endl 换行又清除缓冲
如果你的 程序都是cout << '\n' 结束，缓冲区就会满满的，相当于内存泄漏；

cout是输出流，用cout<<endl 能够将流中的内容全部输出，而cout<<"\n"不一定。在c++中建议用cout<<endl。

### 2.cin

cin是忽略换行和空白符的
但是你可以用cin.get(ch)就可以把'\n'赋给ch

```c
char ch;
cin.get(ch);
```

cin在键盘输入后按回车才会继续执行。

### 3.C++中单引号与双引号的区别

C＋＋中单引号、双引号的区别为：**表示类型不同、数据长度不同、尾部不同**。

1）表示类型不同

> 单引号：单引号的表示类型为字符类型。
>
> 双引号：双引号的表示类型为字符串类型。

2）数据长度不同

> 单引号：单引号的数据长度固定，因为只有一个字符，所以数据长度为1。
>
> 双引号：双引号的数据长度不固定，由字符串的字符数量决定。

3）尾部不同

> 单引号：单引号只有一个字符，不会在字符尾部添加＇＼0＇结尾。
>
> 双引号：系统会将双引号里的字符串内容的尾部自动添加＇＼0＇结尾。

> "a"和'a'的区别，前者是字符串，后者是字符。
> 实际上，"a"在内存中一般占2个字节（不是说字符串长度，是占用内存。注意说是一般占2字节，有特殊情况），"a\0"，以'\0'结尾。而'a'是一个单字符。
> **当然字符串可以是"abcde"这样的，'abcde'这样就是错误的。**

> 在C++中sizeof('a')=1,它是占一个字节，sizeof("a")=2，它后面还有一个\0结束符；而在C语言中，sizeof('a')=4（字符在C语言中是用int型数据存储的）

## 写程序出现的问题

1）warning: control reaches end of non-void function

> 别人的博客：
>
> 用gcc编译一个程序的时候出现这样的警告：
>
> warning: control reaches end of non-void function
>
> 它的意思是：控制到达非void函数的结尾。就是说你的一些本应带有返回值的函数到达结尾后可能并没有返回任何值。这时候，最好检查一下是否每个控制流都会有返回值。

## 一.C/C++基本语法元素

### 1.程序设计的基本概念

程序：一系列遵循一定规则并能正确完成待定功能的代码或指令序列

**通常包括数据结构与算法两部分**

------

算法：

描述问题的求解方法和步骤

不允许存在二义性（计算机是一个机械计算过程，逻辑非常机械）

算法设计过程是逐步求精的（不能指望写一个算法解决实际问题一步到位调试正确；逻辑错误比较难发现；先完成一个初步的算法，然后一步一步不断修正它改进升级它）

常使用流程图和伪代码描述算法（伪代码用的较多）

数据与数据结构：

数据：程序操作的对象

数据结构：数据对象之间的**相互关系及构造方法**

数据结构与算法关系密切，良好的数据结构可使算法更简单，恰当的算法可使数据结构更易理解

> 对象：行动和思考的目标；
>
> 对象之间的关系如若不构建出来你的程序数据对象就是零散的，就不能深刻的表达我们现实世界中的这种联系，事物是普遍联系的；
>
> 一个数据结构应该有一个和它相配套的算法，一个算法应该有一个和它相适应的数据结构，两者是一种紧密联系的关系，不能单纯的割裂这二者，而且在某些情况下还会互相转化。

很多很有经验的程序员也是按照这个方式来做，老师把这个思维模式叫做数据中心主义；

这是很多学习者一开始不自觉的思维习惯，不太容易纠正过来；

好处：解决某个问题我怎么用数据来表达它，这个目标是清晰的；

坏处：当我这个问题没想清楚时，这个数据的表达可能是不恰当的；当我在一个不恰当的地基上写算法时，最终发现这个数据表达是错误的，那么所写的算法基本上是没用的，程序越大越复杂这个问题越严重。

所以最后才把它变为称之为算法中心主义的一个东西。

怎么做程序设计：

涉及三种形态的程序设计

- 结构化程序设计

- 面向对象程序设计

  **对象：行为与属性的集合**

  类与对象、对象构造、继承与派生

- 范型编程

**结构化程序设计是早期从C那里继承过来的，必须会用！**（后两者中的代码实现还是结构化的）

面向对象程序设计做了一个很巧妙的改变：**把数据对象和这个对象的行为也就是算法合在一块，把它辩证统一**；

好处：现在行动和思考的目标是对象，没错，但是你不再是数据中心主义了，而是对象中心主义；行动和思考的目标不仅仅包括数据和数据结构，还包括了在这个数据和数据结构上面可以执行的操作，也就是它的行为，实际是完成了从数据中心主义向算法中心主义的一个转化，这点很重要！

为什么做这样的转变？

一个程序里面要么是数据结构要么是算法，不太容易变动的是算法，数据结构是易变的；**写程序首先应攻克那些不太容易变化的地方**，先把这个固定下来然后去攻克那些容易变动的地方。走极端肯定不对，我们要中庸，那就应该是对象中心主义，两者融合在一起，这就是面向对象程序设计的由来或者产生面向对象程序设计的根本原因，就是为了解决大程序开发时候原来的结构化程序设计解决不了的问题：程序太大，规模太大，控制不住！

### 2.简单C程序介绍

wins命令行中编译c程序：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190115211433592.png)

gcc 是编译命令，刚刚我们安装的，-g参数是表示编译时带上可调试记号，不然编译好的东西只能运行不能调试，-o 是表示指定输出文件，后面紧跟输出文件的名字，这一条指令就可以将c文件编译成一个可执行的二进制文件。

------

int main()

每一个C/C++程序都有一个主函数main()，名字固定，一个程序就这么一个，必须有一个，只能有一个。除非你写的不是程序，而是C或C++的库，这个不需要main！

#include <stdio.h>,printf函数原型位于"stdio.h"中，没有它就找不到该函数的入口，函数用的对不对也是参照header文件！

main()前面有个int，表示main函数完成后会带回一个结果，即函数的返回值，返回值是一个整数；0，1，2等等，返回值是给操作系统用的，正确执行即返回0，运行出错会有很多类型的错误，返回不同的值。

------

若想用C++的新格式包含stdio.h，就要写cstdio，后面的.h可以不要了。

早期的C++头文件为<iostream.h>，后改为<iostream>。

C++引入了一个很特殊的东西，成为（命）名空间---namespace，这个空间的名字叫std！C++标准库的名字都在标准名空间里。比如C++中，cout，endl等都在标准命名空间std里面；如果前面不写using namespace std;那么cout应该改为std::cout，endl改为std::endl；::成为名解析操作符。**std和别的名空间是分开的，这是一个非常重要的设计**，如果名字太多，在一个空间里，重名的话不太好解决。两个名空间里名字可以一样，通过名空间来解析他们。

**小结：**

程序执行由主函数开始，其他函数由主函数直接或间接调用；

程序执行流程与函数定义顺序无关；

每个函数包含函数头与函数体两部分；

C/C++包含大量库函数和算法，可直接使用。

### 3.程序设计的基本流程

包含如下几个过程：

1）编辑源代码

包括源文件和头文件，最后的输出结果就是源文件和头文件。源文件的名字就叫main.cpp，a.cpp等，后缀都为.cpp。编译器自动根据后缀来选择C++的编译还是C的编译；有些是这样做的，至于Linux下面看自己选择，使用gcc编译器还是g++编译器。头文件就是<stdio.h>或者没有.h的就是iostream。

2）编译、链接与测试

编译出来的就是目标文件，是二进制的代码。然后把这些二进制代码按照一个可执行文件的特定格式把它组装在一起，这个过程称为链接。生成可执行文件。

在此过程中我们需要使用到那些函数库里面抽取出来的那些二进制的目标代码，比如printf那样的函数目标代码它就会和我们的这个程序中的目标代码链接在一起形成我们的可执行文件。可执行文件运行，测试这个程序对不对。

------

Linux中可执行文件是放在固定的目录下面的，我们**当前目录往往不在可执行文件的那个搜索路径上**，所以要想执行当前目录下面的"a.out"文件，必须写"./a.out"。

> PATH 是环境变量，里面保存了执行文件路径（通常会包含多个路径，各路径之间以冒号“:”进行间隔）。**当执行一个可执行文件（命令）时，Linux 会优先到 PATH 环境变量中保存的路径下进行查找**。使用export $PATH命令可以查看环境变量的内容。
>
> 二、“.”表示当前目录，Windows/Dos 的默认搜索路径（即 PATH 环境变量）里有当前目录，所以不需要加。其实加上也是一样的效果。因为 Linux 的默认搜索目录里没有当前目录，所以如果你在当前目录需要执行程序就要加上路径。
>
> 三、理论上，如果要让当前目录下的文件不需添加“./”即可运行，只需将“./”加入路径参数PATH中即可，如下所示：
>
> export PATH=$PATH:./
>
> 但通常不建议这样做，这是基于安全性的考虑。若系统管理者所在的目录中有可运行文件，而该文件有问题时，被执行后会发生不可预测的问题。
>
> 例如：任何用户对 /tmp 都有 w 的权限，若某用户在 /tmp 之下新增 ls 这文件，而文件内容如下：
>
> ```
> /usr/sbin/useradd -m adm0
> /bin/ls
> ```
>
> 同时，将 PATH 的路径设为`export PATH=./:$PATH`，则当 root 进入 /tmp 并执行 ls 时，就会优先执行 /tmp/ls，而非系统默认的 /bin/ls，这样不知不觉中新增了一个用户 adm0。因此即使要将当前目录加入路径参数中，`export PATH=$PATH:./`的安全性也将优于`export PATH=./:$PATH`。

如果不想使用默认的可执行文件名"a.out"，使用g++ main.cpp -o hello；-o hello 写在main.cpp前面也可以。

### 4.基本语法元素

#### 数据类型

整数类型

整数的符号：确定是否表示负数

signed、unsigned；

定义b为无符号整数：unsigned int b；

整数的长短：确定整数取值范围的大小

long、short；

定义c为短整数：short int c

> 有时候我们需要的整数不需要表达那么宽，现在很多主流的计算机都是64位的CPU，宽度都是64位宽的；
>
> 但是现在我们使用的很多主流的编译器实际上都是32位的，包括我们用的一些应用程序还仍然保留在32位，因为对一个正常普通应用来讲32位程序是够用的；所以迁徙到64位相对于它的难度来讲大家的兴趣不大；现在主流的C++编译器仍然是32位的，int基本上都是32位的，能表达从-21亿到+21亿的数据范围，如果是unsigned的类型，可表达从0-42亿的数据范围。
>
> 有时候不需要这么大数字，这时候我们可以把这个整数再弄短一点，前面加一个short就短了；短多少看编译器，有16位的有8位的；在主流的编译器下面long int 就是int。

浮点数类型：使用double或float表示小数；首选double，精度更高。平时尽量不要用float，因为float的有效位数只有六位和七位。

#### 量与表达式

**表达式**定义：

操作数与操作符序列，表达运算过程。

**变量**

**文字与常量**：

整数类型文字：8进制很少用，16进制倒是蛮常用的。

常量的定义：程序执行期间其值不可改变的量。

**格式：const  数据类型  常量名称 = 初始值**

这里的=既不是赋值也不是等号，而是初始化符号。

常量的意义：解决直接出现的文字无法解释其意义的问题。比如孤零零的出现一个3.14，你说这个3.14是个什么？谁告诉你一定是圆周率了。const double pi = 3.14。

> # C++ 常量
>
> 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。
>
> 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
>
> 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。
>
> 在 C++ 中，有两种简单的定义常量的方式：
>
> - 使用 **#define** 预处理器。
> - 使用 **const** 关键字。

**赋值与初始化**：

变量的初始化只能做一次，而赋值可以随便做。

**操作符与操作数**：

操作符的优先级很复杂，分成了10多级，搞不清楚时就加括号，编译器会自动将不需要的括号去除。

**基本输入输出**：

输出（插入）操作符：<<

输入（提取）操作符：>>

cin >> a >> b；一般不要这么写，因为没有提示信息，用户不知道输入啥

### 5.程序设计风格

**注释**

同一种注释标记不可以嵌套

**命名规范**

字符集：ASCII字符集

标识符：区分大小写；

**不能以数字开头**：如果允许变量名开头是数字，则无法区分变量名和数字类型，例如：如果变量名 091合法，则程序无法区分这个变量和数字 091。另外，有些数字可能含有字母，如浮点数 1E10。程序设计语言不能存在歧义，因此，需要约定变量名开头不能是数字，以便区分变量与数字。

**宏与常量**

宏定义：

#define 指令：预处理命令

#define后面跟着两个部分：宏的名字及后面跟着的一大串（即宏想要对应的那个文本），注意它实际上是个文本，简单的文本替换，**后面不需要分号，如果有分号，分号就是替换文本的一部分了！**

例如：#define PI 3.14

一旦定义，可以替代常量使用；宏定义不是常量；程序中应优先使用常量而不是宏。

在编译的时候查找PI，然后全用后面的文本替换，替换完一遍才开始编译；有了const关键字后可以定义常量后我们很少再使用宏来定义像这样的宏文字。

**赋值语句的简写形式**

除赋：x / a

注意：到底是在整数上做操作还是浮点数上，是不一样的；对于操作数都为整数的，结果也是整数，舍去小数部分，比如 9 / 2结果是4而不是4.5；9.0 / 2 结果是4.5；除数与被除数有一个是double或float，结果就是相应的类型。

特别说明：x * = a +b 等价于x = x * (a+b)

**源代码的排版**

函数代码不超过60行，如果太长可拆成两三个函数，这样别人阅读和维护起来就更方便了；

标识符的命名规范应该是一致的；

**除非特别必要，否则不要在一行上书写多条语句。**

## 二.程序控制结构

### 1.结构化程序设计基础

**三种基本控制结构：**

顺序结构

分支结构：

有时候真分支这一路是存在的，假分支这一路，我们什么都不需要做时，那假分支可以省略；

循环结构

程序中常见的控制结构是分支和循环，当然架构整个程序本身的那个结构一定是顺序的；从数学角度上将，它实际上是一种时间严格偏序。

任何复杂结构都可以使用这三种控制结构来完成。

**复杂控制结构：**

控制结构可以嵌套，以构成更复杂的控制结构

### 2.布尔数据

只有真或假两种可能的数据量

#### 枚举类型

即一一列举，编程中有些很特殊的量，这些量的取值范围极其有限，比如自然月份。

月份就12个，如果你使用int来表达它，那实际上它可以取任何一个整数值，问题是如果你映射，1代表1月，2代表2月，12代表12月，那13代表啥？0代表啥？-1代表啥？就有一些量你用不到；但是你在程序中又不能限制它把13赋值给这样一个整型量，也即你不能限制它只能得到有效的月份，所以这种情况建议应该使用一个枚举型。

类型声明：

格式：enum 枚举名 {元素1，元素2，...，元素n}；

例：enum MONTH{JAN, FEB, ...}

枚举类型声明中的元素为枚举文字，不是变量。枚举值是常量不是变量，不能在程序中再为枚举元素赋值。

```c
enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};*

这句话有两个作用：
第一：声明enumType为新的数据类型，称为**枚举**(enumeration);
第二：声明Monday、Tuesday等为符号常量，通常称之为枚举量，其值默认分别为0-6。
接着利用新的枚举类型enumType声明这种类型的变量：enumType Weekday'就像使用基本变量类型int声明变量一样，如 int a;也可以在定义枚举类型时定义枚举变量enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;
但如果使用tpyedef enum {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;则表示将weekday定义为枚举类型不是变量。
```

**计算机怎么存储这个枚举数据对象呢？**

有个很特别的规则：内部把它映射为一个整数，最顶头的文字映射为0，往后依次加一；也可以更改默认的映射，将{JAN = 1，FEB，...}，这样月份从一开始映射。

枚举类型变量的定义：

例如：MONTH month；

然后这个month变量就可以赋值了，比如赋值为JAN等，但是不能赋值为数值，数值是int类型，而month是enum MONTH类型；两者类型不匹配。那么能不能将**枚举量**赋给**非枚举变量**呢？如：int a=Monday;这是允许的，因为**枚举量**是符号常量，这里的赋值编译器会自动把**枚举量**转换为int类型。

注意：枚举型不能直接输出，直接输出最终会转化为整数去输出。

> 也可以在定义枚举类型时定义枚举变量enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;
>
> 然而与基本变量类型不同的地方是，**在不进行强制转换的前提下**，只能将定义的**枚举量**赋值给该种枚举的变量，如：*Weekday = Monday;*或者Weekday = Sunday;不能将其他值赋给**枚举变量**，如：Weekday = 10;这是不允许的，因为10不是**枚举量**。也就是说Weekday只能是定义的Monday-Sunday这些定义过的**枚举量**。然而这不是绝对的，下面会讲到利用强制类型转换将其他类型值赋给**枚举变量**。
>
> 枚举型可以隐式的转换为int型
>
> ```c
> enum Suit{Diamonds,Hearts,Clubs}a;
> a = Diamonds;
> int n = 100;
> n = a;
> ```
>
> 也可以强制转换（int）date;(int)a，是类型强转化。

**enum的其他用法：**

在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量，言下之意就是可以**通过强制转换将其他类型值赋给枚举变量**：

*Weekday = enumType(2);*等同于：Weekday = Wednesday;但是，如果试图将一个超出枚举取值范围的值通过强制转换赋给枚举变量，会出现什么结果？

*Weekday = enumType(20);*结果将是不确定的，这么做不会出错，但得不到想要的结果。

**对于枚举，只定义了赋值运算符，没有为枚举定义算术运算。**

不能对枚举量进行算术运算，那么枚举量能不能参与其他类型变量的运算呢？int a;a = 1 + Monday;这是允许的，因为编译器会自动把枚举量转换为int类型。

```C++
也可以只显式的定义一部分枚举量的值：

enum enumType {Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday};这样Monday、Wednesday均被定义为1，则Tuesday=2，Thursday、Friday、Saturday、Sunday的值默认分别为2、3、4、5.总结：未被初始化的枚举值的值默认将比其前面的枚举值大1。
    
这还说明另外一个现象，就是枚举量的值可以相同。
```

**enum(枚举)可以没有枚举名**

如果声明枚举类型时没有指定枚举名，其作用就和#define类似，比如以下代码：

```C
enum {
    STATION_IDLE = 0,
    STATION_CONNECTING,
    STATION_WRONG_PASSWORD,
    STATION_NO_AP_FOUND,
    STATION_CONNECT_FAIL,
    STATION_GOT_IP
};
```

这里声明了一个枚举类型确没有指定其枚举名，那么它就相当于用#define定义了六个名称和其对应的值，从0开始赋值每次加1，相当于：

```c
#define     STATION_IDLE = 0;
#define     STATION_CONNECTING = 1;
#define     STATION_WRONG_PASSWORD = 2;
#define     STATION_NO_AP_FOUND = 3;
#define     STATION_CONNECT_FAIL = 4;
#define     STATION_GOT_IP = 5;
```

只不过eunm类型表示的是一个确定的值，而这里#define了六个值，**可见如果要表示同一个事件的不同反馈status，使用这种没有枚举名的枚举效果更好**。

枚举类型的意义：

将多个文字组织在一起，表达从属于特定类型的性质；取代魔数，使源代码更易理解。

#### 用户自定义类型

自定义类型：

格式：typedef 原类型标识 新类型名；

例一：typedef int DWORD；

自定义类型的性质：

新类型与原类型相同，类型性质一模一样，并未产生新类型，重新命名的自定义类型使程序更易理解。

**bool类型：**

取值：false、true；

这个三个关键字是C++里面有的，在C里面是没有的；如果写C程序，不能使用这个布尔类型。

bool量的定义：

定义：bool modified；

赋值：modified = true；某个数据对象有更新的话，那modified就给它设为true，没有更新就设为false。这样就可以通过modified这个值来决定我们数据有没有更新，这样就把这个数据持久化，这是一个非常重要的概念。

#### 关系表达式

关系操作符：共6种

逻辑值（布尔值）

C 语言以0表示假，以非0表示真（经常以1表示）。

C++里尽量使用bool类型表示逻辑值。

但是有的时候我们要写的程序代码涉及到很多Linux操作系统的功能，它的很多系统代码实际上是早期的代码，都使用C来实现的。所以C的很多架构我们还离不开。

#### 逻辑表达式

逻辑运算符：逻辑与（&&）、逻辑或（||）、逻辑非（!）

关系操作符与逻辑操作符的优先级：

从高到低顺序：逻辑非"!"；"<"、">="、">"、"<="(同级)；"=="、"!="(同级)；"&&"；"||"。

#### 逻辑表达式的求值

给定年份year，判断是否为闰年：

year % 4 == 0 && year % 100 != 0 || year % 400 == 0

实际上能够被8000整除的年份就不是闰年，但是现在才2020年，8000年一轮回的那东西我们一时半会不用去考虑。

### 3.分支架构

**If分支架构**的三种格式：

格式1：if(条件表达式) {语句序列}

格式2：if else 

格式3：if else if else

如果{}里就一条语句{}可以省略。

PS:若仅用于确定某条语句是否执行，else分支可以省略。单独出现if可以，如果有else一定要有一个if配对，两个if一个else没有问题，问题在于else与哪个if配对？

C/C++的配对原则：离它最近：距离最短；同层次：排除底层嵌套。

**switch分支结构**：

switch(表达式){}

switch后面的表达式必须为整型、字符型或枚举型；总之它能和整数形成一一对应。

break语句的目的：

终止switch语句的执行；case子句中的**常数表达式**仅起到语句标号的作用，不是分支之间的分隔标记，也即**只起到什么时候进入这条switch语句的作用**，并不能起到离开这条switch语句的作用，想要离开必须加break，没有break是不能够工作的。

### 4.循环结构

发生无限循环的场合：

循环体内没有改变循环变量值的语句；

即使改变循环变量值，也不能否定循环条件；

循环体内没有能够强制终止循环执行的语句或命令。

**偶尔也需要用无限循环做一些特别的处理：**

```C
//有些程序除非用户产生一个特别的明确的要求，我要结束，否则的话循环就应该不断地做下去；这种循环架构使用无限循环更合适。
```

用户给出结束条件的时候我们再退出，这种东西我们称为哨兵。

哨兵：使循环满足终止条件的循环变量值。

**for循环**

递增递减表达式的优先级非常高。

注意：不要在复杂表达式中使用递增递减操作符，因为它有可能给我们带来错误的结果。

for循环与while循环其实等价，可以互换使用。

> while常用于不需要或很少需要初始化的场合
>
> for常用于需要简单初始化和通过递增递减运算控制循环体执行的场合
>
> for循环将所有循环控制因素都放在循环头部，循环结构最清晰

for循环的初始化表达式可以不写，如果for循环真的需要初始化表达式，那么在for循环前面得加上；

步进表达式也可以不写，如果真的需要步进，那么在循环体的最后要加上步进表达式；

条件表达式也可以不写，那就是无限循环，内部应该要加上哨兵。

## 三.函数

### 1.函数声明、调用与定义

**函数调用**：主调（客户）函数与被调（服务器）函数。

**函数调用过程中为了保证调用没有问题，必须要为每一个函数书写正确的函数原型**，表达这个函数的实现和调用格式的标准说明。**正常情况下它将充当函数的接口，所以它一般出现在头文件里。**

格式：函数返回值类型 函数名称（形式参数列表）；

**函数定义**：不仅可以使用标准库里边提供的一系列函数来实现程序，还可以自己定义一些函数；函数的定义需要使用编程语言来给出函数的执行步骤，它的每一条代码应该怎么写，怎么装配，这个过程就叫函数的定义。

1）函数没有返回值时，只需直接写return；即可。C/C++的编译器还告诉你：当这样的return语句在函数最结尾的时候，其实不写也没关系。

2）程序中可以写很多条return，但遇到第一条return程序就结束了；多条return语句的返回往往都是出现在这样的if-else-if所有的分支上。

**谓词函数**：

编写函数IsLeap，判断某个给定年份是否为闰年

```c
bool IsLeap(int year)
{
	return year % 4 == 0 && year % 100 !=0 || year % 400 == 0;
}
```

谓词函数最重要的一个用途是：可以充当条件表达式，比如if(IsLeap(year))。必须会用！

**函数重载**：

定义同名但参数不完全相同的函数就叫函数重载。

参数不完全相同：参数的个数可以不一样，参数的类型可以不一样，参数的顺序也可以不一样。

示例：比较数值、字符、布尔型的大小

```c
int Max(int x, int y);
char Max(char x, char y);
bool Max(bool x, bool y);
```

没有函数重载时这三个函数不能同名。有了重载就可以，同名的好处是：调用的时候，明确的知道调用的是Max，从功能上将求的就是两个数的大小，管它这两数是整型还是字符型还是布尔型呢，名字固定就是Max，这样可以避免搞混淆。

注意：把所有函数写在main函数前面不好，原因就是别人看你代码应该一眼就看到我们的主函数才对；如果他看到太多我们自己写的内部函数的话，他就看到太多细节，然后再去理解这个主函数的框架就不太容易。**所以从理解和维护的角度上讲，应该先写主函数！所有的函数都应该写在main函数后面**。问题来了：写在main后面函数能运行么，不能，所以需要把函数的原型写在main前面！

```c
//先整体后局部的逻辑进行思考，俗称自顶向下，逐步求精。
//如果一开始就特别关注细节，就会导致一个问题：一叶障目，不见森林
//先从战略高度然后再从战术角度来实现我们的代码
```

### 2.函数调用栈框架

初学者非常容易忽略的：就是在程序启动的最初，应该给出整个程序功能性的简单说明，应该给出提示信息让使用这个程序的程序员或者用户知道这个程序的基本功能。所以我们要把整个程序的功能代码抽取成一个又一个的函数。

值传递的机制：

- 形式参数在函数调用时才分配存储空间，并接受实际参数的值
- 实际参数可以为复杂的表达式，在函数调用前获得计算
- 形式参数与实际参数可以同名，也可以不同名
- 参数较多时，实际参数值逐一赋值，它们必须保持数目、类型、顺序一致
- 值的复制过程是单向不可逆的，函数内部对形式参数的修改不会反映到实际参数中去（就是个一次单向动作，就在函数调用的时候发生那么一次，拷贝完成后，形式参数和实际参数的关系就割裂了）

整数互换示例第二版：

**使用全局变量**：写在using naemspace std；后面，函数原型前面；int a, b。从变量的定义开始到这个文件的结尾，中间这些代码中所有的函数都能够使用这两个量a和b，将被后面所有的函数所共享。

这种解决方案不太好，并不是每个函数都需要用这两个全局变量，但是你能限制某个函数不用它们么？

> 全局变量不易于管理，不像局部变量，在函数调用结束后会自动释放
>
> 1 全局变量是很好；
> 2 但是有缺点：容易被修改错，尤其在工程很大的时候；
> 3 使用时一定要控制好全局变量的修改；
> 4 不过小工程小项目使用全局变量是很方便的！
>
> 全局变量可以被所有的函数访问，所以全局变量的值（正确的、安全的）可能会被其他的函数无意间修改。程序的行为依赖值的正确，**如果全局变量的值被无意或者恶意修改就会导致问题。所以，不推荐使用全局变量**。基于此，某些编程语言是不允许修改变量的值的。(一旦第一次赋值，就不能再修改变量的值了)。

如果你的全局变量过多，就有可能给程序的正确性带来威胁。

## 四.算法

### 1.算法概念与特征

算法定义：解决问题的方法与步骤

设计算法的目的：给出解决问题的逻辑描述，根据算法描述进行实际编程

算法特征：

- 有穷性：算法在每种情况下都可以在有限步后终止（步骤）
- 确定性：算法步骤的顺序和内容没有二义性
- 输入：算法有零个或多个输入
- 输出：算法至少具有一个输出（如果返回值是void的，它的输出体现在当事情做完以后，计算机内部的状态发生了变化，比如Swap函数交换了两个数，x和y两个形式参数的值发生了变化啊，这个就是输出，隐含着了，并没有在函数的返回值里体现出来）
- 有效性：所有操作具有明确含义，并能在有限时间内完成（有效性表示时间是有限的）

**注意：正确性不是算法的特征，算法的正确性需要数学证明**。不知道怎么证明那就测试，测试你的程序的正确的，这样才行。

示例：如果查找单词Abort，按照人的思维这个单词在字典的前几十页，所以不会一开始就去查中间位置，这个是人的智力**启发方式**，编程的时候除非你使用了启发式，否则这个事情是做不了的，它不像你的头脑中可以做到这件事。我们编程机械语言不是那么容易做到的，我们能做到的最快的就是折半（二分）查找，除非你启发式，一开始就说A在哪一个附近，B在哪一个附近....，完全告诉它，在这样一个情况，既然首字母是A，直接去查A那一部分就完了，B以后部分全砍掉；这就叫启发式了，你的算法可以这么设计；**如果没有启发式，折半效率是最快的**。

### 2.算法描述

如果一个算法没有想清楚就去写代码，那写出来的代码质量基本是不高的，更有可能是你压根就写不出来。也就是这个问题在头脑中就已经完全明确到了应该如何去实现；如果不明确，那么这个算法就很难去真正编程。

**伪代码**

混合自然语言与计算机语言、数学语言的算法描述方法描述算法的过程和步骤，第一步做什么第二步做什么...怎么方便怎么来，采用其中一个也行混着来也行，你把这个事情讲清楚了，写出来它，这就叫伪代码。

优点：方便，容易表达设计者的思想，能够清楚描述算法流程，便于修改。

缺点：不美观，（一会计算机语言一会数学语言，或者全是自然语言，全是数学语言，全是计算机语言，都有可能，这么写在一起不美观，别人看复杂算法就不太容易理解），复杂算法不容易理解。

**流程图**(程序框图)

使用图形表示算法执行逻辑；

优点：美观，算法表达清晰；

缺点：绘制复杂，不易修改，占用过多篇幅。

流程图往往是我们算法都设计完了，最终形成设计文档给别人看的时候，这样绘制觉得漂亮，给别人看，印象深刻。

**平时写程序的时候往往都是使用伪代码。**

### 3.算法设计与实现

算法选择的权衡指标：

- 正确性：算法是否完全正确？
- 效率：在某些场合，对程序效率的追求具有重要意义
- 可理解性：算法是否容易理解，也是必须考虑的（让别人容易看懂，同时维护起来也方便）

通常，效率与可理解性是不可兼得的，所以：

算法评估：衡量算法的好坏，主要是效率；但是对于初学者，可理解性其实更重要！尽可能用简单的方式去实现哪怕效率低一点也可以接受。

### 4.递归算法

递归的工作步骤：

递推过程：逐步分解问题，使其更简单

回归过程：根据简单情形组装最后的答案

一个函数通过直接或间接的手段调用自身的动作就叫递归，这样的函数就叫递归函数。

**理论上，任何递归程序都可以使用循环迭代的方法解决**

**写递归算法时需要问两个问题**：

Q1：是否存在某种简单情形，问题很容易解决

Q2：是否可将原始问题分解成性质相同但规模较小的子问题，且新问题的解答对原始问题有关键意义

**递归信任**：

有时候，初学者初学者经常会觉得，这个递归函数能实现么？总是怀疑疑虑，这里要特别强调：递归它一定是能正确工作的，养成最基本的递归信任，不用去怀疑递归工作的基本原理。递归信任里我们能够注意到六个问题：

- 递归实现是否检查了最简单情形

  大多数情况下，递归函数以if开头，如果不是，要仔细检查源程序

- 是否解决了最简单情形

  最简单情形不能调用自身递归，可以调用与它无关的递归

- 递归分解是否使问题更简单

- 问题简化过程是否能够回归最简单情形，还是遗漏了某些情况

- 子问题是否与原始问题完全一致

  如果递归过程改变了问题实质，则整个过程肯定会得到错误的结果

- 使用递归信任时，子问题的解是否正确组装为原始问题的解

### 5.容错与计算复杂度

容错的定义：允许错误的发生

正常情况下我们应允许错误的发生，并且在错误发生的时候能够知道按照什么方式对它进行正确的处理。

典型容错手段：

对于用户输入错误：数据有效性检查

致命错误：程序流程的提前终止（放置错误扩散，造成更严重的后果）

## 五.程序组织与开发方法

### 1.库与接口

从库与接口的角度上讲，实际上C/C++的程序包括了两类文件

```c
程序文件：源文件（*.cpp）

头文件（*.h、*.hpp、*）
```

使用.h和.hpp后缀对头文件命名有助于编译器更好地管理程序

库：源文件与头文件

库从本质上讲是不会独立运行的，那就意味着不需要为它编写main函数。所以从库的设计角度来讲，源文件就包括了具体的实现代码，而头文件则提供了库的接口。想使用库就要通过库的接口来使用，正常情况下也就是.h/.hpp这样的头文件。

**接口**：

通过接口使用库：包括制定库的头文件与源文件

优势：不需了解库的实现细节，只需了解库的使用方法

C++标准库提供了一系列的功能有很多很多个接口，合在一起统称为标准库。标准库包含两部分：C的标准库，C++的标准库；两者是不一样的。写代码时两者皆可使用。

**其中数学库，在Linux和Wins下的处理的方式不太一样。**

在windows下面"math"事实上就是C标准库中的一部分，但是在Linux下数学库是单列的，缺省的时候是不链接数学库的，所以如果链接，就用"-l"链接特定库的选项，后面跟着就是库的名字；所以-lm（l为link，m代表math）

在C下头文件：math.h；C++下头文件：cmath。

库文件：libm

链接方式：g++ -lm main.cpp

如果使用数学库的函数，就必须把数学库链接进去。

**工具与辅助函数**

头文件：stdlib.h/cstdlib

常用函数：

```c
void exit(int status);
void free(void *p);
void *malloc(size_t size);
int rand();
void srand(unsigned int seed);
```

### 2.随机库

```c
#include <cstdlib>
//rand()特别简单，不带任何参数，生成的随机整数在[0,RAND_MAX]这个闭区间范围内，RAND_MAX这个值到底为多少，不同的操作系统对其定义不一样。
srand((int)time(0));
//程序运行过程中，srand()函数只能调用一次，如果生成一个随机数调用一次，那就不行了，因为生成一个随机数的运行时间是非常非常短的，生成一个然后再做一个种子，那时间都没变，每次都设置同样的种子，那随机数不就一样嘛。而且必须是在你生成第一随机数之前调用！
```

**接口设计原则**

四项基本原则：

1）用途一致

接口中所有函数都属于同一类问题（用途不一致，别人就很难用）

2）操作简单

函数调用方便（让别人很容易用），最大限度隐藏操作细节

3）功能充足

满足不同潜在用户的需求

4）性能稳定

经过严格测试，不存在程序缺陷

**设计随机数接口**

随机数库这个接口应该设计一些什么样的函数，提供什么样的功能。

rand()生成[0,RAND_MAX]，但是我想掷骰子，生成0-6之间的随机数；再比如我想生成1-52之间的某个数，模拟扑克牌。就是说能够随机生成在指定范围内的随机数，而不是固定范围内的随机数。第二点，我还要能生成指定范围内的随机小数，尤其是0-1之间的随机小数。这就是随机库两个最主要的功能。还有一个需要对它进行随机化，即设定随机数发生器的种子

```c
void Randomize();
int GenerateRandomNumber(int low, int high);
double GenerateRandomReal(double low, double high);
//就这三条函数原型
```

**随机数库测试**

单独测试库的所有函数

​		合法参数时返回结果是否正确

​		非法参数时返回结果是否正确，即容错功能是否正常

（每一个函数都测试，保证每个函数单独运行时没有问题）

联合测试

​		多次运行程序，查看生成的数据是否随机

​		测试整数与浮点数随机数是否均能正确工作

（混合在一块运行时也是没有问题的）

库的使用者只要知道在生成随机数之前一定要调用Randomize进行随机化。

怎么重新设计数据库让用户不需要调用Randomize？

### 3.作用域与生存期

#### 量的作用域与可见性

作用域：标识符的有效范围

可见性：程序中某个位置是否可以使用某个标识符

**标识符仅在其作用域内可见**，但是位于作用域内的标识符不一定可见

**局部数据对象**：

定义于函数或复合语句块内部的数据对象（包括变量、常量与函数形式参数等）

```c
int func(int x, int y)
{
	int t;
	t = x + y;
	//单独出现的花括号对用于引入嵌套块
	{
		//允许在块中定义数据对象，作用域仅限本块
		int n = 2;
		cout << "n = " << n << endl;
	}
	return t;
}
//c和c++允许单独的复合语句块--一对孤零零的花括号，n从定义到cout语句做完就无效了。
```

**全局数据对象**：

全局数据对象具有文件（全局）作用域，有效性从定义处开始直到本文件结束，其后函数都可直接使用。

若全局数据对象定义的文件被其他文件包含，则其作用域扩展到宿主文件中，这可能导致问题。不要在头文件中定义全局对象，因为放在头文件里非常容易被别人包含，一被别人包含作用域就会扩展过去，编译器很可能报错，因为**不允许定义同名的全局变量**！在一个工程项目里不允许定义全局变量，哪怕他们是在不同的文件里。

**函数原型作用域**：

定义在函数原型中的参数具有函数原型作用域，其有效性仅延续到此函数原型结束，不会延展到函数所对应的实现里面去；这就意味着原型里的参数和实现里的参数名字可以不一样！

**全局变量如果没有初始化，都自动的初始化为0**。

**注意**：如果复合语句块内有变量i，全局变量里也有i，那复合语句块内输出i时到底是哪个i呢？作用域它都在嘛，那就体现一个点，**可见性**嘛。全局变量i作用域很长，在复合语句块内不可见，原因就在于它被一个新定义的作用域更小的局部变量i覆盖了可见性。如果在复合语句块内非要访问全局变量i，可使用全局解析操作符，::i。

#### 量的存储类与生存期

生存期：量在程序中存在的时间范围。通俗的讲，就是这个量能活多长时间。

**C/C++都使用存储类来表达生存期**。

作用域与可见性表达的是量的空间特性，存储类表达量的时间特性。

一般来讲，C/C++代码里的量具有两类生存期，一个称为静态（全局）生存期，一个称为自动（局部）生存期。

- 全局数据对象具有静态生存期；也就是说它的生死仅与程序是否执行有关，程序运行它就出手了，程序结束它就死掉了。
- 局部数据对象具有自动生存期；生死仅与程序流程是否位于该块中有关。程序代码进入语句块，在语句块内部定义的局部变量就算出手了，离开了这个局部块，局部变量就死掉了；程序每次进入该块时就为该对象分配内存，退出该块时释放内存；两次进入该块时使用的不是同一个数据对象（人不能两次踏进同一河流）。

**static关键字**

修饰局部变量：静态局部变量

使局部变量具有静态生存期；程序退出该块时局部变量仍存在，并且下次进入该块时使用上次的数据值；因为static修饰的局部变量的生存期就像全局变量一样长；静态局部变量必须进行初始化，同时它不改变量的作用域，只改变生存期（即生命被拉长了，但存在的空间仍然没有发生变化）

**注意**：静态局部变量看上去就像全局变量一样，初始化在程序启动前就做好了，调用main函数之前该变量就被初始化了。

修饰全部变量

不表示将生存期拉长，而表示限定作用域，**只在本文件内部使用，其它文件不可见**。

#### 函数的作用域与生存期

所有函数具有文件作用域与静态生存期（空间尽可能大，时间尽可能长）

在程序每次执行时都存在，并且可以在函数原型或函数定义之后的任意位置调用。

**内部函数与外部函数**

内部函数：不可以被其它文件中的函数所调用

函数缺省时均为外部函数

内部函数定义：使用static关键字

示例：static int Transform(int x);static int Transform(int x){...}

注意:**内部函数不能把它写在所对应的头文件里**

**声明与定义**

声明不是定义。定义是在程序产生一个新实体，声明仅仅在程序中引入一个实体，不创造只是引入，这个实体可能是别人替我们创造的，可能是我们在另外一个文件中创造的。

**函数的声明与定义**

对于函数来讲，声明就是给出函数的原型，定义就是给出函数的编码实现。如果产生一个新的类型那就叫定义，如果新的类型没有被产生那就是声明；定义一定会构造出新的型来，而声明是没有构造出来。

**全局变量的作用域扩展**

全局变量的定义不能出现在头文件里，只有其声明才可以出现在头文件中。（如果定义出现在头文件里，工程项目中很多文件include该头文件时，就会出现重复定义，编译器是通不过的；想要全局变量跨文件使用，又不能重复定义，怎么办呢，有个技巧，使用external关键字）

声明格式：使用extern关键字

```c
/*库的头文件*/
//此次仅引入变量a，其定义位于对应源文件中
extern int a;//变量a可导出，其他文件可用;将变成变量的声明，而不是定义

//库的源文件
//定义变量a
int a;
```

#### 典型软件开发流程

软件工程概要

问题的提出

- 需求分析
- 概要设计
- 详细设计
- 编码实现
- 系统测试

经验总结

从软件工程角度来讲，真实的开发程序实际上要通过以上5个步骤才能完成，没有这些流程，程序的开发实际上是非常困难的。

**软件工程概要**

需求分析：确定软件需要解决什么问题

决定因素：人

​		软件开发人员需要与用户深入交流，明确问题的输入、输出以及其他附加信息。

​		从设计程序的角度上来讲，**不要轻视任何问题**，因为哪怕是最简单的问题，用计算机语言实现起来可能都是非常复杂的。

**方案设计：设计程序框架**

**分为概要设计与详细设计**

概要设计：设计总体方案，形成高层模块划分

详细设计：细化模块，获得各模块的输入、输出与算法

有了概要设计，有了总体方案，那么就可以向总体方案中填充细节，包括每一个模块的输入、输出和算法，都要在概要设计里完成。有了概要设计之后，其实已经明确了程序中要设计什么样的函数，设计什么样的模块，如果具体到某一个特定的函数的话，那么每一个函数输入是什么、输出是什么、算法是什么，所有的信息理论上都应该完成，有了它就可以很容易地编写程序代码。

**编码实现：实际编程**

**系统测试：测试程序的正确性与稳定性**

这里面的每一个过程都有可能会产生一种反馈，修改原来的设计、原来的分析、原来的实现，形成一个螺旋式的开发流程。这种情况就是最常见的软件开发过程。

**有了概要设计其实就决定了程序的主体框架是什么。**

**系统测试**

**真实测试的时候可能就是干脆直接输出实际的价格，不然真的自己去猜去玩这个有效那测试效率太低了！**

所有数据对象是否已经正确初始化？

随机生成的价格是否合理有效？测试过程可能需要在源程序中添加必要的测试代码，例如：

```c
double PlayGame()
{
    ...
    actual_price = InitializeBout();
    #ifndef NDEBUG
    	cout << "Debugging:Actual price = " << actual_price << endl;
   	#endif//结束这个条件判断
    ...
}
```

那么在真实程序运行的时候，cout这段输出肯定是不能要的，程序真正发布的时候这行代码是要删掉的，可是如果总是一开始测试的时候贴上去，后来又删除，那当代码量很大的时候很难删的，一不小心就删错了。

在这种情况下就有个小技巧。凡是用于测试的这些输出在未来都不应该出现，用一个宏包起来，#ifndef（它是一个条件编译指令），作为一个宏测试，意思是如果没有定义，NDEBUG为宏的名字，那么编译器就编译cout这条语句，程序运行的时候就会执行这段代码；如果你定义了这个宏，那么它里面封包的cout这条语句就不编译了，所以就不需要你删除，想去掉这样的cout语句，很简单，在程序的最开头写上一行，

```c
#define NDEBUG
```

**经验总结**

Q:这个问题一开始大家认为它难不难？

A:不难

Q:程序设计难不难？

Q:难，如果要程序员从系统分析、方案设计开始做起的话

Q:编码难不难？

A:不难，与系统分析与设计相比编码实在简单，不过就是使用了所有代码控制结构和函数编写原则而已。

## 六.复合数据类型

### 1.字符

**字符类型、字符文字与量**

定义格式：char ch；const char cch = 'C'；

字符文字使用单引号对

**实际存储时字符类型量存储字符的对应ASCII值**

可使用signde与unsigned修饰字符文字；缺省的情况下它是signed。正常情况下我们不需要对它进行限制，即使用unsigned。

这个字符的存储一般有多大呢？正常情况下使用8位，也就是一个字节来存储它。表达范围实际上是在-128~127之间。

如果是unicode字符，则使用2个字节存储。

ASCII码表示的字符的整数范围为0-127。ASCII值'\0'在计算机内部保存的时候，保存的其实就是0。而真正的数字0在计算机内部保存的时候，事实上保存的是ASCII码值48。

实例：判断某个字符是否为数字（0-9）

```c
//不能写在‘0’~‘9’之间，而是在48-57之间
```

**标准字符特征库**

在C++里边提供了一系列标准字符运算，当然实际上这是C代码，C的函数库里边包括了一系列字符特征，库函数它写在"ctype.h"这个头文件里，用C++模式包含这个头文件的时候，你就可以写"cctype"。

### 2.数组

**数组的意义与性质**

数组的定义：

定义格式：元素类型 数组名称[常数表达式]

示例：int a[8]; //定义包含8个整数元素的数组

**特别说明**：常数表达式必须是常数和常量，不允许为变量。

```c++
const int count = 0;
int c[count];
//大多数编译器这样可以通过，但是在C程序里这样不行，只能为常数才行 
```

数组的存储表示

数组元素的访问

数组与函数

多维数组



## 七.指针与引用

引用是一个和指针相关的一个新的数据类型，和指针非常相似，但是又完全不同，某些方面它起到的作用和指针是相同的，但是在具体的实现上，和指针实际上是截然不同的。**它不仅是一种新的数据类型，它事实上还是一个新的参数传递机制**。

### 1.指针基本概念

每一个变量，也就是说每个数据对象，它有四个基本特征：VANT。一旦你的程序编译完成后，N（name）和T（type）就没了，正常情况下，信息是缺失的，在我们的程序代码里面，实际上主要就那么两个东西：一个是地址，一个是值。

**数据对象的地址与值**

地址：数据对象的存储位置在计算机中的编号

值：在该位置处存储的内容

地址与值是辩证统一的关系，通过一种恰当的机制，我们可以让一个量的地址就是值，可以让一个值就是一个地址。**这个机制就叫指针**（它就是构造地址和值辩证统一的最重要的一个桥梁）。

#### 指针的定义格式

格式：目标数据对象类型*指针变量名称；

例一：定义p为指向整数的指针：int * p；

```c++
int *p; //*号前有空格，可以是任意个空格
int* p; //*号后有空格，可以是任意个空格
int*p; //*号前后都没有空格
int * p; //*号前后都有空格，可以是任意个空格
//在定义的代码中，有一个*代表指针，有两个*就代表指向指针的指针，有三个*就代表指向指针的指针的指针~~~
//这个写法看个人习惯，其实如果*靠近返回值类型的话可能更容易理解其定义。

int *a;
int* a;
两者意思相同且后者看上去更为清楚:a被声明为类型为 int* 的指针. 但是,这并不是一个好技巧,原因如下:
int* b, c, d;

人们很自然地以为这条语句把所有三个变量声明为指向整形的指针, 但事实上并非如此. 我们被它的形式愚弄了. 星号实际上是表达式 *b 的一部分, 只对这个标识符有用。 b 是一个指针, 但其余两个变量只是普通的整形. 要声明三个指针, 正确的语句如下:

int *b, *c, *d
```

> 上述四种写法编译都没有错误，在定义中的 * 号我们现在可以理解为这仅仅代表定义了一个指针变量p, p的类型是 int * 或者 int* 。
>
> 之后要讲到 * 的 “取地址中的内容” 这个意思，那么这个 * 号和定义中使用的 * 号，是一个意思么？
>
> 我们先从 * 和 & 后边接的变量以及作用说起，之后再对第一篇文章中讲解的指针的定义进行更加深入的理解
>
> **& 和 * 可以理解为对紧接在后边的变量进行一定的信息提取**
>
> & 和 * 后边紧接的都是变量，但后边接的变量有所不同，& 后边紧接的是存放真实数据的变量（整型变量 a 或者是字符变量 b等），而 * 后边紧接的是存放地址数据的变量（比如int * 类型的变量或者char *类型的变量）
>
> &a 意味着提取变量 a 的地址，我们想要知道 a 放到哪里了
>
> *p意味着提取变量p里存放的地址所对应的存储空间里存放的真实数据，我们想知道这个地址处放了什么内容，101教室上的什么课。
>
> 知道了 * 符号代表的意思，我们来看一下上一篇文章讲的指针的定义~
>
> ```cpp
> int *p;
> ```
>
> 定义一个int型数据 a 时，是这样的语句 int a; 我们不妨类比一下，把 *p 先看成一个整体， *p 就是一个整型变量。
>
> *p是一个整型变量，我们讲 * 后边接的变量是一个指针变量，那么 p 就是一个指针变量了，那么 p 就是存放 *p 的内存的地址；
>
> *p 是一个整型变量，同时我们能得到 &*p 就是存放 *p 的内存的地址；
>
> **最终我们得到 p=&*p** 

含义：定义一个指针类型的变量名字叫p，它是一个指针，指向一个整数；把这个写法倒过来看，定义一个变量，名字叫p，它是一个指针，指向一个整数。

多个指针变量的定义：

例二：int * p，* q；

如果怕忘记第二个变量的*，可采用如下方式：typedef int * PINT；PINT p,q；如果写PINT p, * q；那么q指向PINT，即指向指针的指针。

#### 指针变量的存储布局

在使用指针的时候**一定要记住**：指针数据对象事实上涉及到两个数据对象，并不是只有一个，一个就是指针数据对象本身，第二个就是指针所指向的目标数据对象。

如果你在定义这个指针变量过程中，同时对它进行初始化，那么这个时候就会涉及到两个数据对象。

> 一定一定记住一点， **指针和变量一样，也是有值的，只不过变量的值被解释成一个值，而指针的值被解释成一个地址。**

定义指针变量，**并使其指向数组首元素**：

例三：int a[8] = {1,2,3,4,5,6,7,8};int * p = a;

p作为一个指针，只能指向一个整数，并不能指向8个整数，即p指向数组的0号元素。

**指针变量可以像普通变量一样赋值**

示例：

```c++
int n = 10; 
int *p = &n, *q;
q = p;
//两个指针指向同一个目标数据对象
```

#### 取址操作符“&”

获取数据对象的地址，可将结果赋给指针变量（得到的地址像一个普通的值一样赋值给指针变量）

#### 引领操作符

获取指针所指向的目标数据对象

用* p去引领p所指向的目标数据对象，p指向n，那* p就代表这个指针p所指向的目标数据对象n

#### 指针的意义与作用

**作为函数通信的一种手段**

使用指针作为函数参数，不仅可以提高参数传递效率，还可以将该参数作为函数输出集的一员，带回结果；（和外界进行通讯的时候，函数可以有一个返回值或者没有，它只能带回来一个结果，如果想带回来两个以少的结果怎么办呢？把它的两个结果合成一个结构体，用这个结构体作为函数的返回值，它就可以把这个同时都带回来；还有一种方案，指针作为函数参数，它就可以把这个结果带回来）

**作为构造复杂数据结构的手段**

使用指针构造数据对象之间的关联，形成复杂数据结构

**作为动态内存分配和管理的手段**

可以在程序执行期间动态构造数据对象之间的关联

**作为执行特定程序代码的手段**

使用指针指向特定代码段，执行未来才能实现的函数

**<font color = "00aaee">这四种使用场合务必掌握！</font>**

### 2.指针与函数

一个结构体的尺寸往往会很大，你要传结构体，那么结构体得整体赋值，如果传指向结构体的指针，那么它只需要赋结构体的地址就行了，结构体的地址有多大呢？32位的计算机、32位的编译器，它的尺寸是固定的4个字节。

**注意**：示例中main函数中写了swap函数，在main函数里有两个量m，n，调用swap时实际上是覆盖了这个main函数的栈框架，所以在swap执行过程中是看不见main函数的数据的，实际上是不能访问m和n的值的，也就是说不能在swap中使用main函数的m和n，并不表示它们不存在，只是我们没办法通过名字m和n来访问它们。现在我们有指针了，可以用* x，* y访问，* x就是m，* y就是n。

> 变量的作用域（生命周期）可以通过所在du的大括号界别来确定；
> main里定义的变量，是在main的大括号里， 所以在test的大括号是访问不到的（他们不是包含的关系）
> 而类的那个，定义的成员变量（字段）是属于class的大括号，而里面的方法的大括号是class大括号里面的（包含），所以是可以访问到的

#### 常量指针与指针常量

常量指针：指向常量的指针

性质：不能通过指针修改目标数据对象的值（即不可以通过引领操作符来修改目标数据对象的值），但可以改变指针值，使其指向其他地方。

```c++
示例一：
int n = 10; const int *p = &n;
```

典型使用场合：作为函数参数，表示函数内部不能修改指针所指向的目标数据对象值。

```c++
示例二：
void PrintObject(const int *p);
//限定了指针p只能作为函数输入集的一部分，不能作为函数输出集的一个部分
```

指针常量：指针指向的位置不可变化

性质：不可将指针指向其他地方，但可改变指针所指向的目标的数据对象值

**<font color="00aaee">指针常量和其他常量一样，必须在定义的时候初始化！</font>**

```c++
示例三：
int n = 10;
int * const p = &n;
//这个时候必须把它初始化为&n；因为p是一个常量，不可以被赋值，所以你定义它的瞬间必须初始化。
//前面的常量指针你不初始化是可以的，然后再赋值p=&n
```

常量指针常量：指向常量的指针常量（指针的双重只读属性）

```c++
示例四：
const int n = 10;
const int * const p = &n;
//const关键字实际上是左结合的，它作用在它左边的标记上面，
const int * p = &n;//const左边啥都没有，这个时候就只能作用它右边的int上面，它不作用在*上面，也不作用在int *上，表示那个整数是常量。
//如果严格按照const的左结合，那么const int应该写为int const，所以示例四中的第一个const写在int前或者后都是对的，第二个const一定要写在*后边。
```

典型使用场合：主要作为函数参数使用（大部分情况下不需要搞这么复杂，主要使用常量指针）

#### 指针与函数返回值

指针类型可以作为函数返回值，它会带回来一个目标数据对象的地址，但是指针作为函数返回值的时候，它不能返回函数内部定义的局部变量的地址，只能返回某个全局变量的地址或者作为函数的参数传给函数的指针。

```c++
程序示例：
int global = 0;
int * ReturnPointer()
{
return &global;
}
```

网上查找补充知识点：

**指针函数与函数指针**

指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，**而该函数的返回值是一个指针**（即地址值）。
声明格式为：类型标识符 *函数名(参数表)

```c++
int* fun(int x,int y);
```

函数指针，**其本质是一个指针变量，该指针指向这个函数**。总结来说，函数指针就是指向函数的指针。
声明格式：类型说明符 (*函数名) (参数)

```c++
int (*fun)(int x,int y);
```

函数指针是需要把一个函数的地址赋值给它，有两种写法：

```c++
fun = &Function;
fun = Function;
```

取地址运算符&不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。
调用函数指针的方式也有两种：

```c++
x = (*fun)();
x = fun();
```

两种方式均可，其中第二种看上去和普通的函数调用没啥区别，如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。当然，也要看个人习惯，如果理解其定义，随便怎么用都行啦。

### 3.指针与复合数据类型

#### 指针与数组

数组基地址：&a或者a

数组首元素地址：&a[0]

数组第i个元素地址：&a[0]+i*sizeof(int)

**数组基地址与首元素地址数值相同**，故：数组第i个元素地址可表示为a+i*sizeof(int)

**指针运算**

指针与整数加减运算的结果仍为指针类型量，故可赋值。

设p为指向整数数组中某元素的指针，i为整数，则p+i表示指针向后滑动i个整数，p-i表示指针向前滑动i个整数。

**规律**：以指针指向的目标数据对象类型为单位，而不是以字节为单位。

递增递减：p指向a[0]，则p++指向a[1];p指向a[1]，则--p指向a[0]

指针减法运算：两个指针的减法运算结果为其间元素个数

过尾元：让一个指针指向数组0号元，在数组最后增加一个元素，让另一个指针指向它，两个指针相减即得到数组的长度。

关系运算：p==q测试两个指针是否指向同一个目标数据对象

**空指针**：NULL

​	指针值0：表示指针不指向任何地方，表示为NULL；其实它指向的是内存条最开头的存储区。不过现在主流的操作系统，几乎所有的操作系统在那个存储区都是什么数据都不保存的，专门就用来捕获指针错误的。

例：设p为指针，则p=NULL表示p不指向任何目标数据对象

**特别注意**：使用指针前一定要测试其是否有意义，if(p != NULL)或if(p)；当你在编写带有指针的程序的时候，它非常容易出错，如果这个指针是错的，它指向一个无意义的地方或者它没有权利去访问的地方，这个程序不是错的而是崩溃，这个错误就太严重了，所以每次使用指针都要注意这点！每次访问指针，想通过引领操作符访问它的目标数据对象的时候，都要测试这个指针是不是有意义。

指针数据对象，理论上来讲，你应该对它进行初始化。要么是合法有效的目标数据对象的地址，要么就是0。只有这样才能保证你的测试每次都是有意义的。因为如果你不对它初始化，它是个全尽量，自动被初始化为0，如果这个指针变量本身是个局部量，那么它内部的位序列就是随机的，极有可能不是0。如果不是0，你一访问，目标数据对象区域没有权利访问的，程序一下就崩了。

**作为函数参数的指针与数组**

```c++
*p++ = GenerateRandomNumber(lower_bound, upper_bound);
```

*p++，这是两个操作符 * p、p++，因为是后缀++，所以是把函数调用后生成的那个整数赋值给 * p，然后才能做p++。它做的绝不是（* p）++，不是（* p），如果你是想把* p这个目标量累加，那么你必须写（* p）括号完毕后++那才对。p一开始指向0号元，所以把生成的那个数赋值给0号元，然后p++让p指向1号元。

指针作为函数参数：函数调用

​	必须传递已分配空间的数组基地址，比如int a[8]。

#### 指针与数组的可互换性

指针一旦指向数组的基地址，则使用指针和数组格式访问元素时的地址计算方式是相同的，此时可以互换指针与数组操作格式：p[i]与*（a+i）分别与a[i]与 * (p+i)的功能是一样的。但是并不表示此时指针与数组真的等价。在某种程度上讲，指针和数组的等价的，可以互换，**注意**，这并不是全部的应用场合，在一维数组上是有效的，在高维它可能就是无效的了。

指针和数组真是完全等价的吗？当然也不是，它还是有一些例外的。数组名本身它是一个常数，此时不能在数组格式上面进行一些特定指针运算的；比如：

```c
for(int i = 0; i < 3; i++)
	cout << *a++ <<endl;
//可以写*a+1，*a+2等，但是不能写*a++；因为a++它是a+1赋值给a，因为a是一个常数，它不能被赋值。
//而*p++可以，它是指针量
```

#### 指针与数组的差异

```c
int a[3] = {1,2,3};
int *p = &a; //会为p分配一个存储空间，这个存储空间有多大呢？我们现在32位计算机、32位的编译器，p是四个字节，int a[3]是12个字节，

```

定义数组的同时确定了数组元素的存储布局：a为静态分配内存的数组；若a 为全局数组，则程序执行前分配内存；若为局部数组，则在进入该块时分配内存。

定义指针时规定指针数据对象的存储布局：**p** 为指针，若 p 为全局变量，则程序执行前分配内存；若为局部变量，则在进入该块时分配内存。

**注意**：**定义指针的时候，规定的是指针数据对象的存储空间**，定义数组的时候，它规定的是数组元素的存储空间。这两者是不一样的。如果你定义一个指针，它就不会为那个数组分配空间，它只分配指针这个对象的空间，如果这个指针指向那个数组，你必须保证那个数组已经分配了，其他地方分配的跟这个指针没关系，**除非你是动态分配的**。

定义指针时未规定目标数据对象的存储布局：**p** 为指针，指向一个已存在数组的基地址，即指向该位置处的整数 a[0]；若a未初始化，则目标数据对象未知。

**所以**：使用指针时，指针这个对象和指针所指向的目标数据对象两者之间的关联在你的程序里必须显示地构造它。

#### 多维数组作为函数参数

不能每维都不传递元素个数，语法规则不允许，二维数组只能第一个中括号里什么都不写，三维数组里也只能第一个中括号里什么都不写，后面的你都必须给写上，没有数据是不对的，编译器是通不过的。所以采用另一种方案，把二维数组当一维数组降维，但是找具体的a[i] [j]，使用运算a+n*i+j运算有点麻烦，到了高维数组以后要这么运算，能不能算出来都不好说了，到了高维降维都有可能出问题；而且从逻辑上讲明明是二维搞成一维有点怪怪的。

那么有没有一个妥当的方案呢？没有，不管是C还是C++里，当多维数组作为函数参数传递的时候，就没有一个好方案能够解决这个问题。所以实在没招，建议按照第一个方案写：

```c
void PrintTwoDimensinalArray(int a[8][8], unsigned int m, unsigned int n);
```



#### 指针与结构体

**访问指针所指向的结构体对象的成员**

必须使用括号：选员(.)操作符优先级高于引领操作符，比如：（*pstudent).id

C/C++提供了一个新的操作符，选员操作符"->"，比如pstudent -> id

**结构体成员类型维指针**

```c
struct ARRAY{ unsigned int count; int * elements; };
int a[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
ARRAY array = { 8, &a };
//访问指针类型的结构体成员
//访问 elements 的第 i 个元素： array.elements[i];也就是把element当作数组用
```

```c
//若有定义：ARRAY * parray = &array;

访问parray指向的结构体对象elements的第i个元素：

//(*parray).elements[i]或parray->elements[i]
```

#### 结构体指针的使用场合

有两个非常重要的使用场合：

​	**使用指向结构体对象的指针作为函数参数**

```c
好处一：节省结构体整体赋值的时间成本
好处二：（普通结构体类型的参数作为参数传进去，它不能把结果带回来，我们就觉得不方便，想带回来结果，传它的指针，结果就能带回来了）解决普通函数参数不能直接带回结果的问题，可以在函数内部改变目标结构体对象的值
//你又想快，又不想带回来结果，就指向const结构体的指针
```

​	**构造复杂的数据结构**

```c
我想创建一个数据结构，这个数据结构能够表达动态的数组信息，表达数组元素个数，可以在整个程序运行期间，随时发生变化的数据结构，它里边保存了一系列元素，这些元素的个数可以在程序运行期间动态的变化，可以大也可以缩小，这个我们就称它为动态数组，我们就需要使用很特殊的像这样的数据结构
动态数组：struct ARRAY { unsigned int count; int * elements; };
//count为数组元素的个数，然后用一个int * element来表达指向特定元素的指针，以后就可以通过element指针的运算来访问它的0号元、1号元、2号元；你定义好这个数据结构必须为它创建一系列对动态数组进行操作的函数
```

### 4.字符串

字符串的表示

三种理解角度：作为字符数组，作为指向字符的指针，作为抽象的字符串整体

#### 多个字符数组连续存储时的问题

如何区分存储空间刚好连续的多个字符数组?

解决方案：字符数组末尾添加结束标志'\0'，'\0'即ASCII码值为0的那个字符

**优** **点**

可以在程序运行时通过测试‘\0’字符确定字符数组是否结束，而不需要了解数组元素个数，使处理元素个数未知的数组成为可能通过指针运算直接操作字符数组中的字符，而不再使用数组格式访问字符元素

**字符指针量的定义、初始化与存储**

char *s = "CPP-Prog"；

s作为一个指针它会分配一段存储空间4个字节，里面保存字符串的基地址，而那个字符串基地址里面会分配9个字节，来存"CPP-Prog\0"。注意，这里面双引号字符串文字尾部的'\0'是编译器为我们自动添加的。

**特别注意**：不管char *, int *, float *,所有类型的指针变量在32位系统上都是4字节， 64位系统上都是8字节。

**用char *s定义的时候它会多一个指针变量**

#### 字符数组与字符指针的差异

①按指针格式定义字符串，可以直接赋值

```c
示例：
char * s; 
s = "CPP-Prog"; // 正确
//字符串文字首先分配空间，然后将其基地址赋给 s，使 s 指向该字
//符串基地址
```

②按字符数组格式定义字符串，不能直接赋值

```c
示例：
char s[9]; 
s = "CPP-Prog"; //** **错误**

//不能对数组进行整体赋值操作
//char s[9]会分配9个字符的存储空间，然后“CPP-Prog”它本身也要分配9个字符的存储空间，保存进去，然后把这个基地址赋值给s，赋值不了，s是个数组，它必须接受9个字符，而不是接受9个字符的基地址。
//原因：数组空间已分配，字符串文字空间已分配，且它们位于不同位置，不能直接整体复制
```

示例：编写函数，将某个字符c转换为字符串

```c
typedef char * STRING
STRING TransformCharIntoString( char c )
{
 STRING _s = (STRING)malloc( 2 );
 _s[0] = c;
 _s[1] = '\0';
 return _s;
}
//分配2个字节的存储空间，分配出来的空间转换为STRING，然后把它初始化或赋值给STRING类型变量_s
```

```c++
char * TransformCharIntoString( char c )
{
 char _s[2];
 _s[0] = c;
 _s[1] = '\0';
 return _s;
}
//错误函数定义
	对于所有返回值为指针类型的函数，都不能返回在函数内部定义的局部数据对象——所有局部对象在函数结束后不再有效，其地址在函数返回后没有意义
```

#### 标准字符串库

**标准库中关于字符串处理的函数很多，均定义于头文件“cstring”中**，用C++的就包含“string”。

如果写C++，不建议使用标准字符串库，使用string类代替。

**string类**

```c
定义于头文件“string”中
声明与构造string对象
string s = "abcdefg"; //定义s然后把它初始化
string s( "abcdefg" ); //直接构造的时候对它初始化，这种方式更好
读取与写入string对象
cout << s << endl;
cin >> s; // 读取以空格、制表符与回车符分隔的单词
getline( cin, s, '\n' ); // 读取包含空格和制表符在内的整行
//从cin这个输入流里面去读取，然后把这个东西读到s字符串里面去，最后的'\n'表示以它结尾，读的是一整行
```

①获取string对象的长度

使用length()函数，从属于string类这个对象的。

②改变string对象的容量大小

s.resize(32); // 将s设为32字符长，多余舍弃，不足空闲
s.resize(32, '='); // 多余舍弃，不足补‘=’

③string对象的追加操作

string s1 = "abcd", s2 = "efg";
s1.append( s2 ); // 将字符串s2追加到s1尾部

或者更简单直接使用’+‘，提供了重载操作符，可以直接使用。

④string对象的比较操作

string s1 = "abcdefg", s2 = "abcdxyz";
int a = s1.compare( s2, 0 ); // 从0号位字符开始比较

⑤string对象的查找操作

string s1 = "abcdefg", s2 = "bcd";
int a = s1.find( s2, 0 ); // 从字符串开头开始查找，结果为
s2在s1中首次出现的位置

### 5.动态存储管理

#### 内存分配与释放

①静态内存分配方式

适用对象：全局变量与静态局部变量

程序运行前分配好，程序结束了它就释放

静态的方式分配的这些内存它的生存期是巨大的，它就和我们的程序一样长。实际上比我们真正的main函数运行还要长，它在main函数之前就能分完，main函数做完了它才能够销毁。

②自动内存分配

适用对象：普通局部变量
分配与释放时机：在程序进入该函数或该块时自动进行，退出时自动释放

③动态内存分配方式

你想让它什么时候分配就什么时候分配，想让它什么时候销毁就什么时候销毁，全由程序员编程说了算。

动态内存分配的目的
	静态与自动内存分配方式必须事先了解数据对象的格式和存储空间大小，部分场合无法确定数据对象的大小

动态内存分配的位置
	计算机维护的一个专门存储区：堆
	所有动态分配的内存都位于堆中

动态内存分配的关键技术
	使用指针指向动态分配的内存区
	使用引领操作符操作目标数据对象

​	也就是说没有指针这个动态内存分配是做不到的。

#### 标准库的动态存储管理函数

```c
动态存储管理函数的原型
头文件：“cstdlib”和“cmalloc”，两者包含其一即可
内存分配函数原型：void * malloc( unsigned int size );
内存释放函数原型：void free( void * memblock );

```

**void * 类型**

**<font color="00aaee">一个非常非常非常重要的数据类型</font>**

称它为哑型指针，特殊的指针类型，它非常特殊。

它表示指向的目标数据对象类型是未知的，它是一个指针没错，指针的目标数据对象类型void也没错，不是说它的目标数据对象没有类型，目标数据对象一定是有类型的，但是它的类型是什么呢？我不知道。

所以你绝不能在其上使用引领操作符访问目标数据对象

> This gives `void` pointers a great flexibility, by being able to point to any data type, from an integer value or a float to a string of characters. In exchange, they have a great limitation: the data pointed to by them cannot be directly dereferenced (which is logical, since we have no type to dereference to), and for that reason, any address in a `void`pointer needs to be transformed into some other pointer type that points to a concrete data type before being dereferenced.
>
> ---cplusplus.com/doc/tutorial/pointers
>
> ---它们指向的数据不能直接解引用(这是符合逻辑的，因为我们没有类型可以解引用）

可以转换为任意指针类型，不过转换后类型是否有意义要看程序逻辑
可以在转换后的类型上使用引领操作符（或称解引用操作符）

主要目的：作为一种**通用指针类型**，首先构造指针对象与目标数据对象
的一般性关联（我用一个指针，指向一个东西，那个东西类型是什么我现在还不知道，那我就用void * 指针，然后指向它），然后由程序员在未来明确该关联的性质（这就是void * 最重要的一个地方）

所以在C语言里，它是通用的类型，什么东西都可以表示，因为如果它不能表示，它一定能够表示那个东西的地址，比如那个结构体 void * 不能表示，但是我能表示指向结构体的指针，能够表示那个结构体的地址啊，int * 它也能表示，实际上因为在32位编译器下边，它这个void * 指针尺寸是固定的4个字节，如果int刚好也是四个字节呢，int就可以直接转换成void * ，反正尺寸是够的，你直接传进去就行了。它是通用的一个型。

1）malloc与free

示例：编写函数，复制字符串

```c
char * DuplicateString( char * s )
{
 char * t;
 unsigned int n, i;
 if( !s )
 	{ 
     	cout << "DuplicateString: Parameter Illegal."; 			exit(1);
 	}
 n = strlen( s );
 t = ( char * )malloc( n + 1 );
 for( i = 0; i < n; i++ )
 	t[i] = s[i];
 t[n] = '\0';
 return t;
}
//这个地方指针是不能直接赋值的，直接赋值那两个指针都指向目标字符串了
//这个字符串的构造我们一定要动态地构造，因为在调用这个函数之前，我压根就不知道s所指向的那个串有多少个字节，所以你没有办法预先假定新的串的存储空间要多大合适，你只能按照这个方式来，给我多长就分配多长。
```

特别说明：有分配就有释放

**free 函数释放的是 p 指向的目标数据对象的空间，而不是 p 本身的存储空间**，p本身不需要销毁，它要么是全局量，要么是局部量。

调用 free 函数后，p 指向的空间不再有效，但 p 仍指向它

为保证在释放目标数据对象空间后，不会再次使用 p 访问，建议按照下述格式书写代码：

```c++
free(p); 
p = NULL;
```

```c++
示例二：
int * p = ( int * )malloc( 10 * sizeof( int ) ); 
free( p );
//示例二分配能够容纳 10 个整数的连续存储空间，使 p 指向该空间的基地址，虽然指向0号元，实际上通过这个指针操纵的是40个字节的存储空间；最后调用 free 函数释放 p 指向的整个空间,而不是只销毁数组的0号元
```

2）new与delete

这个功能要比malloc和free强大很多；它事实上不仅能够替你分配内存，还能够替你构造所分配的那个目标数据对象。

new和delete是配对使用的，new[]和delete[]是配对使用的，malloc和free配对使用；c的与c++的不能混用。

**所有权与空悬指针**

指针为什么难用？它涉及到很重要的一个地方，就是这里面涉及到两个数据对象，一个是目标数据对象，还有一个指针数据对象本身，尤其是当目标数据对象本身它是没有名字的时候，那么这种情况下面，访问它的唯一的手段，就是需要通过一个指针数据对象来指向它。这种时候我们可以称之为这个指针拥有那个目标数据对象的所有权，问题就在于我们编程的时候，我们有可能很多个指针指向同一个目标数据对象，那么这种情况下谁拥有它，谁有权使用它，一个是使用权，一个不仅有使用权还有所有权。这个就需要决定。但是我们的程序中呢，其实也没有什么很好的方案能够解决这个问题，尤其是在C/C++早期的代码里，这个东西是没有办法解决的，你只能是程序员头脑中要很清晰地架构这个目标数据对象是谁所有 的，谁只有使用权而不是拥有权。这样才能保证你的程序不容易写错，否则的话非常容易出错。

（所以）指针使用的一般原则

```c
主动释放原则：如果某函数动态分配了内存，在函数退出时该目标数据
对象不再需要，应主动释放它，此时 malloc 与 free 在函数中成对出现
    
所有权转移原则：如果某函数动态分配了内存，在函数退出后该目标数
据对象仍然需要，此时应将其所有权转交给本函数之外的同型指针对象，
函数内部代码只有 malloc，没有 free
//因为这个内存区域是这个函数中某一个局部变量所拥有的，它有所有权，但是那个变量将会随着这个函数一样死掉了，所以这个所有权必须在这个函数结束之前要能够完成它的转移，往往都是通过函数的返回值转移给我们的主调函数
```

在编写指针类型的程序的时候，经常会出现两种问题，一个就是空悬指针的问题，

```c
//所有权的重叠：指针赋值操作导致两个指针数据对象指向同样的目
//标数据对象，即两个指针都声称“自己拥有目标数据对象的所有权”
示例：
int *p, *q; 
q = ( int* )malloc( sizeof(int) ); 
p = q;
产生原因：如果在程序中通过某个指针释放了目标数据对象，另一
指针并不了解这种情况，它仍指向不再有效的目标数据对象，导致
空悬指针
示例：free( p ); p = NULL; // q 为空悬指针，仍指向原处
//碰到这种情况，你一旦再尝试使用q去访问它的目标数据对象的时候程序就崩掉了，q这个指针就空悬了。
```

解决方案：

```c
确保程序中只有惟一一个指针拥有目标数据对象，即只有它负责目标数
据对象的存储管理，其它指针只可访问，不可管理；
若目标数据对象仍有存在价值，但该指针不再有效，此时应进行所有权移交；
在一个函数中，确保最多只有一个指针拥有目标数据对象，其它指针即
使存在，也仅能访问，不可管理；
如果可能，在分配目标数据对象动态内存的函数中释放内存，如 main 
函数分配的内存在 main 函数中释放（在哪一个函数内部分配的这段动态内存，那么就在哪个函数内部销毁它），//如果做不到这一点，那么就应该把这一段分配出来的内存把它的所有权转移给我们主调函数中对应的指针,如果在主调函数里仍然不能够销毁它，那么这个所有权还必须进一步地向主调函数的主调函数转移，一直转移到main函数，如果main函数还不销毁它，main函数结束的时候操作系统会全部销毁它。
退一步，如果上述条件不满足，在分配目标数据对象动态内存的函数的
主调函数中释放内存，即将所有权移交给上级函数

//这个所有权移交的过程，是要由内部最底层的函数一层一层地向它的主调函数上去移交的，所以用8个字总结：级级上报，层层审批
```

如果你不销毁，就应该做到8字总结，做不到这条，那么这个指针就会出问题，很重要的一个地方就是内存泄漏。

#### 内存泄漏与垃圾回收

你弄了一个函数，分配了一个动态内存区域，然后函数结束了，那个指针死了，动态内存分配区域呢你忘了销毁，没有任何一个指针指向它了，它那个区域又没有名字，那么它就会变成一个无主之物。无主之物的结果就是出了一个垃圾，对于内存来讲，就变成了内存泄漏，那片内存区域，操作系统已经分配给你了，你的程序本来可以用的，但是你没有任何一个机制可以访问它了，指针没了嘛，所以那个地方明明给了你，但是你不能用，就相当于内存那个地方被挖了一个洞一样。

```c
示例：
void f(){ int * p = new int; *p = 10; }
函数 f 结束后，p 不再存在，*p 所在的存储空间仍在，10 仍在，但没
有任何指针对象拥有它，故不可访问
//问题的实质：动态分配的内存必须动态释放，函数本身并不负责管理它
```

**垃圾回收机制：系统负责管理，程序员不需要主动释放动态分配的内存，Java有此功能，C 语言无**，C++也无。你可以自己写，但是效率可能不高。

垃圾回收机制有个巨大问题是：**垃圾回收机制在需要时效率很差，而不需要时效率很好**

### 6.引用

**和指针不一样**

#### 引用的定义

定义格式：数据类型& 变量名称 = 被引用变量名称；
示例：int a; int & ref = a;

引用的性质
引用类型的变量不占用单独的存储空间
为另一数据对象起个**别名，与该对象同享存储空间**

特殊说明
引用类型的变量**必须在定义时初始化**，除非引用类型的量作为函数参数；
此关联关系在引用类型变量的整个存续期都保持不变
对引用类型变量的操作就是对被引用变量的操作

> 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起；
>
> 初始化常量引用时允许用任意表达式作为初始值

**引用的最大意义：作为函数参数**

前面我们谈到“&”和“*”是可逆的，那是指针，这里是引用，不可逆。

```c++
函数原型示例：void Swap( int & x, int & y );
函数实现示例：
void Swap( int & x, int & y ){
int t; t = x; x = y; y = t; return;
}
函数调用示例：
int main(){
int a = 10, b = 20; Swap( a, b ); return 0;
}
//在Swap函数内部，x就是main函数里面变量a的别名
//它最大的好处就是将主调函数中的两个量a、b把它们引入到Swap这个函数的名空间，换了一个名字访问它。可以直接修改我们的实际参数的值，而不是像指针那样修改指针所指向的目标对象的值
```

#### 引用作为函数返回值

常量引用：仅能引用常量，不能通过引用改变目标对象值；引用本身也不能改变引用对象(**也即自己不能变，也不能通过引用改变被引用对象**)

> **常量引用的定义方式：int b;const int &a =b;或者int b;int const &a=b;** 
>
> 对引用来说，引用的类型必须和其引用对象的类型必须一致，但常量引用只要求其返回的结果能转换成引用的类型。
>
> 常量引用只有2种情况会**绑定到实际的对象**:一是常量引用的初始值为const对象,且该对象类型与常量引用类型相同(如const int i ; const int &r = i;);二是常量引用的初始值为非const对象,且该对象也与常量引用类型(除去const的类型)相同(如int i; const int &r = i;)

引用作为函数返回值时不生成副本

```c
函数原型示例：int & Inc( int & dest, const int & alpha );
函数实现示例：
int & Inc( int & dest, const int & alpha ){
dest += alpha; return dest; }
函数调用示例：引用类型返回值可以递增
int main(){
int a = 10, b = 20, c; Inc( a, b ); c = Inc(a, b)++; return 0;
}
```

其重要性不仅仅于此，当我们想重载输出操作符的时候，你就能看到引用为什么那么重要，没有引用，新的面向对象的那种架构是非常非常难以实现的，

补充知识：形参中使用常量引用，常量，普通引用的区别

```c++
C++中的引用，给我们提供了一种区别于C指针的形参定义方式。一般我们可以将其定义为

1）普通引用

void foo(int &n);

2）常量

void foo(const int n);

3）常量引用

void foo(const int& n);

//三种方法用途不一样，都可以通过编译。
```

以普通引用为形参的函数，一般会更改实参的值，比如increment(int &n)等；**以常量以及常量引用为形参的函数，一般不对实参进行修改**。需要注意的是，当函数的功能确定后，不能把常量引用和普通引用混淆，虽然编译可以通过，运行也没有错误，但是会对函数的安全性以及功能造成影响：

1）如果一个本该是常量引用的形参定义成了普通引用，那么程序员会误认为这个形参可以修改。而且，在调用该函数的时候，会产生意想不到的错误。比如：

```c++
int getSize1(string &str){
    return str.size();
}
int getSize2(const string &str){
    return str.size();
}
void main(){
    getSize1("helloworld");//报错
    getSize2("helloworld");//正确
}
//显然，getSize2才是符合正常函数思维的实现。
```

2）常量引用为形参时，形参指向实参的空间，而常量为形参时，编译器会给形参重新分配空间。

```c++
void foo1(const int n){
    printf("%x\n", &n);
}
 
void foo2(const int &n){
    printf("%x\n", &n);
}
int main(int argc, char *argv[]){
    int n = 1;
    printf("%x\n", &n);
    foo1(n);
    foo2(n);
    return 0;
}
 
//输出：
//e25f58cc
//e25f58ac
//e25f58cc
```

## 八.链表与程序抽象

### 1.数据抽象

1）数据抽象的目的与意义

程序中的数据对象在C++里面有四个主要特征：VANT（值、地址、名称、类型），在真实的程序中最终只会留下两个---地址和值。N、T在程序运行的过程中就消失了。那么它就对我们的程序带来一个巨大的问题，就是我们真实编程的时候所希望所表达的那些信息或意义，有一些东西就没了。这个东西我们称为信息缺失。

解决这个问题的主要手段就是**抽象**

数据抽象最重要的地方就是：第一，怎么表示我们的数据，前面讲过，我们要用注释、**有意义的数据对象名称**来表示数据；第二、在我们的程序代码中应该在算法的关键处，对于特殊的数据结构的使用、对于特殊类型的使用要给出注释。这些都能够让我们**在源代码级别保持数据对象的意义**，这是一个非常重要的地方。

虽说这样的保持在编译成可执行文件以后它这个信息就没了，但是在源代码级别它能够让我们保持数据的意义。

2）结构化数据类型的性质

类型

​	细节由用户自定义，语言只给我们提供技术手段

成员

​	结构化数据类型的子数据对象

成员类型

​	每个成员具有确切的类型

成员数目

​	部分结构化数据类型可变，部分固定

成员组织

​	成员组织结构（线性结构或非线性结构）必须是显示定义

操作集

​	每个结构化的数据类型都会有一个可以和它相适应的操作集

3）数据封装

数据封装：将数据结构的细节隐藏起来

实现方式：分别实现访问数据成员的存取函数

数据封装示例：

```c++
struct DYNINTS{
 unsigned int capacity;
 unsigned int count;
 int * items;
 bool modified;
};
//动态数组
//平常访问count时使用.操作符，但是如果把count改为num_of_element，那整个程序需要很多修改，特别是如果给别人使用了你的库，他们的程序也需要大量的修改
//这是一个非常不好的设计方式，那么我们就想一个办法，就是提供一个函数，我为你实现一个函数的接口DiGetCount，用这样的函数来获取动态数组的元素个数
unsigned int DiGetCount( DYNINTS* a )
{
 if( !a ){ cout << "DiGetCount: Parameter illegal." << endl; exit(1); }
 return a->count;
}
```

我们希望通过一个技术手段，能够将整个程序分解成很多个库，并且这些库的修订、升级、改变这样的操作只要在接口不变的情况下不影响其它的库或者库的使用者，数据封装就是一个最重要的概念。

你不把细节藏起来，就没法保证这个库和其它的库是隔离的。我们怎么实现这样的数据封装呢？就是要对结构体里面的数据成员提供相应的存取函数。

4）信息隐藏

**数据封装的问题**

你如果只有数据封装这个是不够的，我们假设实现那个结构体，你也提供一系列的存取函数，把数据已经封装起来了，这实际上是暗示这个库的使用者，就是如果你想访问结构体里面的成员，你该使用相应的存取函数而不是直接访问成员的名字。这样的话数据才能封装起来。但是只有这些是不够的，因为struct这个结构体类型，它是设计并没有限定用户不能访问它的数据成员，虽然有了接口函数，可是你不能限制不使用这个函数而直接访问那个count成员，也就是说，对库的使用者来讲，他可以在DiGetCount函数的调用和直接访问那个count字段之间自由地切换，你没有办法限定他只能使用存取函数。

所以问题就是：只要将结构体类型定义在头文件中，库的使用者就可以看到该定义，并按照成员格式直接访问，而不调用存取函数

**解决方法**

将结构体类型的**具体细节定义在源文件中**，所有针对该类型量的操作都只能通过函数接口来进行，从而隐藏实现细节。

数据封装和信息隐藏合在一起才是我们编写抽象程序的关键，这是最重要的两个核心概念：数据封装、信息隐藏。

信息隐藏示例

```c++
/* 头文件“dynarray.h”*/
struct DYNINTS; typedef struct DYNINTS * PDYNINTS;
//要保证调用者能够正确使用这个结构体，那么就会在头文件里给出这个结构体的声明，并且提供一个指向这个结构体的指针，我们保证只使用这个指针来操纵它的目标结构体的数据对象。
/* 源文件“dynarray.cpp”*/
struct DYNINTS{
 unsigned int capacity; unsigned int count; int * items; bool modified;
};
```

5）抽象数据类型

```c++
设计能够存储二维平面上点的抽象数据类型
/* 点库接口“point.h”*/
struct POINT;
typedef struct POINT * PPOINT;
//注意：因为我们的目标结构体的定义是未知的，那么实际上这样的PPOINT型虽然可以在函数原型里面使用，但是我们实际上不能使用它的目标结构体的任何内部信息
PPOINT PtCreate( int x, int y );
void PtDestroy( PPOINT point );
void PtGetValue( POINT point, int * x, int * y );
void PtSetValue( PPOINT point, int x, int y );
bool PtCompare( PPOINT point1, PPOINT point2 );
char * PtTransformIntoString( PPOINT point );
void PtPrint( PPOINT point );
```



## 十一.泛型编程

### 1.泛型编程概览

1）什么是泛型编程

---泛型就是通用型式

---编写不依赖数据对象型式的代码就是泛型编程（你写的程序代码和你想要操纵的那个数据对象的具体型式相对无关，那么你写的这段代码就称为泛型的代码，你处理的型，当然也就是所谓的泛型）。

2）为什么需要泛型编程

前面讨论的C++的语言规范里，我们使用面向对象的技术，有继承，有多态，可以解决很多现实世界中的问题，但是，在纯粹的面向对象编程里，涉及到几个问题，这几个问题不太好解决。

一个是函数重载的问题，第二个是相似类的定义问题，第三个是型号式兼容性。在这里，需要补充两个知识，一个是异常处理机制，一个是运行期的型式信息。

3）怎样进行泛型编程

泛型编程最主要的技术手段就是：模板与型式参数化。

1.**函数重载问题**

设计函数，求两个数据对象的较小者

**注意**：并没有说数据对象具体是什么型

所以，如果你编写这样一段程序代码，那么事实上你将提供很多个函数，因为重载机制，所以处理不同型的这样的函数可以命名成一样的。

如果你有一个类A，那么你要为A类提供一个Min()版本，如果你还有一个类B，还要为B类提供一个Min()版本。

```c++
//为明确规定参数型式，因C/C++的强型式检查特性，必须为不同型式的参数分别实现，没完没了。。。
//函数重载数目巨大，并且永不完备。。。
class A;
const A & Min(const A & a, const A & b);
class B;
const B & Min(const B & a, const B & b);
```

**解决方案：使用C的含参宏**

在引入C++以前，我们怎么解决函数重载问题呢？在C++以前，C是怎么解决函数重载问题的呢？因为C不支持函数重载，所以它提供了含参宏，这是一种很巧妙的方案。

宏，尤其是含参宏，它是型式无关的。所以它在某种程度上起到了函数重载的类似效果。

**缺点**：

---无型式检查，无法在编译期检查程序错误。

---宏文本替换时，要注意操作符优先级，错误的宏文本有可能导致问题

**结论**：

---（从函数重载角度上讲）需要一种机制，能够在语法层面解决宏的问题

2**.相似类定义问题**

动态数组类

---定义存储整数的动态数组类

---定义存储浮点数的动态数组类

---定义存储某类对象的动态数组类

---定义存储某类对象指针的动态数组类

......

结论：

---需要一种机制，能够在语法层面解决相似类的重复定义问题，降低编程工作量。

3.**型式兼容性问题**

C型式转换：(T)x

---不安全

---内建型式（int、double）对象转换安全性基本保证

---类对象转换可能导致无法控制的严重后果

C++型式转换：T(x)

看上去让这个型式转换变成像一个函数一样。事实上它就是一个函数。

对于一个特定的型，我们可能需要一个单参数的构造函数和重载的型式转换操作符，才能完成这样的一个型式转换。

**同样，C++的型式转换依然不安全**。

如果你未实现这样的型式转换，那么它的转换本身就不存在。对于你自己定义的一个特定的类，如果你没有实现单参数构造函数，如果你没有重载型式转换操作符，这样的转换可能就是无法工作的。所以它一样也是不太方便的。

**类库架构**

---（从类库架构的角度上来讲）类的继承和多态频繁要求能够通过基类的指针或引用访问派生类的对象。(这是类库层次的基本要求)

---（所以）需要沿着类的继承层次，频繁进行对象的型式转换。（这是必须的）

而前面两种转换，它在很多情况下效果不令人满意。

**存在的问题**

---（所以）C/C++已有型式转换为静态转换，不能适应指针或引用的多态性。

---型式转换本身必须能够适应全部型式，并能自如操作；然而很不幸，型式无穷尽，程序员无法编写完备的型式转换代码。

所以我们需要一种很特殊的机制，能够来保持我们的型式兼容性。

**保证型式兼容性的机制**

---（这样的一种机制）必须能确保型式转换操作本身是合法有效的，并且在失败的时候通知用户。

---（为了让这样一种机制能够工作，我们需要两个特别的技术手段），①：需要在运行期维持对象的型式信息（run-time-type information，RTTI，运行期型式信息），②：转换结果的确认，通过转换操作的返回值确认结果，或者在失败时触发特定信号（或者给出一个特定的返回值来标记它），后者需要使用异常处理机制。

如果是一个指向对象的指针，当它转换失败的时候，我们简单的传递一个空指针就OK了；但是如果是一个引用，当它转换失败的时候，我们没有办法返回一个空引用，所以这个时候就需要使用异常处理机制。

从实现策略角度来讲，完成这样的型式兼容性的一个最基本的技术，就是我们这一讲要讨论的**模板与型式参数化**。

### 2.异常处理机制（非常重要）

1）异常处理机制的基本概念

异常的定义：程序中可以检测的运行不正常的情况

示例：被0除、数组越界、存储空间不足等。

**一个健壮的程序这些问题都必须处理**，早期我们是怎么写程序呢，我们可以写一个if判断它，当它出错的时候我们就做特定的处理，我们还可以写什么呢，我们还可以使用断言来处理这个问题。到了C++里边，为了和面向对象类库的架构相兼容，它提供了异常处理机制。允许你定义异常类，给了你一个更灵活的处理异常的技术手段。

**异常处理的基本流程**

---某段程序代码在执行操作时发生特殊情况，引发一个特定的异常

---另一段程序代码捕获该异常并处理它

异常的引发

异常的捕获

异常类与异常对象

异常处理策略

异常描述规范



