# C++疑惑解析

## 一.C++构造函数详解

### 1. 构造函数是干什么的

```cpp
class Counter
{
public:
    // 类Counter的构造函数
    // 特点：以类名作为函数名，无返回类型
    Counter()
    {
        m_value = 0;
    }         
private:     
    // 数据成员
  int m_value;
}
```

该类对象被创建时，编译系统对象分配内存空间，并自动调用该构造函数->由构造函数完成成员的初始化工作；

定义类对象: Counter c1;

编译系统为对象 c1 的每个数据成员(m_value)分配内存空间，并调用构造函数Counter()自动地初始化对象 c1 的m_value值设置为0

故：**构造函数的作用：初始化对象的数据成员。**

### 2. 构造函数的种类

```c++
class Complex 
{         
private :
    double m_real;
    double m_imag;
public:
    // 无参数构造函数
    // 如果创建一个类你没有写任何构造函数,则系统会自动生成默认的无参构造函数，函数为空，什么都不做
    // 只要你写了一个下面的某一种构造函数，系统就不会再自动生成这样一个默认的构造函数，如果希望有一个这样的无参构造函数，则需要自己显示地写出来
    Complex()
    {
         m_real = 0.0;
         m_imag = 0.0;
    } 
    // 一般构造函数（也称重载构造函数）
    // 一般构造函数可以有各种参数形式,一个类可以有多个一般构造函数，前提是参数的个数或者类型不同（基于c++的重载函数原理）
    // 例如：你还可以写一个 Complex( int num)的构造函数出来
    // 创建对象时根据传入的参数不同调用不同的构造函数
    Complex(double real, double imag)
    {
         m_real = real;
         m_imag = imag;         
     }
    // 复制构造函数（也称为拷贝构造函数）
    // 复制构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中
    // 若没有显示的写复制构造函数，则系统会默认创建一个复制构造函数，但当类中有指针成员时，由系统默认创建该复制构造函数会存在风险，具体原因请查询有关 “浅拷贝” 、“深拷贝”的文章论述
    Complex(const Complex & c)
    {
        // 将对象c中的数据成员值复制过来
        m_real = c.m_real;
        m_img  = c.m_img;
    }            
    // 类型转换构造函数，根据一个指定的类型的对象创建一个本类的对象
    // 例如：下面将根据一个double类型的对象创建了一个Complex对象
    Complex::Complex(double r)
    {
        m_real = r;
        m_imag = 0.0;
    }
    // 等号运算符重载
    // 注意，这个类似复制构造函数，将=右边的本类对象的值复制给等号左边的对象，它不属于构造函数，等号左右两边的对象必须已经被创建
    // 若没有显示的写=运算符重载，则系统也会创建一个默认的=运算符重载，只做一些基本的拷贝工作
    Complex &operator=(const Complex &rhs)
    {
        // 首先检测等号右边的是否就是左边的对象本身，若是本对象本身,则直接返回
        if ( this == &rhs ) 
        {
            return *this;
        }     
        // 复制等号右边的成员到左边的对象中
        this->m_real = rhs.m_real;
        this->m_imag = rhs.m_imag;
            
        // 把等号左边的对象再次传出
        // 目的是为了支持连等 eg:    a=b=c 系统首先运行 b=c
        // 然后运行 a= ( b=c的返回值,这里应该是复制c值后的b对象)    
        return *this;
    }
};
```

下面使用上面定义的类对象来说明各个构造函数的用法：

```c++
void main()
{
    // 调用了无参构造函数，数据成员初值被赋为0.0
    Complex c1，c2;

    // 调用一般构造函数，数据成员初值被赋为指定值
    Complex c3(1.0,2.5);
    // 也可以使用下面的形式
    Complex c3 = Complex(1.0,2.5);
        
    // 把c3的数据成员的值赋值给c1
    // 由于c1已经事先被创建，故此处不会调用任何构造函数
    // 只会调用 = 号运算符重载函数
    c1 = c3;
        
    // 调用类型转换构造函数
    // 系统首先调用类型转换构造函数，将5.2创建为一个本类的临时对象，然后调用等号运算符重载，将该临时对象赋值给c2
    c2 = 5.2;
      
    // 调用拷贝构造函数( 有下面两种调用方式) 
    Complex c5(c2);
    Complex c4 = c2;  // 注意和 = 运算符重载区分,这里等号左边的对象不是事先已经创建，故需要调用拷贝构造函数，参数为c2       
        
}
```

> 补充：转换构造函数
>
> 一个构造函数接收一个不同于其类类型的形参，可以视为将其形参转换成类的一个对象。像这样的构造函数称为转换构造函数。
>
> 除了创建类对象之外，转换构造函数还为编译器提供了执行**隐式类型转换的方法**。只要在需要类的类型值的地方，给定构造函数的形参类型的值，就将由编译器执行这种类型的转换。
>
> 举一个简单的例子，先来看下面这个类：
>
> ```c++
> class IntClass
> {
>     private:
>         int value;
>     public:
>         //转换int的转换构造函数
>         IntClass(int intValue)
>         {
>             value = intValue;
>         }
>         int getValue() const { return value; }
> };
> ```
>
> 由于构造函数 IntClass(int) 只接收一个类型不同于 IntClass 的单个形参，所以它是一个转换构造函数。
>
> 只要上下文需要类对象，但提供的却是构造函数形参类型的值，则编译器将自动调用转换构造函数，这会在以下 4 种不同的上下文环境中出现：
>
> - 该类的一个对象使用转换构造函数的形参类型的值进行初始化。例如:
>
>   ```c++
>   IntClass intObject = 23;
>   ```
>
> - 该类的一个对象被赋给了一个转换构造函数形参类型的值。例如:
>
>   ```c++
>   intObject = 24;
>   ```
>
> - 函数需要的是该类的类型的值形参，但传递的却是构造函数的形参类型的值。例如，假设定义了下面这样一个函数：
>
>   ```c++
>   void printValue(IntClass x)
>   {
>       cout << x.getValue();
>   }
>   ```
>
>   但是在调用它的时候却传递了一个整数给它：
>
>   printValue(25);
>
>   **编译器将使用转换构造函数将整数 25 转换为 IntClass 类的对象，然后将该对象传递给该函数。如果形参是一个[指针](http://c.biancheng.net/c/80/)或对 IntClass 对象的引用，则编译器将不会调用转换构造函数。只有在形参按值传递时，才会调用转换构造函数。**
>
> - 返回值为类类型的函数实际上返回的却是转换构造函数的形参类型的值。例如，编译器将接收以下函数：
>
>   ```c++
>   IntClass f(int intValue)
>   {
>       return intValue;
>   }
>   ```
>
>   请注意，虽然已经将 IntClass 声明为其返回类型，但是该函数仍然会返回整数类型的值，于是编译器也将再次隐式地调用转换构造函数，将整数 intValue 转换为一个 IntClass 对象，这个对象正是需要从函数返回的对象。

### 3.拷贝构造函数

拷贝构造函数，顾名思义，等于拷贝 + 构造。它肩负着创建新对象的任务，同时还要负责把另外一个对象拷贝过来。

当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数就会被自动调用。也就是说，当类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：

1. 一个对象以值传递的方式传入函数体，如果是引用传递则不会调用；
2. 一个对象以值传递的方式从函数返回，或返回对象的引用；
3. 一个对象需要通过另外一个对象进行初始化。

**针对1、2进行扩展说明**

在C++中对象如何作为参数传递和返回？
来源地址：https://www.php.cn/csharp-article-416163.html

1、将对象作为参数传递

要将对象作为参数传递，我们将对象名作为参数写入，同时调用函数，方法与对其他变量执行是相同的。

基本语法：

```c++
函数名(对象名);
```

```c++
#include <iostream>
using namespace std;

class Example {
public:
    int a;
    // 此函数将对象作为参数
    void add(Example E)
    {
        a = a + E.a;
    }
};
int main()
{
    // 创建对象
    Example E1, E2;
    // 两个对象的值都已初始化
    E1.a = 50;
    E2.a = 100;
    cout << "初始值 \n";
    cout << "对象1的值： " << E1.a
         << "\n对象2的值： " << E2.a
         << "\n\n";
    // 将对象作为参数传递给函数add()
    E2.add(E1);
    // 传递给函数add()后
    cout << "新值 \n";
    cout << "对象1的值： " << E1.a
         << "\n对象2的值：" << E2.a
         << "\n\n";
    return 0;
}
```

2、将对象或对象的引用作为参数返回

基本语法：

```c++
object = return object_name;
```

```c++
#include <iostream>
using namespace std;
class Example {
public:
    int a;
    // 此函数将以对象为参数并返回对象
    Example add(Example Ea, Example Eb)
    {
        Example Ec;// 这种编译貌似通过不了，提示使用了未初始化的局部变量，采用我后面写的另一个可以通过
        Ec.a = Ec.a + Ea.a + Eb.a;
        // 返回对象
        return Ec;
    }
};
int main()
{
    Example E1, E2, E3;
    // 两个对象的值都已初始化
    E1.a = 50;
    E2.a = 100;
    E3.a = 0;
    cout << "初始值 \n";
    cout << "对象1的值: " << E1.a
         << " \n对象2的值: " << E2.a
         << "\n对象3的值: " << E3.a
         << "\n\n";
    //将对象作为参数传递给函数add（）。
    E3 = E3.add(E1, E2);
    // 将对象作为参数传递后更改的值
    cout << "新值 \n";
    cout << "对象1的值: " << E1.a
         << " \n对象2的值: " << E2.a
         << " \n对象3的值: " << E3.a
         << "\n";
    return 0;
}
```

```c++
class Example {
	public:
		int a;
	public:
		Example(int num) :a(num) {}
		// 此函数将以对象为参数并返回对象的引用
		Example& add(Example Ea, Example Eb)
		{
			Example Ec(0);
			Ec.a = Ec.a + Ea.a + Eb.a;
			// 返回对象
			return Ec;
		}
	};
```

如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该拷贝构造函数完成对象之间的位拷贝。位拷贝又称浅拷贝，后面将进行说明。

自定义拷贝构造函数是一种良好的编程风格，它可以阻止编译器形成默认的拷贝构造函数，提高源码效率。

## 二.C++类的静态数据为什么一定要初始化

我们知道C++类的静态成员变量是需要初始化的，但为什么要初始化呢。

其实这句话“静态成员变量是需要初始化的”是有一定问题的，**应该说“静态成员变量需要定义”才是准确的，而不是初始化**。

两者的区别在于：初始化是赋一个初始值，而**定义是分配内存**。

**静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存**。

可以通过以下几个例子更形象的说明这个问题：

```c++
//test.cpp 
#include <cstdio> 
class A { 
    public: 
        static int a; //声明但未定义
 }; 
int main() { 
    printf("%d", A::a);
    return 0;
}
```

编译以上代码会出现“对‘A::a’未定义的引用”错误。这是因为静态成员变量a未定义，也就是还没有分配内存，显然是不可以访问的。

再看如下例子：

```c++
//test.cpp 
#include <cstdio> 
class A { 
    public: 
        static int a; //声明但未定义
 }; 
int A::a = 3; //定义了静态成员变量，同时初始化。也可以写"int A::a;"，即不给初值，同样可以通过编译
int main() { 
    printf("%d", A::a);
    return 0;
}
```

**注解：静态变量定义时不给初始值，系统会默认设为0。**

这样就对了，因为给a分配了内存，所以可以访问静态成员变量a了。

因为类中的静态成员变量仅仅是声明，暂时不需分配内存，所以我们甚至可以这样写代码：

```c++
//a.cpp
class B; //这里我们使用前置声明，完全不知道B是什么样子
class A {
    public:
        static B bb;//声明了一个类型为B的静态成员，在这里编译器并未给bb分配内存。
                    //因为仅仅是声明bb,所以编译器并不需要知道B是什么样子以及要给其对应的对象分配多大的空间。
                    //所以使用前置声明"class B"就可以保证编译通过。
};
```

注意：这里只可以用来声明，而不能用前置声明的类来定义成员，写为B bb就错了。

使用命令"g++ -c -o a.o a.cpp"通过编译。

**对于类来说，new一个类对象不仅会分配内存，同时会调用构造函数进行初始化，所以类对象的定义和初始化总是关联在一起**。