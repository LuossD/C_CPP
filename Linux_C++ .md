# 基于Linux的C++

---记录老师展开讲的内容，附加网上看的一些

## 小知识

### 1.endl与"\n"

cout << endl
相当于cout << "\n" + flush
回车同时刷新了缓冲区
所谓刷新缓冲区的意思如下
很简单的一个例子:

```c
代码1，输出123之后才会出现暂停提示
cout << "123"<<endl;//有endl
system("pause");
代码2，出现暂停提示之后才会输出123
cout << "123";//无endl
system("pause");
```

cout << '\n' 只是单纯换行，没有清除缓冲
cout<<endl 换行又清除缓冲
如果你的 程序都是cout << '\n' 结束，缓冲区就会满满的，相当于内存泄漏；

cout是输出流，用cout<<endl 能够将流中的内容全部输出，而cout<<"\n"不一定。在c++中建议用cout<<endl。

### 2.cin

cin是忽略换行和空白符的，遇到就读取终止
但是你可以用cin.get(ch)就可以把'\n'赋给ch

```c
char ch;
cin.get(ch);
```

cin在键盘输入后按回车才会继续执行。

### 3.C++中单引号与双引号的区别

C＋＋中单引号、双引号的区别为：**表示类型不同、数据长度不同、尾部不同**。

1）表示类型不同

> 单引号：单引号的表示类型为字符类型。
>
> 双引号：双引号的表示类型为字符串类型。

2）数据长度不同

> 单引号：单引号的数据长度固定，因为只有一个字符，所以数据长度为1。
>
> 双引号：双引号的数据长度不固定，由字符串的字符数量决定。

3）尾部不同

> 单引号：单引号只有一个字符，不会在字符尾部添加＇＼0＇结尾。
>
> 双引号：系统会将双引号里的字符串内容的尾部自动添加＇＼0＇结尾。

> "a"和'a'的区别，前者是字符串，后者是字符。
> 实际上，"a"在内存中一般占2个字节（不是说字符串长度，是占用内存。注意说是一般占2字节，有特殊情况），"a\0"，以'\0'结尾。而'a'是一个单字符。
> **当然字符串可以是"abcde"这样的，'abcde'这样就是错误的。**

> 在C++中sizeof('a')=1,它是占一个字节，sizeof("a")=2，它后面还有一个\0结束符；而在C语言中，sizeof('a')=4（字符在C语言中是用int型数据存储的）

### 4.cout怎么控制输出的小数点位数

基本格式为cout << fixed << setprecision(N) <<X<< endl;
X为待打印的数，N为期望输出的小数点后的位数；
setprecision包含在iomanip头文件下；

**补充：**cout的默认精度是6，所以运行此代码：
cout << 12.3456789 << endl; 的结果是12.3457；
setprecision(n)指的是精度为n(不是小数点后的)
如，运行cout<<setprecision(5)<<12.3456789<<endl;的结果是12.345；
精确到小数点后n位就需要加上fixed,其意义上制定小数点后
如：cout << fixed << setprecision(2) << 3.1415 << endl;就是指精确到小数点后两位。

### 4.C 中的左值（Lvalues）和右值（Rvalues）

C 中有两种类型的表达式：

左值（lvalue）：**指向内存位置的表达式被称为左值**（lvalue）表达式。左值可以出现在赋值号的左边或右边。

右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。

### 5.初始化局部变量和全局变量

当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化。正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。

**初始化不是赋值**，初始化的含义是创建变量赋予其一个初始值，而赋值的含义是把当前值擦除，而以一个新值来替代。

### 6.c++中派生类和基类是要放在同一个头文件里吗?

可以一起可以不一起；
但是派生类的定义的时候是必须先定义了基类的；
即如果不在同一个文件中，派生类所在文件必须包含基类的定义的头文件。

### 7.派生类定义复制构造函数怎么传、传什么初始化参数给它的基类们？

若派生类定义复制构造函数，一般都要为基类的复制构造函数传递参数，但是复制构造函数的形参表里只能有一个参数，那么这个问题怎么解决呢？解决的关键就是：已有的派生类的对象的引用，可以作为实参，传给任意一个基类的复制构造函数。例如如下的派生类的复制构造函数的实现：

```c++
C::C(const C &c1): B(c1),D(c1),...{...};
//其中C是派生类，B、D等等是其基类，c1是已有的派生类的对象。
//拷贝构造函数中提到参数必须为本类的一个常对象，而派生类属于基类，所以派生类的一个常对象可以作为基类的拷贝构造函数的参数，个人理解
```

### 8.函数名是地址么？

我们经常把函数名当地址用，可实际上他不是地址，但是你可以把他理解成地址，心里清楚他不是就行。

对于test和&test你应该这样理解，test是函数的首地址，它的类型是void ()，&test表示一个指向函数test这个对象的地址， 它的类型是void (*)()；因此test和&test所代表的地址值是一样的，但类型不一样。test是一个函数，&test表达式的值是一个指针！ 

网上看的不知道对不对

### 9.c++中类对象不能访问类的私有成员变量

原则上，C++类中私有变量不允许在类之外的其他任何地方访问。

- 类的成员函数可以访问类这三类（public、protected、private）
- 继承类成员函数可以访问 protect 类型
- 只有本身类的成员函数才可以访问 private 类型
- 类的对象若在其他函数中是不可以访问类的 protect private类型变量

如果你确实需要调用某个private的变量，你可以定义一个public的函数来返回这个变量，比如：

```c++
class D
{
private：
	int a；
public：
	int Getint（）{return a;}
......
}
这里你的对象不能调用a的，
也就是不能
int b；
D d；//假设已经写好了构造函数
b=d.a;//这是错误的，
但是你可以
b=d.Getint();
这样就可以把a的值给b了。
所有的public的函数都可以通过
<对象>.<函数名>的方式来调用
```

### 10.sloc：source line of codes---源代码行

### 11.数组定义时下标操作符可以和数组名中间有空格

### 12.C++中 \0 是什么意思

符号 \ 在 字符串常量中是转义字符，\0 为 空字符（ascii码值为0的字符），在C语言中作为字符串结束符使用。C中定义了一些字母前加" \ "来表示常见的那些**不能显示的ASCII字符**，如\0,\t,\n等，就称为转义字符，因为后面的字符，都不是它本来的ASCII字符意思了，例如\0表示空字符，作为字符串结束符使用，\t表示水平制表符（相当于Tab键），\n表示换行符，可用于输出时的结束符。

使用转义字符时需要注意以下问题：
1)转义字符中只能使用小写字母，每个转义字符只能看作一个字符。
2) \v垂直制表和\f换页符对屏幕没有任何影响，但会影响打印机执行响应操作。
3)在C程序中，使用不可打印字符时，通常用转义字符表示

## 写程序出现的问题

### 1.warning: control reaches end of non-void function

> 别人的博客：
>
> 用gcc编译一个程序的时候出现这样的警告：
>
> warning: control reaches end of non-void function
>
> 它的意思是：控制到达非void函数的结尾。就是说你的一些本应带有返回值的函数到达结尾后可能并没有返回任何值。这时候，最好检查一下是否每个控制流都会有返回值。

### 2.no space left on device

​		原因是磁盘空间满了，经查看c盘确实没一点空间了。

### 3.error: 'constexpr' needed for in-class initialization of static data member 'const double Example::scd' of non-integral type [-fpermissive]

​		const static 和 static const一样，都不能在类内直接初始化非整形常量，可以修饰int，bool，char，但不能修饰其他类型（如double，float）

​		在c++11中，可以使用 constexpr static 或者 static constexpr 来修饰 非整形静态成员常量。

```c++
static const double scd = 1.01;
改为如下：
static constexpr double scd = 1.01;
或者 constexpr static  double scd = 1.01;
```

### 4.error: cast from 'void*' to 'int' loses precision [-fpermissive]

​		学习linux多线程时看别人的示例代码直接将void * 转化为int，在自己的程序中也这样写可是提示错误。

​		在32位系统中int为4字节，地址也为4字节，所以可以直接转换，不会损失精度。但是在64位系统中，int依旧为4字节，但是地址已经变为64位了，所以直接转换会损失精度。

​		解决办法:

（1）这时就**可以使用intptr_t来进行转换**，因为intptr_t就是为了跨平台而存在的，总是所在平台的位数，不会损失精度。
（2）另一种方法是使用unsigned long 来进行转换，因为unsigned long 在32位平台是4字节，在64位平台占用8字节，与地址占用字节数相同也不会损失精度，所以也可以。（**而我的编译器实际测试long为4字节，所以这个时候有另一个办法，使用__int64 来定义变量，这样就是64位了**）

## 疑惑的地方

1.为啥void * 可以直接存放int类型数据？

​		首先可以通过void * 查看编译器的位数，如下：

```c++
在程序中返回sizeof(void*)  的值（通过指针地址来判断，也可以使用long类型），返回的结果是操作系统的字节数。若返回4则是32位操作系统，返回8即是64位。
```



2.缺省的构造函数里面没有代码是如何分配内存的？缺省的析构函数里面没有代码是如何销毁对象的？

3.浅拷贝老师说的是一个字节一个字节拷贝过去为啥是只拷贝了指针？

​		一个字节一个字节拷贝的是指针的那四个字节

4.拷贝就是赋值么？对象没有定义只是声明所以它没有分配内存空间所以就不能拷贝？

​		在谭浩强《C++面向对象程序设计》2.2节里有说“类是抽象的，不占内存空间，而对象是具体的，占用存储空间”。所以类只声明是不分配空间的；而sizeof()这个函数只是计算数据类型所占空间大小，不存在实例化，但存在对内部类型大小计算，sizeof是一个操作符（operator），其作用是返回一个对象或类型所占的内存字节数，sizeof对对象求内存大小，最终都是转换为对对象的数据类型进行求值。拷贝的前提是对象已经存在了。

5.delete如果销毁的不是指向类对象的指针只是个普通数据成员，它会调用类析构函数么？

​		不会。其实一句话可以回答，类才有析构函数。

​		是否调用析构函数得看动态内存里面的对象是否是自定义类对象。如果是内置类型int ,char就不会涉及到析构函数；另外，delete有没有调用析构函数，就是看那个地方以前到底new的是什么东西。

```c++
如果
int* p = new int [10];
//。。。。。。
delete []p; 这里的delete就没有调用什么析构函数
如果
class A{
  int a;
//。。。。。
}
A* apple = new A;这里new A没有给定参数，其就调用了默认构造函数。。
//。。。。
delete apple;
这里调用了个析构函数
```

6.一个类可以赋值给另一个类么？

​		不能，类对象可以赋值给另一个类对象

7.对象名与&对象名的区别？为啥对象名不能作为实参传给指针类型的形参？

8.new出来的对象是一个地址么？

9.&a + 1 是a的下一个元素的基地址么？

## 一.C/C++基本语法元素

### 1.程序设计的基本概念

程序：一系列遵循一定规则并能正确完成待定功能的代码或指令序列

**通常包括数据结构与算法两部分**

------

算法：

描述问题的求解方法和步骤

不允许存在二义性（计算机是一个机械计算过程，逻辑非常机械）

算法设计过程是逐步求精的（不能指望写一个算法解决实际问题一步到位调试正确；逻辑错误比较难发现；先完成一个初步的算法，然后一步一步不断修正它改进升级它）

常使用流程图和伪代码描述算法（伪代码用的较多）

数据与数据结构：

数据：程序操作的对象

数据结构：数据对象之间的**相互关系及构造方法**

数据结构与算法关系密切，良好的数据结构可使算法更简单，恰当的算法可使数据结构更易理解

> 对象：行动和思考的目标；
>
> 对象之间的关系如若不构建出来你的程序数据对象就是零散的，就不能深刻的表达我们现实世界中的这种联系，事物是普遍联系的；
>
> 一个数据结构应该有一个和它相配套的算法，一个算法应该有一个和它相适应的数据结构，两者是一种紧密联系的关系，不能单纯的割裂这二者，而且在某些情况下还会互相转化。

很多很有经验的程序员也是按照这个方式来做，老师把这个思维模式叫做数据中心主义；

这是很多学习者一开始不自觉的思维习惯，不太容易纠正过来；

好处：解决某个问题我怎么用数据来表达它，这个目标是清晰的；

坏处：当我这个问题没想清楚时，这个数据的表达可能是不恰当的；当我在一个不恰当的地基上写算法时，最终发现这个数据表达是错误的，那么所写的算法基本上是没用的，程序越大越复杂这个问题越严重。

所以最后才把它变为称之为算法中心主义的一个东西。

怎么做程序设计：

涉及三种形态的程序设计

- 结构化程序设计

- 面向对象程序设计

  **对象：行为与属性的集合**

  类与对象、对象构造、继承与派生

- 范型编程

**结构化程序设计是早期从C那里继承过来的，必须会用！**（后两者中的代码实现还是结构化的）

面向对象程序设计做了一个很巧妙的改变：**把数据对象和这个对象的行为也就是算法合在一块，把它辩证统一**；

好处：现在行动和思考的目标是对象，没错，但是你不再是数据中心主义了，而是对象中心主义；行动和思考的目标不仅仅包括数据和数据结构，还包括了在这个数据和数据结构上面可以执行的操作，也就是它的行为，实际是完成了从数据中心主义向算法中心主义的一个转化，这点很重要！

为什么做这样的转变？

一个程序里面要么是数据结构要么是算法，不太容易变动的是算法，数据结构是易变的；**写程序首先应攻克那些不太容易变化的地方**，先把这个固定下来然后去攻克那些容易变动的地方。走极端肯定不对，我们要中庸，那就应该是对象中心主义，两者融合在一起，这就是面向对象程序设计的由来或者产生面向对象程序设计的根本原因，就是为了解决大程序开发时候原来的结构化程序设计解决不了的问题：程序太大，规模太大，控制不住！

### 2.简单C程序介绍

wins命令行中编译c程序：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190115211433592.png)

gcc 是编译命令，刚刚我们安装的，-g参数是表示编译时带上可调试记号，不然编译好的东西只能运行不能调试，-o 是表示指定输出文件，后面紧跟输出文件的名字，这一条指令就可以将c文件编译成一个可执行的二进制文件。

------

int main()

每一个C/C++程序都有一个主函数main()，名字固定，一个程序就这么一个，必须有一个，只能有一个。除非你写的不是程序，而是C或C++的库，这个不需要main！

#include <stdio.h>,printf函数原型位于"stdio.h"中，没有它就找不到该函数的入口，函数用的对不对也是参照header文件！

main()前面有个int，表示main函数完成后会带回一个结果，即函数的返回值，返回值是一个整数；0，1，2等等，返回值是给操作系统用的，正确执行即返回0，运行出错会有很多类型的错误，返回不同的值。

------

若想用C++的新格式包含stdio.h，就要写cstdio，后面的.h可以不要了。

早期的C++头文件为<iostream.h>，后改为<iostream>。

C++引入了一个很特殊的东西，成为（命）名空间---namespace，这个空间的名字叫std！C++标准库的名字都在标准名空间里。比如C++中，cout，endl等都在标准命名空间std里面；如果前面不写using namespace std;那么cout应该改为std::cout，endl改为std::endl；::成为名解析操作符。**std和别的名空间是分开的，这是一个非常重要的设计**，如果名字太多，在一个空间里，重名的话不太好解决。两个名空间里名字可以一样，通过名空间来解析他们。

**小结：**

程序执行由主函数开始，其他函数由主函数直接或间接调用；

程序执行流程与函数定义顺序无关；

每个函数包含函数头与函数体两部分；

C/C++包含大量库函数和算法，可直接使用。

### 3.程序设计的基本流程

包含如下几个过程：

1）编辑源代码

包括源文件和头文件，最后的输出结果就是源文件和头文件。源文件的名字就叫main.cpp，a.cpp等，后缀都为.cpp。编译器自动根据后缀来选择C++的编译还是C的编译；有些是这样做的，至于Linux下面看自己选择，使用gcc编译器还是g++编译器。头文件就是<stdio.h>或者没有.h的就是iostream。

2）编译、链接与测试

编译出来的就是目标文件，是二进制的代码。然后把这些二进制代码按照一个可执行文件的特定格式把它组装在一起，这个过程称为链接。生成可执行文件。

在此过程中我们需要使用到那些函数库里面抽取出来的那些二进制的目标代码，比如printf那样的函数目标代码它就会和我们的这个程序中的目标代码链接在一起形成我们的可执行文件。可执行文件运行，测试这个程序对不对。

------

Linux中可执行文件是放在固定的目录下面的，我们**当前目录往往不在可执行文件的那个搜索路径上**，所以要想执行当前目录下面的"a.out"文件，必须写"./a.out"。

> PATH 是环境变量，里面保存了执行文件路径（通常会包含多个路径，各路径之间以冒号“:”进行间隔）。**当执行一个可执行文件（命令）时，Linux 会优先到 PATH 环境变量中保存的路径下进行查找**。使用export $PATH命令可以查看环境变量的内容。
>
> 二、“.”表示当前目录，Windows/Dos 的默认搜索路径（即 PATH 环境变量）里有当前目录，所以不需要加。其实加上也是一样的效果。因为 Linux 的默认搜索目录里没有当前目录，所以如果你在当前目录需要执行程序就要加上路径。
>
> 三、理论上，如果要让当前目录下的文件不需添加“./”即可运行，只需将“./”加入路径参数PATH中即可，如下所示：
>
> export PATH=$PATH:./
>
> 但通常不建议这样做，这是基于安全性的考虑。若系统管理者所在的目录中有可运行文件，而该文件有问题时，被执行后会发生不可预测的问题。
>
> 例如：任何用户对 /tmp 都有 w 的权限，若某用户在 /tmp 之下新增 ls 这文件，而文件内容如下：
>
> ```
> /usr/sbin/useradd -m adm0
> /bin/ls
> ```
>
> 同时，将 PATH 的路径设为`export PATH=./:$PATH`，则当 root 进入 /tmp 并执行 ls 时，就会优先执行 /tmp/ls，而非系统默认的 /bin/ls，这样不知不觉中新增了一个用户 adm0。因此即使要将当前目录加入路径参数中，`export PATH=$PATH:./`的安全性也将优于`export PATH=./:$PATH`。

如果不想使用默认的可执行文件名"a.out"，使用g++ main.cpp -o hello；-o hello 写在main.cpp前面也可以。

### 4.基本语法元素

#### 数据类型

整数类型

整数的符号：确定是否表示负数

signed、unsigned；

定义b为无符号整数：unsigned int b；

整数的长短：确定整数取值范围的大小

long、short；

定义c为短整数：short int c

> 有时候我们需要的整数不需要表达那么宽，现在很多主流的计算机都是64位的CPU，宽度都是64位宽的；
>
> 但是现在我们使用的很多主流的编译器实际上都是32位的，包括我们用的一些应用程序还仍然保留在32位，因为对一个正常普通应用来讲32位程序是够用的；所以迁徙到64位相对于它的难度来讲大家的兴趣不大；现在主流的C++编译器仍然是32位的，int基本上都是32位的，能表达从-21亿到+21亿的数据范围，如果是unsigned的类型，可表达从0-42亿的数据范围。
>
> 有时候不需要这么大数字，这时候我们可以把这个整数再弄短一点，前面加一个short就短了；短多少看编译器，有16位的有8位的；在主流的编译器下面long int 就是int。

浮点数类型：使用double或float表示小数；首选double，精度更高。平时尽量不要用float，因为float的有效位数只有六位和七位。

#### 量与表达式

**表达式**定义：

操作数与操作符序列，表达运算过程。

**变量**

**文字与常量**：

整数类型文字：8进制很少用，**16进制倒是蛮常用的**。

常量的定义：程序执行期间其值不可改变的量。

**格式：const  数据类型  常量名称 = 初始值**

这里的=既不是赋值也不是等号，而是初始化符号。

常量的意义：解决直接出现的文字无法解释其意义的问题。比如孤零零的出现一个3.14，你说这个3.14是个什么？谁告诉你一定是圆周率了。const double pi = 3.14。

> # C++ 常量
>
> 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。
>
> 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
>
> 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。
>
> 在 C++ 中，有两种简单的定义常量的方式：
>
> - 使用 **#define** 预处理器。
> - 使用 **const** 关键字。

**赋值与初始化**：

变量的初始化只能做一次，而赋值可以随便做。

**操作符与操作数**：

操作符的优先级很复杂，分成了10多级，搞不清楚时就加括号，编译器会自动将不需要的括号去除。

**基本输入输出**：

输出（插入）操作符：<<

输入（提取）操作符：>>

cin >> a >> b；一般不要这么写，因为没有提示信息，用户不知道输入啥

### 5.程序设计风格

**注释**

同一种注释标记不可以嵌套

**命名规范**

字符集：ASCII字符集

标识符：区分大小写；

**不能以数字开头**：如果允许变量名开头是数字，则无法区分变量名和数字类型，例如：如果变量名 091合法，则程序无法区分这个变量和数字 091。另外，有些数字可能含有字母，如浮点数 1E10。程序设计语言不能存在歧义，因此，需要约定变量名开头不能是数字，以便区分变量与数字。

**宏与常量**

宏定义：

#define 指令：预处理命令

#define后面跟着两个部分：宏的名字及后面跟着的一大串（即宏想要对应的那个文本），注意它实际上是个文本，简单的文本替换，**后面不需要分号，如果有分号，分号就是替换文本的一部分了！**

例如：#define PI 3.14

一旦定义，可以替代常量使用；宏定义不是常量；程序中应优先使用常量而不是宏。

在编译的时候查找PI，然后全用后面的文本替换，替换完一遍才开始编译；有了const关键字后可以定义常量后我们很少再使用宏来定义像这样的宏文字。

**赋值语句的简写形式**

除赋：x / a

注意：到底是在整数上做操作还是浮点数上，是不一样的；对于操作数都为整数的，结果也是整数，舍去小数部分，比如 9 / 2结果是4而不是4.5；9.0 / 2 结果是4.5；除数与被除数有一个是double或float，结果就是相应的类型。

特别说明：x * = a +b 等价于x = x * (a+b)

**源代码的排版**

函数代码不超过60行，如果太长可拆成两三个函数，这样别人阅读和维护起来就更方便了；

标识符的命名规范应该是一致的；

**除非特别必要，否则不要在一行上书写多条语句。**

## 二.程序控制结构

### 1.结构化程序设计基础

**三种基本控制结构：**

顺序结构

分支结构：

有时候真分支这一路是存在的，假分支这一路，我们什么都不需要做时，那假分支可以省略；

循环结构

程序中常见的控制结构是分支和循环，当然架构整个程序本身的那个结构一定是顺序的；从数学角度上将，它实际上是一种时间严格偏序。

任何复杂结构都可以使用这三种控制结构来完成。

**复杂控制结构：**

控制结构可以嵌套，以构成更复杂的控制结构

### 2.布尔数据

只有真或假两种可能的数据量

#### 枚举类型

即一一列举，编程中有些很特殊的量，这些量的取值范围极其有限，比如自然月份。

月份就12个，如果你使用int来表达它，那实际上它可以取任何一个整数值，问题是如果你映射，1代表1月，2代表2月，12代表12月，那13代表啥？0代表啥？-1代表啥？就有一些量你用不到；但是你在程序中又不能限制它把13赋值给这样一个整型量，也即你不能限制它只能得到有效的月份，所以这种情况建议应该使用一个枚举型。

类型声明：

格式：enum 枚举名 {元素1，元素2，...，元素n}；

例：enum MONTH{JAN, FEB, ...}

枚举类型声明中的元素为枚举文字，不是变量。枚举值是常量不是变量，不能在程序中再为枚举元素赋值。

```c
enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};*

这句话有两个作用：
第一：声明enumType为新的数据类型，称为**枚举**(enumeration);
第二：声明Monday、Tuesday等为符号常量，通常称之为枚举量，其值默认分别为0-6。
接着利用新的枚举类型enumType声明这种类型的变量：enumType Weekday'就像使用基本变量类型int声明变量一样，如 int a;也可以在定义枚举类型时定义枚举变量enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;
但如果使用tpyedef enum {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;则表示将weekday定义为枚举类型不是变量。
```

**计算机怎么存储这个枚举数据对象呢？**

有个很特别的规则：内部把它映射为一个整数，最顶头的文字映射为0，往后依次加一；也可以更改默认的映射，将{JAN = 1，FEB，...}，这样月份从一开始映射。

枚举类型变量的定义：

例如：MONTH month；

然后这个month变量就可以赋值了，比如赋值为JAN等，但是不能赋值为数值，数值是int类型，而month是enum MONTH类型；两者类型不匹配。那么能不能将**枚举量**赋给**非枚举变量**呢？如：int a=Monday;这是允许的，因为**枚举量**是符号常量，这里的赋值编译器会自动把**枚举量**转换为int类型。

注意：枚举型不能直接输出，直接输出最终会转化为整数去输出。

> 也可以在定义枚举类型时定义枚举变量enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;
>
> 然而与基本变量类型不同的地方是，**在不进行强制转换的前提下**，只能将定义的**枚举量**赋值给该种枚举的变量，如：*Weekday = Monday;*或者Weekday = Sunday;不能将其他值赋给**枚举变量**，如：Weekday = 10;这是不允许的，因为10不是**枚举量**。也就是说Weekday只能是定义的Monday-Sunday这些定义过的**枚举量**。然而这不是绝对的，下面会讲到利用强制类型转换将其他类型值赋给**枚举变量**。
>
> 枚举型可以隐式的转换为int型
>
> ```c
> enum Suit{Diamonds,Hearts,Clubs}a;
> a = Diamonds;
> int n = 100;
> n = a;
> ```
>
> 也可以强制转换（int）date;(int)a，是类型强转化。

**enum的其他用法：**

在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量，言下之意就是可以**通过强制转换将其他类型值赋给枚举变量**：

*Weekday = enumType(2);*等同于：Weekday = Wednesday;但是，如果试图将一个超出枚举取值范围的值通过强制转换赋给枚举变量，会出现什么结果？

*Weekday = enumType(20);*结果将是不确定的，这么做不会出错，但得不到想要的结果。

**对于枚举，只定义了赋值运算符，没有为枚举定义算术运算。**

不能对枚举量进行算术运算，那么枚举量能不能参与其他类型变量的运算呢？int a;a = 1 + Monday;这是允许的，因为编译器会自动把枚举量转换为int类型。

```C++
也可以只显式的定义一部分枚举量的值：

enum enumType {Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday};这样Monday、Wednesday均被定义为1，则Tuesday=2，Thursday、Friday、Saturday、Sunday的值默认分别为2、3、4、5.总结：未被初始化的枚举值的值默认将比其前面的枚举值大1。
    
这还说明另外一个现象，就是枚举量的值可以相同。
```

**enum(枚举)可以没有枚举名**

如果声明枚举类型时没有指定枚举名，其作用就和#define类似，比如以下代码：

```C
enum {
    STATION_IDLE = 0,
    STATION_CONNECTING,
    STATION_WRONG_PASSWORD,
    STATION_NO_AP_FOUND,
    STATION_CONNECT_FAIL,
    STATION_GOT_IP
};
```

这里声明了一个枚举类型确没有指定其枚举名，那么它就相当于用#define定义了六个名称和其对应的值，从0开始赋值每次加1，相当于：

```c
#define     STATION_IDLE = 0;
#define     STATION_CONNECTING = 1;
#define     STATION_WRONG_PASSWORD = 2;
#define     STATION_NO_AP_FOUND = 3;
#define     STATION_CONNECT_FAIL = 4;
#define     STATION_GOT_IP = 5;
```

只不过eunm类型表示的是一个确定的值，而这里#define了六个值，**可见如果要表示同一个事件的不同反馈status，使用这种没有枚举名的枚举效果更好**。

枚举类型的意义：

将多个文字组织在一起，表达从属于特定类型的性质；取代魔数，使源代码更易理解。

#### 用户自定义类型

自定义类型：

格式：typedef 原类型标识 新类型名；

例一：typedef int DWORD；

自定义类型的性质：

新类型与原类型相同，类型性质一模一样，并未产生新类型，重新命名的自定义类型使程序更易理解。

**bool类型：**

取值：false、true；

这个三个关键字是C++里面有的，在C里面是没有的；如果写C程序，不能使用这个布尔类型。

bool量的定义：

定义：bool modified；

赋值：modified = true；某个数据对象有更新的话，那modified就给它设为true，没有更新就设为false。这样就可以通过modified这个值来决定我们数据有没有更新，这样就把这个数据持久化，这是一个非常重要的概念。

#### 关系表达式

关系操作符：共6种

逻辑值（布尔值）

C 语言以0表示假，以非0表示真（经常以1表示）。

C++里尽量使用bool类型表示逻辑值。

但是有的时候我们要写的程序代码涉及到很多Linux操作系统的功能，它的很多系统代码实际上是早期的代码，都使用C来实现的。所以C的很多架构我们还离不开。

#### 逻辑表达式

逻辑运算符：逻辑与（&&）、逻辑或（||）、逻辑非（!）

关系操作符与逻辑操作符的优先级：

从高到低顺序：逻辑非"!"；"<"、">="、">"、"<="(同级)；"=="、"!="(同级)；"&&"；"||"。

#### 逻辑表达式的求值

给定年份year，判断是否为闰年：

year % 4 == 0 && year % 100 != 0 || year % 400 == 0

实际上能够被8000整除的年份就不是闰年，但是现在才2020年，8000年一轮回的那东西我们一时半会不用去考虑。

### 3.分支架构

**If分支架构**的三种格式：

格式1：if(条件表达式) {语句序列}

格式2：if else 

格式3：if else if else

如果{}里就一条语句{}可以省略。

PS:若仅用于确定某条语句是否执行，else分支可以省略。单独出现if可以，如果有else一定要有一个if配对，两个if一个else没有问题，问题在于else与哪个if配对？

C/C++的配对原则：离它最近：距离最短；同层次：排除底层嵌套。

**switch分支结构**：

switch(表达式){}

switch后面的表达式必须为整型、字符型或枚举型；总之它能和整数形成一一对应。

break语句的目的：

终止switch语句的执行；case子句中的**常数表达式**仅起到语句标号的作用，不是分支之间的分隔标记，也即**只起到什么时候进入这条switch语句的作用**，并不能起到离开这条switch语句的作用，想要离开必须加break，没有break是不能够工作的。

### 4.循环结构

发生无限循环的场合：

循环体内没有改变循环变量值的语句；

即使改变循环变量值，也不能否定循环条件；

循环体内没有能够强制终止循环执行的语句或命令。

**偶尔也需要用无限循环做一些特别的处理：**

```C
//有些程序除非用户产生一个特别的明确的要求，我要结束，否则的话循环就应该不断地做下去；这种循环架构使用无限循环更合适。
```

用户给出结束条件的时候我们再退出，这种东西我们称为哨兵。

哨兵：使循环满足终止条件的循环变量值。

**for循环**

递增递减表达式的优先级非常高。

注意：不要在复杂表达式中使用递增递减操作符，因为它有可能给我们带来错误的结果。

for循环与while循环其实等价，可以互换使用。

> while常用于不需要或很少需要初始化的场合
>
> for常用于需要简单初始化和通过递增递减运算控制循环体执行的场合
>
> for循环将所有循环控制因素都放在循环头部，循环结构最清晰

for循环的初始化表达式可以不写，如果for循环真的需要初始化表达式，那么在for循环前面得加上；

步进表达式也可以不写，如果真的需要步进，那么在循环体的最后要加上步进表达式；

条件表达式也可以不写，那就是无限循环，内部应该要加上哨兵。

## 三.函数

### 1.函数声明、调用与定义

**函数调用**：主调（客户）函数与被调（服务器）函数。

**函数调用过程中为了保证调用没有问题，必须要为每一个函数书写正确的函数原型**，表达这个函数的实现和调用格式的标准说明。**正常情况下它将充当函数的接口，所以它一般出现在头文件里。**

格式：函数返回值类型 函数名称（形式参数列表）；

**函数定义**：不仅可以使用标准库里边提供的一系列函数来实现程序，还可以自己定义一些函数；函数的定义需要使用编程语言来给出函数的执行步骤，它的每一条代码应该怎么写，怎么装配，这个过程就叫函数的定义。

1）函数没有返回值时，只需直接写return；即可。C/C++的编译器还告诉你：当这样的return语句在函数最结尾的时候，其实不写也没关系。

2）程序中可以写很多条return，但遇到第一条return程序就结束了；多条return语句的返回往往都是出现在这样的if-else-if所有的分支上。

**谓词函数**：

编写函数IsLeap，判断某个给定年份是否为闰年

```c
bool IsLeap(int year)
{
	return year % 4 == 0 && year % 100 !=0 || year % 400 == 0;
}
```

谓词函数最重要的一个用途是：可以充当条件表达式，比如if(IsLeap(year))。必须会用！

**函数重载**：

定义同名但参数不完全相同的函数就叫函数重载。

参数不完全相同：参数的个数可以不一样，参数的类型可以不一样，参数的顺序也可以不一样。

示例：比较数值、字符、布尔型的大小

```c
int Max(int x, int y);
char Max(char x, char y);
bool Max(bool x, bool y);
```

没有函数重载时这三个函数不能同名。有了重载就可以，同名的好处是：调用的时候，明确的知道调用的是Max，从功能上将求的就是两个数的大小，管它这两数是整型还是字符型还是布尔型呢，名字固定就是Max，这样可以避免搞混淆。

注意：把所有函数写在main函数前面不好，原因就是别人看你代码应该一眼就看到我们的主函数才对；如果他看到太多我们自己写的内部函数的话，他就看到太多细节，然后再去理解这个主函数的框架就不太容易。**所以从理解和维护的角度上讲，应该先写主函数！所有的函数都应该写在main函数后面**。问题来了：写在main后面函数能运行么，不能，所以需要把函数的原型写在main前面！

```c
//先整体后局部的逻辑进行思考，俗称自顶向下，逐步求精。
//如果一开始就特别关注细节，就会导致一个问题：一叶障目，不见森林
//先从战略高度然后再从战术角度来实现我们的代码
```

### 2.函数调用栈框架

初学者非常容易忽略的：就是在程序启动的最初，应该给出整个程序功能性的简单说明，应该给出提示信息让使用这个程序的程序员或者用户知道这个程序的基本功能。所以我们要把整个程序的功能代码抽取成一个又一个的函数。

值传递的机制：

- 形式参数在函数调用时才分配存储空间，并接受实际参数的值
- 实际参数可以为复杂的表达式，在函数调用前获得计算
- 形式参数与实际参数可以同名，也可以不同名
- 参数较多时，实际参数值逐一赋值，它们必须保持数目、类型、顺序一致
- 值的复制过程是单向不可逆的，函数内部对形式参数的修改不会反映到实际参数中去（就是个一次单向动作，就在函数调用的时候发生那么一次，拷贝完成后，形式参数和实际参数的关系就割裂了）

整数互换示例第二版：

**使用全局变量**：写在using naemspace std；后面，函数原型前面；int a, b。从变量的定义开始到这个文件的结尾，中间这些代码中所有的函数都能够使用这两个量a和b，将被后面所有的函数所共享。

这种解决方案不太好，并不是每个函数都需要用这两个全局变量，但是你能限制某个函数不用它们么？

> 全局变量不易于管理，不像局部变量，在函数调用结束后会自动释放
>
> 1 全局变量是很好；
> 2 但是有缺点：容易被修改错，尤其在工程很大的时候；
> 3 使用时一定要控制好全局变量的修改；
> 4 不过小工程小项目使用全局变量是很方便的！
>
> 全局变量可以被所有的函数访问，所以全局变量的值（正确的、安全的）可能会被其他的函数无意间修改。程序的行为依赖值的正确，**如果全局变量的值被无意或者恶意修改就会导致问题。所以，不推荐使用全局变量**。基于此，某些编程语言是不允许修改变量的值的。(一旦第一次赋值，就不能再修改变量的值了)。

如果你的全局变量过多，就有可能给程序的正确性带来威胁。

## 四.算法

### 1.算法概念与特征

算法定义：解决问题的方法与步骤

设计算法的目的：给出解决问题的逻辑描述，根据算法描述进行实际编程

算法特征：

- 有穷性：算法在每种情况下都可以在有限步后终止（步骤）
- 确定性：算法步骤的顺序和内容没有二义性
- 输入：算法有零个或多个输入
- 输出：算法至少具有一个输出（如果返回值是void的，它的输出体现在当事情做完以后，计算机内部的状态发生了变化，比如Swap函数交换了两个数，x和y两个形式参数的值发生了变化啊，这个就是输出，隐含着了，并没有在函数的返回值里体现出来）
- 有效性：所有操作具有明确含义，并能在有限时间内完成（有效性表示时间是有限的）

**注意：正确性不是算法的特征，算法的正确性需要数学证明**。不知道怎么证明那就测试，测试你的程序的正确的，这样才行。

示例：如果查找单词Abort，按照人的思维这个单词在字典的前几十页，所以不会一开始就去查中间位置，这个是人的智力**启发方式**，编程的时候除非你使用了启发式，否则这个事情是做不了的，它不像你的头脑中可以做到这件事。我们编程机械语言不是那么容易做到的，我们能做到的最快的就是折半（二分）查找，除非你启发式，一开始就说A在哪一个附近，B在哪一个附近....，完全告诉它，在这样一个情况，既然首字母是A，直接去查A那一部分就完了，B以后部分全砍掉；这就叫启发式了，你的算法可以这么设计；**如果没有启发式，折半效率是最快的**。

### 2.算法描述

如果一个算法没有想清楚就去写代码，那写出来的代码质量基本是不高的，更有可能是你压根就写不出来。也就是这个问题在头脑中就已经完全明确到了应该如何去实现；如果不明确，那么这个算法就很难去真正编程。

**伪代码**

混合自然语言与计算机语言、数学语言的算法描述方法描述算法的过程和步骤，第一步做什么第二步做什么...怎么方便怎么来，采用其中一个也行混着来也行，你把这个事情讲清楚了，写出来它，这就叫伪代码。

优点：方便，容易表达设计者的思想，能够清楚描述算法流程，便于修改。

缺点：不美观，（一会计算机语言一会数学语言，或者全是自然语言，全是数学语言，全是计算机语言，都有可能，这么写在一起不美观，别人看复杂算法就不太容易理解），复杂算法不容易理解。

**流程图**(程序框图)

使用图形表示算法执行逻辑；

优点：美观，算法表达清晰；

缺点：绘制复杂，不易修改，占用过多篇幅。

流程图往往是我们算法都设计完了，最终形成设计文档给别人看的时候，这样绘制觉得漂亮，给别人看，印象深刻。

**平时写程序的时候往往都是使用伪代码。**

### 3.算法设计与实现

算法选择的权衡指标：

- 正确性：算法是否完全正确？
- 效率：在某些场合，对程序效率的追求具有重要意义
- 可理解性：算法是否容易理解，也是必须考虑的（让别人容易看懂，同时维护起来也方便）

通常，效率与可理解性是不可兼得的，所以：

算法评估：衡量算法的好坏，主要是效率；但是对于初学者，可理解性其实更重要！尽可能用简单的方式去实现哪怕效率低一点也可以接受。

### 4.递归算法

递归的工作步骤：

递推过程：逐步分解问题，使其更简单

回归过程：根据简单情形组装最后的答案

一个函数通过直接或间接的手段调用自身的动作就叫递归，这样的函数就叫递归函数。

**理论上，任何递归程序都可以使用循环迭代的方法解决**

**写递归算法时需要问两个问题**：

Q1：是否存在某种简单情形，问题很容易解决

Q2：是否可将原始问题分解成性质相同但规模较小的子问题，且新问题的解答对原始问题有关键意义

**递归信任**：

有时候，初学者初学者经常会觉得，这个递归函数能实现么？总是怀疑疑虑，这里要特别强调：递归它一定是能正确工作的，养成最基本的递归信任，不用去怀疑递归工作的基本原理。递归信任里我们能够注意到六个问题：

- 递归实现是否检查了最简单情形

  大多数情况下，递归函数以if开头，如果不是，要仔细检查源程序

- 是否解决了最简单情形

  最简单情形不能调用自身递归，可以调用与它无关的递归

- 递归分解是否使问题更简单

- 问题简化过程是否能够回归最简单情形，还是遗漏了某些情况

- 子问题是否与原始问题完全一致

  如果递归过程改变了问题实质，则整个过程肯定会得到错误的结果

- 使用递归信任时，子问题的解是否正确组装为原始问题的解

### 5.容错与计算复杂度

容错的定义：允许错误的发生

正常情况下我们应允许错误的发生，并且在错误发生的时候能够知道按照什么方式对它进行正确的处理。

典型容错手段：

对于用户输入错误：数据有效性检查

致命错误：程序流程的提前终止（放置错误扩散，造成更严重的后果）

## 五.程序组织与开发方法

### 1.库与接口

从库与接口的角度上讲，实际上C/C++的程序包括了两类文件

```c
程序文件：源文件（*.cpp）

头文件（*.h、*.hpp、*）
```

使用.h和.hpp后缀对头文件命名有助于编译器更好地管理程序

库：源文件与头文件

库从本质上讲是不会独立运行的，那就意味着不需要为它编写main函数。所以从库的设计角度来讲，源文件就包括了具体的实现代码，而头文件则提供了库的接口。想使用库就要通过库的接口来使用，正常情况下也就是.h/.hpp这样的头文件。

**接口**：

通过接口使用库：包括制定库的头文件与源文件

优势：不需了解库的实现细节，只需了解库的使用方法

C++标准库提供了一系列的功能有很多很多个接口，合在一起统称为标准库。标准库包含两部分：C的标准库，C++的标准库；两者是不一样的。写代码时两者皆可使用。

**其中数学库，在Linux和Wins下的处理的方式不太一样。**

在windows下面"math"事实上就是C标准库中的一部分，但是在Linux下数学库是单列的，缺省的时候是不链接数学库的，所以如果链接，就用"-l"链接特定库的选项，后面跟着就是库的名字；所以-lm（l为link，m代表math）

在C下头文件：math.h；C++下头文件：cmath。

库文件：libm

链接方式：g++ -lm main.cpp

如果使用数学库的函数，就必须把数学库链接进去。

**工具与辅助函数**

头文件：stdlib.h/cstdlib

常用函数：

```c
void exit(int status);
void free(void *p);
void *malloc(size_t size);
int rand();
void srand(unsigned int seed);
```

### 2.随机库

```c
#include <cstdlib>
//rand()特别简单，不带任何参数，生成的随机整数在[0,RAND_MAX]这个闭区间范围内，RAND_MAX这个值到底为多少，不同的操作系统对其定义不一样。
srand((int)time(0));
//程序运行过程中，srand()函数只能调用一次，如果生成一个随机数调用一次，那就不行了，因为生成一个随机数的运行时间是非常非常短的，生成一个然后再做一个种子，那时间都没变，每次都设置同样的种子，那随机数不就一样嘛。而且必须是在你生成第一随机数之前调用！
```

**接口设计原则**

四项基本原则：

1）用途一致

接口中所有函数都属于同一类问题（用途不一致，别人就很难用）

2）操作简单

函数调用方便（让别人很容易用），最大限度隐藏操作细节

3）功能充足

满足不同潜在用户的需求

4）性能稳定

经过严格测试，不存在程序缺陷

**设计随机数接口**

随机数库这个接口应该设计一些什么样的函数，提供什么样的功能。

rand()生成[0,RAND_MAX]，但是我想掷骰子，生成0-6之间的随机数；再比如我想生成1-52之间的某个数，模拟扑克牌。就是说能够随机生成在指定范围内的随机数，而不是固定范围内的随机数。第二点，我还要能生成指定范围内的随机小数，尤其是0-1之间的随机小数。这就是随机库两个最主要的功能。还有一个需要对它进行随机化，即设定随机数发生器的种子

```c
void Randomize();
int GenerateRandomNumber(int low, int high);
double GenerateRandomReal(double low, double high);
//就这三条函数原型
```

**随机数库测试**

单独测试库的所有函数

​		合法参数时返回结果是否正确

​		非法参数时返回结果是否正确，即容错功能是否正常

（每一个函数都测试，保证每个函数单独运行时没有问题）

联合测试

​		多次运行程序，查看生成的数据是否随机

​		测试整数与浮点数随机数是否均能正确工作

（混合在一块运行时也是没有问题的）

库的使用者只要知道在生成随机数之前一定要调用Randomize进行随机化。

怎么重新设计数据库让用户不需要调用Randomize？

### 3.作用域与生存期

#### 量的作用域与可见性

作用域：标识符的有效范围

可见性：程序中某个位置是否可以使用某个标识符

**标识符仅在其作用域内可见**，但是位于作用域内的标识符不一定可见

**局部数据对象**：

定义于函数或复合语句块内部的数据对象（包括变量、常量与函数形式参数等）

```c
int func(int x, int y)
{
	int t;
	t = x + y;
	//单独出现的花括号对用于引入嵌套块
	{
		//允许在块中定义数据对象，作用域仅限本块
		int n = 2;
		cout << "n = " << n << endl;
	}
	return t;
}
//c和c++允许单独的复合语句块--一对孤零零的花括号，n从定义到cout语句做完就无效了。
```

**全局数据对象**：

全局数据对象具有文件（全局）作用域，有效性从定义处开始直到本文件结束，其后函数都可直接使用。

若全局数据对象定义的文件被其他文件包含，则其作用域扩展到宿主文件中，这可能导致问题。不要在头文件中定义全局对象，因为放在头文件里非常容易被别人包含，一被别人包含作用域就会扩展过去，编译器很可能报错，因为**不允许定义同名的全局变量**！在一个工程项目里不允许定义全局变量，哪怕他们是在不同的文件里。

**函数原型作用域**：

定义在函数原型中的参数具有函数原型作用域，其有效性仅延续到此函数原型结束，不会延展到函数所对应的实现里面去；这就意味着原型里的参数和实现里的参数名字可以不一样！

**全局变量如果没有初始化，都自动的初始化为0**。

**注意**：如果复合语句块内有变量i，全局变量里也有i，那复合语句块内输出i时到底是哪个i呢？作用域它都在嘛，那就体现一个点，**可见性**嘛。全局变量i作用域很长，在复合语句块内不可见，原因就在于它被一个新定义的作用域更小的局部变量i覆盖了可见性。**如果在复合语句块内非要访问全局变量i，可使用全局解析操作符，::i**。

#### 量的存储类与生存期

生存期：量在程序中存在的时间范围。通俗的讲，就是这个量能活多长时间。

**C/C++都使用存储类来表达生存期**。

作用域与可见性表达的是量的空间特性，存储类表达量的时间特性。

一般来讲，C/C++代码里的量具有两类生存期，一个称为静态（全局）生存期，一个称为自动（局部）生存期。

- 全局数据对象具有静态生存期；也就是说它的生死仅与程序是否执行有关，程序运行它就出手了，程序结束它就死掉了。
- 局部数据对象具有自动生存期；生死仅与程序流程是否位于该块中有关。程序代码进入语句块，在语句块内部定义的局部变量就算出手了，离开了这个局部块，局部变量就死掉了；程序每次进入该块时就为该对象分配内存，退出该块时释放内存；两次进入该块时使用的不是同一个数据对象（人不能两次踏进同一河流）。

**static关键字**

修饰局部变量：静态局部变量

使局部变量具有静态生存期；程序退出该块时局部变量仍存在，并且下次进入该块时使用上次的数据值；因为static修饰的局部变量的生存期就像全局变量一样长；**静态局部变量必须进行初始化，同时它不改变量的作用域，只改变生存期**（即生命被拉长了，但存在的空间仍然没有发生变化）

**注意**：静态局部变量**看上去就像全局变量一样**，**初始化在程序启动前就做好了，调用main函数之前该变量就被初始化了**。

修饰全部变量

不表示将生存期拉长，而表示限定作用域，**只在本文件内部使用，其它文件不可见**。

#### 函数的作用域与生存期

所有函数具有文件作用域与静态生存期（空间尽可能大，时间尽可能长）

在程序每次执行时都存在，并且可以在函数原型或函数定义之后的任意位置调用。

**内部函数与外部函数**

内部函数：不可以被其它文件中的函数所调用

函数缺省时均为外部函数

内部函数定义：使用static关键字

示例：static int Transform(int x);static int Transform(int x){...}

注意:**内部函数不能把它写在所对应的头文件里**

**声明与定义**

声明不是定义。定义是在程序产生一个新实体，声明仅仅在程序中引入一个实体，不创造只是引入，这个实体可能是别人替我们创造的，可能是我们在另外一个文件中创造的。

**函数的声明与定义**

对于函数来讲，声明就是给出函数的原型，定义就是给出函数的编码实现。如果产生一个新的类型那就叫定义，如果新的类型没有被产生那就是声明；定义一定会构造出新的型来，而声明是没有构造出来。

**全局变量的作用域扩展**

全局变量的定义不能出现在头文件里，只有其声明才可以出现在头文件中。（如果定义出现在头文件里，工程项目中很多文件include该头文件时，就会出现重复定义，编译器是通不过的；**想要全局变量跨文件使用，又不能重复定义，怎么办呢，有个技巧，使用external关键字**）

声明格式：使用extern关键字

```c
/*库的头文件*/
//此次仅引入变量a，其定义位于对应源文件中
extern int a;//变量a可导出，其他文件可用;将变成变量的声明，而不是定义

//库的源文件
//定义变量a
int a;
```

#### 典型软件开发流程

软件工程概要

问题的提出

- 需求分析
- 概要设计
- 详细设计
- 编码实现
- 系统测试

经验总结

从软件工程角度来讲，真实的开发程序实际上要通过以上5个步骤才能完成，没有这些流程，程序的开发实际上是非常困难的。

**软件工程概要**

需求分析：确定软件需要解决什么问题

决定因素：人

​		软件开发人员需要与用户深入交流，明确问题的输入、输出以及其他附加信息。

​		从设计程序的角度上来讲，**不要轻视任何问题**，因为哪怕是最简单的问题，用计算机语言实现起来可能都是非常复杂的。

**方案设计：设计程序框架**

**分为概要设计与详细设计**

概要设计：设计总体方案，形成高层模块划分

详细设计：细化模块，获得各模块的输入、输出与算法

有了概要设计，有了总体方案，那么就可以向总体方案中填充细节，包括每一个模块的输入、输出和算法，都要在概要设计里完成。有了概要设计之后，其实已经明确了程序中要设计什么样的函数，设计什么样的模块，如果具体到某一个特定的函数的话，那么每一个函数输入是什么、输出是什么、算法是什么，所有的信息理论上都应该完成，有了它就可以很容易地编写程序代码。

**编码实现：实际编程**

**系统测试：测试程序的正确性与稳定性**

这里面的每一个过程都有可能会产生一种反馈，修改原来的设计、原来的分析、原来的实现，形成一个螺旋式的开发流程。这种情况就是最常见的软件开发过程。

**有了概要设计其实就决定了程序的主体框架是什么。**

**系统测试**

**真实测试的时候可能就是干脆直接输出实际的价格，不然真的自己去猜去玩这个有效那测试效率太低了！**

所有数据对象是否已经正确初始化？

随机生成的价格是否合理有效？测试过程可能需要在源程序中添加必要的测试代码，例如：

```c
double PlayGame()
{
    ...
    actual_price = InitializeBout();
    #ifndef NDEBUG
    	cout << "Debugging:Actual price = " << actual_price << endl;
   	#endif//结束这个条件判断
    ...
}
```

那么在真实程序运行的时候，cout这段输出肯定是不能要的，程序真正发布的时候这行代码是要删掉的，可是如果总是一开始测试的时候贴上去，后来又删除，那当代码量很大的时候很难删的，一不小心就删错了。

在这种情况下就有个小技巧。凡是用于测试的这些输出在未来都不应该出现，用一个宏包起来，#ifndef（它是一个条件编译指令），作为一个**宏测试**，意思是如果没有定义，NDEBUG为宏的名字，那么编译器就编译cout这条语句，程序运行的时候就会执行这段代码；如果你定义了这个宏，那么它里面封包的cout这条语句就不编译了，所以就不需要你删除，想去掉这样的cout语句，很简单，在程序的最开头写上一行，

```c
#define NDEBUG
```

**经验总结**

Q:这个问题一开始大家认为它难不难？

A:不难

Q:程序设计难不难？

Q:难，如果要程序员从系统分析、方案设计开始做起的话

Q:编码难不难？

A:不难，与系统分析与设计相比编码实在简单，不过就是使用了所有代码控制结构和函数编写原则而已。

## 六.复合数据类型

### 1.字符

**字符类型、字符文字与量**

定义格式：char ch；const char cch = 'C'；

字符文字使用单引号对

**实际存储时字符类型量存储字符的对应ASCII值**

可使用signde与unsigned修饰字符文字；缺省的情况下它是signed。正常情况下我们不需要对它进行限制，使用unsigned。

这个字符的存储一般有多大呢？正常情况下使用8位，也就是一个字节来存储它。表达范围实际上是在-128~127之间。

如果是unicode字符，则使用2个字节存储，也就是16位来表达单一的字符。

```c++
字符表示的等价性
 char a = 'A';
 char a = 65;
 char a = 0101; // 八进制
 char a = 0x41; // 16进制
```

ASCII码值在我们计算机里怎么保存呢？它当然是按照一个整数来保存的，它要和这个整数构成一一映射。ASCII码表示的字符的整数范围为0-127。ASCII值'\0'（空字符）在计算机内部保存的时候，保存的其实就是0。而真正的数字0在计算机内部保存的时候，事实上保存的是ASCII码值48。

实例：判断某个字符是否为数字（0-9）

```c
bool IsDigit( char c )
{ 
 if( c >= 48 && c <= 57 )
 	return true; 
 else 
 	return false; 
} 
//不能写在‘0’~‘9’之间，而是在48-57之间
```

**标准字符特征库**

在C++里边提供了一系列标准字符运算，当然实际上这是C代码，C的函数库里边包括了一系列字符特征，库函数它写在"ctype.h"这个头文件里，用C++模式包含这个头文件的时候，你就可以写"cctype"。

> ### 深入 理解char * ,char ** ,char a[ ] ,char *a[] 的区别
>
> #### １.数组的本质
>
> 　　数组是多个元素的集合，在内存中分布在地址相连的单元中，所以可以通过其下标访问不同单元的元素。。
>
> #### ２.指针
>
> 　　**指针也是一种变量**，只不过它的内存单元中保存的是一个标识其他位置的地址。。由于地址也是整数，在32位平台下，指针默认为32位。。
>
> #### ３.指针的指向？
>
> 　　指向的直接意思就是指针变量所保存的其他的地址单元中所存放的数据类型。
>
> 　　int * p，//p 变量保存的地址所在内存单元中的数据类型为整型;float *q，// ........................................浮点型
>
> ​      不论指向的数据类型为那种，指针变量其本身永远为整型，因为它保存的地址。
>
> ####  4.字符数组
>
> ​    字面意思是数组，数组中的元素是字符。。确实，这就是它的本质意义。
>
> ​     char str[10]; 
>
> ​     定义了一个有十个元素的数组，元素类型为字符。
>
> ​     C语言中定义一个变量时可以初始化。
>
> ```c++
> // 错误示范，array bounds overflow（数组边界溢出）
> char str[10] = {"hello world"};// 大括号可以省略
> 
> // 正确写法
> char str[10] = {"helloworl"};
> 当编译器遇到这句时，会把str数组中从第一个元素把
> helloworl\0 逐个填入，str[9]即数组的第10个元素为空字符，打印的显示不出来为空
> ```
>
> ​     **由于C语言中没有真正的字符串类型，可以通过字符数组表示字符串，因为它的元素地址是连续的，这就足够了**。
>
> 看如下例子：
>
> ```c++
> #include <iostream>
> using namespace std;
> 
> int main()
> {
> 	char c[10]="aabsdsf";
> 	printf("%s\n",c);// 数组名即数组首元素地址来输出字符串
> 	printf("%p\n",c);// 数组的地址
> 	printf("%p\n",&c);// 数组的地址
> 	printf("%p\n",&c[0]);// 数组的地址
> 	printf("%p\n",c[0]);// 将c[0]的ASC码转换成p类型的，也就是指针类型的，所以是数组首元素以指针形式输出，内存地址空间是用16进制的数据表示
> 	printf("%p\n",c[1]);
> 	printf("%p\n",c[2]);
> 	printf("%p\n",c[3]);
>     printf("%p\n",c[4]);
> 	return 0;
> }
> 输出如下：
>     aabsdsf
>     0019FF10
>     0019FF10
>     0019FF10
>     00000061 // a的ascii码值为97，转为16进制就是这个
>     00000061 
>     00000062
>     00000073
>     00000064
> ```
>
> ​     C语言中规定数组名代表数组所在内存位置的首地址，整个数组是以首地址开头的一块连续的内存单元，也是 str[0]的地址，即str = &str[0];
>
> ​     而printf("%s",str); 为什么用首地址就可以输出字符串？因为还有一个关键，在C语言中**字符串常量的本质表示其实是一个地址，这是许多初学者比较难理解的问题**。。。
>
> ```c++
> 举例：
>     char  *s ;
>     s = "China";
>     为什么可以把一个字符串赋给一个指针变量。。这不是类型不一致吗？？？
> 这就是上面提到的关键 。。
> // C语言中编译器会给字符串常量分配地址，如果 "China", 存储在内存中的 0x3000 0x3001 0x3002 0x3003 0x3004 0x3005。
> s = "China" ，意思是什么，对了，地址。
> 其实真正的意义是 s ="China" = 0x3000;
> 看清楚了吧 ，你把China 看作是字符串，但是编译器把它看作是地址 0x3000，
> // 即字符串常量的本质表现是代表它的第一个字符的地址。。。
> s = 0x3000
> 这样写似乎更符合直观的意思。。。
> ```
>
> 搞清楚这个问题，那么 %s ，它的**原理其实也是通过字符串首地址输出字符串**，printf("%s ", s);  传给它的其实是s所保存的字符串的地址。。。
>
> ```c++
> 转换说明符
> %c　　　　一个字符
> %s　　　　字符串
> %p　　　　指针(即地址形式)
> ```
>
> char str[10] = "helloworl"；前面已经说了，str = &str[0] ， 也等于 "helloworl"的首地址。所以printf("%s",str); 本质也是 printf("%s", 地址");**C语言中操作字符串是通过它在内存中的存储单元的首地址进行的，这是字符串的终极本质**。。。
>
> ```c++
> #include <iostream>
> using namespace std;
> 
> int main()
> {
> 	char a[10] = "HelloWorl";
> 	char *s;
> 	for(int i = 0; i < 10; ++i)
> 	{
> 		cout << a[i] << " ";
> 	}
> 	cout << "\n" << a[8] << endl;
>     s = "hello";
>     printf("%s\n",s);// 通过字符串首地址输出字符串
>     // 如果通过cout输出字符串的话，则根据通过字符串首地址输出字符串，应写为：
>     cout << &s[0] << endl;
> 	printf("%p\n",s);// 输出字符串首地址，也即指针变量中存放的值它是个地址
> 	printf("%p\n",&s);// 输出变量本身所在内存单元地址，即指针变量本身的地址
> 	printf("%p\n",&s[0]);// 输出字符串首地址
> 	printf("%p\n",&s[1]);// 输出字符串第二个字符的地址，char表示的字符型数据，占一个字节，所以它输出的为前面的地址值加1即可
> 	cout << "\n" << s[0] << "\n" << *s << "\n" << &s << "\n" << &s[0] << endl;
>     return 0;
> }
> // 输出如下
> H e l l o W o r l
> l
> hello
> 00432024
> 0019FF20
> 00432024
> 00432025
> 
> h
> h // *s，s是字符串第一个字符的地址，引领后就是h
> 0019FF20 // &s，s是一个指针变量，&后边一般跟着的是真实数据变量，指针比较特殊，它也是有地址和值的，值是另外一个对象的地址而已，所以对指针变量取地址符时，就得到的是它本身的地址，
> hello
> ```
>
> #### 5.char * 与 char a[ ]
>
> ​    char *s                 char a[ ] 
>
> ​    前面说到 a代表字符串的首地址，而s这个指针也保存字符串的地址（其实首地址），即第一个字符的地址，**这个地址单元中的数据是一个字符，这也与 s 所指向的 char 一致**。
>
>    因此可以 s = a;
>
> ​    但是不能 a = s;
>
> ​       C语言中数组名可以复制给指针表示地址， **但是指针变量却不能赋给给数组名，它是一个常量类型，所以不能修改**。。
>
> 当然也可以这样:
>
> ```c++
> char a [ ] = "hello";
> char *s =a;
> for(int i= 0; i < strlen(a) ; i++)
> 	printf("%c", s[i]);
> 	// 或 printf("%c",*s++);
> ```
>
> ​    字符指针可以用间接操作符 * 取其内容，也可以用数组的下标形式 [ ]，数组名也可以用 * 操作，因为它本身表示一个地址,比如 printf("%c",* a); 将会打印出 'h'；如果想打印出e，就应该写printf("%c",* (a+1))，如果写的是printf("%c",* a+1)则输出的是h的下一个ascii字符，i，**因为ascii字符存储的在内存中的是数值，h对应的数字加1就是它的下一个ascii字符i**。这个地方可以参见后面第七章7.3，指针与数组那节！**另外，* * 、& 与+ 、- 优先级一样**！
>
> char * 与 char a[ ] 的本质区别：
>
> ​    当定义 char a[10 ] 时，编译器会给数组分配十个单元，每个单元的数据类型为字符。。
>
> ​    而定义 char *s 时， 这是个指针变量，只占四个字节，32位，用来保存一个地址。。
>
> 用一句话来概括，就是 char *s 只是一个保存字符串首地址的指针变量， char a[ ] 是许多连续的内存单元，单元中的元素为char ，之所以用 char * 能达到char a [ ] 的效果，还是字符串的本质，地址，即给你一个字符串地址，便可以随心所欲的操所他。。但是，char* 和 char a[ ] 的本质属性是不一样的。。
>
> #### 6   char ** 与char * a[ ] 
>
> ​      先看 char *a [ ] ;
>
> ​      由于[ ] 的优先级高于* 所以a先和 [ ]结合，他还是一个数组，数组中的元素才是char * ，前面讲到char * 是一个变量，保存的地址。。
>
> ​      所以 char *a[ ] = {"China","French","America","German"}；
>
> ​      可以看到， 数组中的元素是字符串，那么sizeof(a) 是多少呢，有人会想到是五个单词的占内存中的全部字节数 6+7+8+7 = 28；但是其实sizeof(a) = 16；
>
> ​      为什么，前面已经说到， **字符串常量的本质是地址**，a 数组中的元素为char * 指针，指针变量占四个字节，那么四个元素就是16个字节了
>
> ```c
>  #include <stdio.h>
> 　int main()
> 　{
>  　char *a [ ] = {"China","French","America","German"};
> printf("%p %p %p %p\n",a[0],a[1],a[2],a[3]); //数组元素中保存的地址
> printf("%p %p %p %p\n",&a[0],&a[1],&a[2],&a[3]);//数组元素单元本身的地址
> return 0;
> 　}
> 注意数组元素中保存的这四个地址是不连续的，它是编译器为"China","French","America","German" 分配的内存空间的地址，所以，四个地址没有关联。
> 数组元素单元本身的地址，这四个是元素单元所在的地址，每个地址相差四个字节，这是由于每个元素是一个指针变量占四个字节。。。
> ```
>
> #### 7.char **s
>
> char **为二级指针， s保存一级指针 char *的地址，关于二级指针就在这里不详细讨论了 ，简单的说一下二级指针的易错点。 
>
> ```c++
> 举例：
> char *a [ ]={"China","French","America","German"};
> char **s =  a;
> ```
>
>  为什么能把 a赋给s,因为数组名a代表数组元素内存单元的首地址，即 a = &a[0] = 0012FF38；而 0x12FF38即 a[0]中保存的又是 00422FB8 ,这个地址00422FB8为字符串"China"的首地址。
>
> 即 *s = 00422FB8 = "China"；这样便可以通过s 操作 a 中的数据。
>
> ```c++
> printf("%s",*s);
> printf("%s",a[0]);
> printf("%s",*a);
> 都是一样的。。。输出China
> 但还是要注意，不能a = s，前面已经说到，a 是一个常量。。
> ```
>
> 再看一个易错的点：
>
> char **s = "hello world";
>
> 这样是错误的，
>
> 因为 s 的类型是 char ** 而 "hello world "的类型是 char *
>
> 虽然都是地址， 但是指向的类型不一样，因此，不能这样用。**从其本质来分析，"hello world",代表一个地址，比如0x003001,这个地址中的内容是 'h'**，为 char 型，而 s 也保存一个地址 ，这个地址中的内容(*s) 是char *　，是一个指针类型，　所以两者类型是不一样的。　。。
>
> 如果是这样呢？
>
> ```c++
> char **s;
> *s = "hello world";
> ```
>
> ​    貌似是合理的，编译也没有问题，但是 printf("%s",*s),就会崩溃，why??
>
>    咱来慢慢推敲一下。。
>
> ​    printf("%s",*s); 时，首先得有s 保存的地址，再在这个地址中找到 char * 的地址，即*s;
>
>    举例：
>
> ​    s = 0x1000;
>
>    在0x1000所在的内存单元中保存了"hello world"的地址 0x003001 ，*s = 0x003001;
>
>    这样printf("%s",*s);
>
>    这样会先找到 0x1000,然后找到0x003001;
>
>    如果直接 char **s;
>
>    *s = "hello world";
>
> ​    s 变量中保存的是一个无效随机不可用的地址， 谁也不知道它指向哪里。。。。，*s 操作会崩溃。。
>
> ​    所以用 char **s 时，要给它分配一个内存地址。
>
> ```c++
> char **s；
> s = (char **) malloc(sizeof(char**));
> *s = "hello world";
> ```
>
>   这样 s 给分配了了一个可用的地址，比如 s = 0x412f;
>
>  然后在 0x412f所在的内存中的位置，保存 "hello world"值。。
>
> ```c++
> 再如：
>   #include <stdio.h>
>   void buf( char **s)
>   {
>      *s = "message";
>   }
>   int main()
>    {
>    char *s ;
>    buf(&s);
>    printf("%s\n",s);
>    }
> ```
>
>   二级指针的简单用法。。。。，说白了，二级指针保存的是一级指针的地址，它的类型是指针变量，**而一级指针保存的是指向数据所在的内存单元的地址**，虽然都是地址，但是类型是不一样的。。。

### 2.数组

#### **数组的意义与性质**

数组的定义：

定义格式：元素类型 数组名称[常数表达式]

示例：int a[8]; //定义包含8个整数元素的数组

**特别说明**：常数表达式必须是常数和常量，不允许为变量。因为编译器需要根据这个表达式的值来去元素的个数，然后要为它分配空间，那么这个计算的任务是在什么时候做的，是在编译的时候做的，所以如果你给它一个变量，它就没法在编译的时候算出它的结果来，它不能为它分配一个合适的内存空间，那么这个编译器就会拒绝分配。所以这个常数表达式必须是一个常数或者常量，这两种在C++里都可以，在C里面常量是不允许的，只能为常数。

```c++
const int count = 0;
int c[count];
//大多数编译器这样可以通过，但是在C程序里这样不行，只能为常数才行 
```

数组的操作不允许对数组进行整体赋值。

意义于性质：**将相同性质的数据元素组织成整体，构成单一维度上的数据序列**。如果你有很多个数据对象，它们性质是一样的，你定义很多个变量，那么久割裂了这些数据对象从属于同一个集合的性质，它是一个整体。

#### 数组的存储表示

**数组元素依次连续存放，中间没有空闲空间**。前面没有**前导标记，后边没有结束标记**。

数组的地址

数组的基地址：数组开始存储的物理位置

数组首元素的基地址：数组首个元素开始存储的物理地址，数值上总是与数组基地址相同

“&”操作符：&a 获得数组的基地址；&a[0] 获得数组首元素的基地址（单独出现数组名字a时往往意味着我们取这个数组的基地址）

设数组基地址为 p，并设每个元素的存储空间为 m，则第i 个元素的基地址为 p + mi

#### 数组元素的初始化

前4个不初始化，初始化后4个，写为int a[8] = {,,,,5,6,7,8}，,不能省略，这样它才知道0、1、2、3号你没写；

前4个初始化，后4个不初始化，写为int a[8] = {1,2,3,4}

#### 数组与函数

1)数组元素作为函数**实际参数**

2）数组整体作为函数**形式参数**

```c++
基本格式：返回值类型 函数名称( 元素类型 数组名称[], 元素
个数类型 元素个数 )
示例：void GenerateIntegers( int a[], unsigned int n );
// 特别说明：作为函数形式参数时，数组名称后的中括号内不需列写元素个数，必须使用单独的参数传递元素个数信息
```

数组作为函数参数的时候，它不仅是函数输入集的一部分，也是这个函数的输出集的一部分。

```c++
// 不写常数：不知道元素个数，易出错
void GenerateIntegers( int a[], int lower, int upper )
{
 ……
}
```

调用格式

使用单独数组名称作为函数实际参数，传递数组基地址而不是数组元素值；

形式参数与实际参数使用相同存储区，对数组形式参数值的改变会自动反应到实际参数中。

```c++
#define NUMBER_OF_ELEMENTS 8
const int lower_bound = 10;
count int upper_bound = 99;
int a[NUMBER_OF_ELEMENTS];
GenerateIntegers( a, NUMBER_OF_ELEMENTS, lower_bound, upper_bound);
```

#### 多维数组

```c++
多维数组的定义
定义格式：元素类型 数组名称[常数表达式1] [常数表达式2]…;
示例一：int a[2][2]; /* 2×2 个整数元素的二维数组 */
示例二：int b[2][3][4]; /* 2×3×4 个整数元素数组 */
特别说明：同单维数组
多维数组的初始化
与一维数组类似： int a[2][3] = {1, 2, 3, 4, 5, 6};
单独初始化每一维： int a[2][3] = { {1, 2, 3}, {4, 5, 6} };
```

### 3.结构体

#### 结构体的意义与性质

结构体的意义

与数组的最大差别：不同类型数据对象构成的集合
当然也可以为相同类型的但具体意义或解释不同的数据对象集合

```c++
struct 结构体名称
 {
 成员类型 1 成员名称 1;
 成员类型 2 成员名称 2;
 ……
 成员类型 n 成员名称 n;
 };
// 这里面有一系列元素，我们称之为字段、域、成员，每个元素类型可以一样也可以不一样
```

#### 结构体的存储表示

按照成员定义顺序存放，各成员的存储空间一般连续，中间可能会出现空洞，

特殊情况
因为不同硬件和编译器的原因，不同类型的成员可能会按照字（两个
字节）或双字（四个字节）对齐后存放；
使用 sizeof 获得结构体类型量占用空间大小（以字节为单位），下 述两种使用方式均可（不要想当然认为它是各个成员的存储空间大小之和）
 sizeof date; sizeof( date );

#### 结构体数据对象的访问

```c++
结构体类型的变量与常量：按普通量格式定义
示例一：DATE date;
示例二：STUDENT zhang_san;
示例三：STUDENT students[8];
```

**与数组不同，结构体量可直接赋值，拷贝过程为逐成员一一复制**（是一种浅拷贝）

#### 结构体与函数

```c++
编写一函数，使用结构体类型存储日期，并返回该日在该年的第几天
信息，具体天数从 1 开始计数，例如 2016 年 1 月 20 日返回 20，
2 月 1 日返回 32
unsigned int GetDateCount( DATE date ) {
 static unsigned int days_of_months[13] =
 { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
 unsigned int i, date_id = 0;
 for( i = 1; i < date.month; i++ )
 date_id += days_of_months[i];
 date_id += date.day;
 if( date.month > 2 && IsLeap(date.year) )
 date_id++;
 return date_id; }
```

```c++
计算机屏幕上的点使用二维坐标描述。编写函数，随机生成一个屏幕
上的点。设计算机屏幕分辨率为 1920×1200，屏幕坐标总是从 0 
开始计数
struct POINT{ int x, y; };
const int orignal_point_x = 0;
const int orignal_point_y = 0;
const int num_of_pixels_x = 1920;
const int num_of_pixels_y = 1200;
POINT GeneratePoint()
{
 POINT t;
 t.x = GenerateRandomNumber( orignal_point_x, num_of_pixels_x - 1 );
 t.y = GenerateRandomNumber( orignal_point_y, num_of_pixels_y - 1 );
 return t;
}
```

## 七.指针与引用

引用是一个和指针相关的一个新的数据类型，和指针非常相似，但是又完全不同，某些方面它起到的作用和指针是相同的，但是在具体的实现上，和指针实际上是截然不同的。**它不仅是一种新的数据类型，它事实上还是一个新的参数传递机制**。

### 1.指针基本概念

每一个变量，也就是说每个数据对象，它有四个基本特征：VANT。一旦你的程序编译完成后，N（name）和T（type）就没了，正常情况下，信息是缺失的，在我们的程序代码里面，实际上主要就那么两个东西：一个是地址，一个是值。

**数据对象的地址与值**

地址：数据对象的存储位置在计算机中的编号

值：在该位置处存储的内容

地址与值是辩证统一的关系，通过一种恰当的机制，我们可以让一个量的地址就是值，可以让一个值就是一个地址。**这个机制就叫指针**（它就是构造地址和值辩证统一的最重要的一个桥梁）。

#### 指针的定义格式

格式：目标数据对象类型*指针变量名称；

例一：定义p为指向整数的指针：int * p；

```c++
int *p; //*号前有空格，可以是任意个空格
int* p; //*号后有空格，可以是任意个空格
int*p; //*号前后都没有空格
int * p; //*号前后都有空格，可以是任意个空格
//在定义的代码中，有一个*代表指针，有两个*就代表指向指针的指针，有三个*就代表指向指针的指针的指针~~~
//这个写法看个人习惯，其实如果*靠近返回值类型的话可能更容易理解其定义。

int *a;
int* a;
两者意思相同且后者看上去更为清楚:a被声明为类型为 int* 的指针. 但是,这并不是一个好技巧,原因如下:
int* b, c, d;

人们很自然地以为这条语句把所有三个变量声明为指向整形的指针, 但事实上并非如此. 我们被它的形式愚弄了. 星号实际上是表达式 *b 的一部分, 只对这个标识符有用。 b 是一个指针, 但其余两个变量只是普通的整形. 要声明三个指针, 正确的语句如下:

int *b, *c, *d
```

> 上述四种写法编译都没有错误，在定义中的 * 号我们现在可以理解为这仅仅代表定义了一个指针变量p, p的类型是 int * 或者 int* 。
>
> 之后要讲到 * 的 “取地址中的内容” 这个意思，那么这个 * 号和定义中使用的 * 号，是一个意思么？
>
> 我们先从 * 和 & 后边接的变量以及作用说起，之后再对第一篇文章中讲解的指针的定义进行更加深入的理解
>
> **& 和 * 可以理解为对紧接在后边的变量进行一定的信息提取**
>
> & 和 * 后边紧接的都是变量，但后边接的变量有所不同，& 后边紧接的是**存放真实数据的变量**（整型变量 a 或者是字符变量 b等），而 * 后边紧接的是**存放地址数据的变量**（比如int * 类型的变量或者char *类型的变量）
>
> &a 意味着提取变量 a 的地址，我们想要知道 a 放到哪里了
>
> *p意味着提取变量p里存放的地址所对应的存储空间里存放的真实数据，我们想知道这个地址处放了什么内容，101教室上的什么课。
>
> 知道了 * 符号代表的意思，我们来看一下上一篇文章讲的指针的定义~
>
> ```cpp
> int *p;
> ```
>
> 定义一个int型数据 a 时，是这样的语句 int a; 我们不妨类比一下，把 *p 先看成一个整体， *p 就是一个整型变量。
>
> *p是一个整型变量，我们讲 * 后边接的变量是一个指针变量，那么 p 就是一个指针变量了，那么 p 就是存放 *p 的内存的地址；
>
> (* p 是一个整型变量，同时我们能得到 &*p 就是存放 *p 的内存的地址)；
>
> **最终我们得到 p=&*p** 

含义：定义一个指针类型的变量名字叫p，它是一个指针，指向一个整数；把这个写法倒过来看，定义一个变量，名字叫p，它是一个指针，指向一个整数。

多个指针变量的定义：

例二：int * p，* q；

如果怕忘记第二个变量的*，可采用如下方式：typedef int * PINT；PINT p,q；如果写PINT p, * q；那么q指向PINT，即指向指针的指针。

#### 指针变量的存储布局

在使用指针的时候**一定要记住**：指针数据对象事实上涉及到两个数据对象，并不是只有一个，一个就是指针数据对象本身，第二个就是指针所指向的目标数据对象。

如果你在定义这个指针变量过程中，**同时对它进行初始化，那么这个时候就会涉及到两个数据对象。**

> 一定一定记住一点， **指针和变量一样，也是有值的，只不过变量的值被解释成一个值，而指针的值被解释成一个地址。**

定义指针变量，**并使其指向数组首元素**：

例三：int a[8] = {1,2,3,4,5,6,7,8};int * p = a;

p作为一个指针，只能指向一个整数，并不能指向8个整数，即p指向数组的0号元素。

**指针变量可以像普通变量一样赋值**

示例：

```c++
int n = 10; 
int *p = &n, *q;
q = p;
//两个指针指向同一个目标数据对象
```

#### 取址操作符“&”

获取数据对象的地址，可将结果赋给指针变量（得到的地址像一个普通的值一样赋值给指针变量）

#### 引领操作符

获取指针所指向的目标数据对象

用* p去引领p所指向的目标数据对象，p指向n，那* p就代表这个指针p所指向的目标数据对象n

#### 指针的意义与作用

**作为函数通信的一种手段**

使用指针作为函数参数，不仅可以提高参数传递效率，还可以将该参数作为函数输出集的一员，带回结果；（和外界进行通讯的时候，函数可以有一个返回值或者没有，它只能带回来一个结果，如果想带回来两个以少的结果怎么办呢？把它的两个结果合成一个结构体，用这个结构体作为函数的返回值，它就可以把这个同时都带回来；还有一种方案，指针作为函数参数，它就可以把这个结果带回来）

**作为构造复杂数据结构的手段**

使用指针构造数据对象之间的关联，形成复杂数据结构

**作为动态内存分配和管理的手段**

可以在程序执行期间动态构造数据对象之间的关联

**作为执行特定程序代码的手段**

使用指针指向特定代码段，执行未来才能实现的函数

**<font color = "00aaee">这四种使用场合务必掌握！</font>**

### 2.指针与函数

一个结构体的尺寸往往会很大，你要传结构体，那么结构体得整体赋值，如果传指向结构体的指针，那么它只需要赋结构体的地址就行了，结构体的地址有多大呢？32位的计算机、32位的编译器，它的尺寸是固定的4个字节。

**注意**：示例中main函数中写了swap函数，在main函数里有两个量m，n，调用swap时实际上是覆盖了这个main函数的栈框架，所以在swap执行过程中是看不见main函数的数据的，实际上是不能访问m和n的值的，也就是说不能在swap中使用main函数的m和n，并不表示它们不存在，只是我们没办法通过名字m和n来访问它们。现在我们有指针了，可以用* x，* y访问，* x就是m，* y就是n。

> 变量的作用域（生命周期）可以通过所在du的大括号界别来确定；
> main里定义的变量，是在main的大括号里， 所以在test的大括号是访问不到的（他们不是包含的关系）
> 而类的那个，定义的成员变量（字段）是属于class的大括号，而里面的方法的大括号是class大括号里面的（包含），所以是可以访问到的

#### 常量指针与指针常量

常量指针：指向常量的指针

性质：不能通过指针修改目标数据对象的值（即不可以通过引领操作符来修改目标数据对象的值），但可以改变指针值，使其指向其他地方。

```c++
示例一：
int n = 10; const int *p = &n;
```

典型使用场合：作为函数参数，表示函数内部不能修改指针所指向的目标数据对象值。

```c++
示例二：
void PrintObject(const int *p);
//限定了指针p只能作为函数输入集的一部分，不能作为函数输出集的一个部分
```

指针常量：**指针指向的位置不可变化**

性质：不可将指针指向其他地方，但可改变指针所指向的目标的数据对象值

**<font color="00aaee">指针常量和其他常量一样，必须在定义的时候初始化！</font>**

```c++
示例三：
int n = 10;
int * const p = &n;
//这个时候必须把它初始化为&n；因为p是一个常量，不可以被赋值，所以你定义它的瞬间必须初始化。
//前面的常量指针你不初始化是可以的，然后再赋值p=&n
```

常量指针常量：指向常量的指针常量（指针的双重只读属性）

```c++
示例四：
const int n = 10;
const int * const p = &n;
//const关键字实际上是左结合的，它作用在它左边的标记上面，
const int * p = &n;//const左边啥都没有，这个时候就只能作用它右边的int上面，它不作用在*上面，也不作用在int *上，表示那个整数是常量。
//如果严格按照const的左结合，那么const int应该写为int const，所以示例四中的第一个const写在int前或者后都是对的，第二个const一定要写在*后边。
```

典型使用场合：主要作为函数参数使用（大部分情况下不需要搞这么复杂，主要使用常量指针）

#### 指针与函数返回值

指针类型可以作为函数返回值，它会带回来一个目标数据对象的地址，但是指针作为函数返回值的时候，它不能返回函数内部定义的局部变量的地址，只能返回某个全局变量的地址或者作为函数的参数传给函数的指针。

```c++
程序示例：
int global = 0;
int * ReturnPointer()
{
return &global;
}
```

网上查找补充知识点：

**指针函数与函数指针**

指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，**而该函数的返回值是一个指针**（即地址值）。
声明格式为：类型标识符 *函数名(参数表)

```c++
int* fun(int x,int y);
```

函数指针，**其本质是一个指针变量，该指针指向这个函数**。总结来说，函数指针就是指向函数的指针。
声明格式：类型说明符 (*函数名) (参数)

```c++
int (*fun)(int x,int y);
```

函数指针是需要把一个函数的地址赋值给它，有两种写法：

```c++
fun = &Function;
fun = Function;
```

取地址运算符&不是必需的，**因为一个函数标识符就表示了它的地址**，如果是函数调用，还必须包含一个圆括号括起来的参数表。
调用函数指针的方式也有两种：

```c++
x = (*fun)();
x = fun();
```

两种方式均可，**其中第二种看上去和普通的函数调用没啥区别**，如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。当然，也要看个人习惯，如果理解其定义，随便怎么用都行啦。

### 3.指针与复合数据类型

#### 指针与数组

数组基地址：&a或者a

数组首元素地址：&a[0]

数组第i个元素地址：&a[0]+i*sizeof(int)

**数组基地址与首元素地址数值相同**，故：数组第i个元素地址可表示为a+i*sizeof(int)

**指针运算**

指针与整数加减运算的结果仍为指针类型量，故可赋值。

设p为指向整数数组中某元素的指针，i为整数，则p+i表示指针向后滑动i个整数，p-i表示指针向前滑动i个整数。

**规律**：以指针指向的目标数据对象类型为单位，而不是以字节为单位。

递增递减：p指向a[0]，则p++指向a[1];p指向a[1]，则--p指向a[0]

指针减法运算：两个指针的减法运算结果为其间元素个数

过尾元：让一个指针指向数组0号元，在数组最后增加一个元素，让另一个指针指向它，两个指针相减即得到数组的长度。

关系运算：p==q测试两个指针是否指向同一个目标数据对象

**空指针**：NULL

​	指针值0：表示指针不指向任何地方，表示为NULL；**其实它指向的是内存条最开头的存储区。不过现在主流的操作系统，几乎所有的操作系统在那个存储区都是什么数据都不保存的，专门就用来捕获指针错误的**。

例：设p为指针，则p=NULL表示p不指向任何目标数据对象

**特别注意**：使用指针前一定要测试其是否有意义，if(p != NULL)或if(p)；当你在编写带有指针的程序的时候，它非常容易出错，如果这个指针是错的，它指向一个无意义的地方或者它没有权利去访问的地方，这个程序不是错的而是崩溃，这个错误就太严重了，所以每次使用指针都要注意这点！每次访问指针，想通过引领操作符访问它的目标数据对象的时候，都要测试这个指针是不是有意义。

**指针数据对象，理论上来讲，你应该对它进行初始化**。要么是合法有效的目标数据对象的地址，要么就是0。只有这样才能保证你的测试每次都是有意义的。因为如果你不对它初始化，它是个全局量，自动被初始化为0，如果这个指针变量本身是个局部量，那么它内部的位序列就是随机的，极有可能不是0。如果不是0，你一访问，目标数据对象区域没有权利访问的，程序一下就崩了。

**作为函数参数的指针与数组**

```c++
*p++ = GenerateRandomNumber(lower_bound, upper_bound);
```

*p++，这是两个操作符 * p、p++，因为是后缀++，所以是把函数调用后生成的那个整数赋值给 * p，然后才能做p++。它做的绝不是（* p）++，不是（* p），如果你是想把* p这个目标量累加，那么你必须写（* p）括号完毕后++那才对。p一开始指向0号元，所以把生成的那个数赋值给0号元，然后p++让p指向1号元。

指针作为函数参数：函数调用

​	必须传递已分配空间的数组基地址，比如int a[8]。

#### 指针与数组的可互换性

**指针一旦指向数组的基地址，则使用指针和数组格式访问元素时的地址计算方式是相同的，此时可以互换指针与数组操作格式**：<font color='00aaee'>p[i]与*（a+i）分别与a[i]与 * (p+i)的功能是一样的</font>。但是并不表示此时指针与数组真的等价。在某种程度上讲，指针和数组的等价的，可以互换，**注意**，这并不是全部的应用场合，**在一维数组上是有效的，在高维它可能就是无效的了**。

指针和数组真是完全等价的吗？当然也不是，它还是有一些例外的。**数组名本身它是一个常数**，此时不能在数组格式上面进行一些特定指针运算的；比如：

```c
for(int i = 0; i < 3; i++)
	cout << *a++ <<endl;
//可以写*a+1，*a+2等，但是不能写*a++；
因为a++它是a+1赋值给a，因为a是一个常数，它不能被赋值。
//而*p++可以，它是指针量
```

#### 指针与数组的差异

```c
int a[3] = {1,2,3};
int *p = &a; //会为p分配一个存储空间，这个存储空间有多大呢？我们现在32位计算机、32位的编译器，p是四个字节，int a[3]是12个字节，

```

定义数组的同时确定了数组元素的存储布局：a为静态分配内存的数组；若a 为全局数组，则程序执行前分配内存；若为局部数组，则在进入该块时分配内存。

定义指针时规定指针数据对象的存储布局：**p** 为指针，若 p 为全局变量，则程序执行前分配内存；若为局部变量，则在进入该块时分配内存。

**注意**：**定义指针的时候，规定的是指针数据对象的存储空间**，定义数组的时候，它规定的是数组元素的存储空间。这两者是不一样的。如果你定义一个指针，它就不会为那个数组分配空间，它只分配指针这个对象的空间，**如果这个指针指向那个数组**，**你必须保证那个数组已经分配了，其他地方分配的跟这个指针没关系**，**除非你是动态分配的**。

定义指针时未规定目标数据对象的存储布局：**p** 为指针，指向一个已存在数组的基地址，即指向该位置处的整数 a[0]；若a未初始化，则目标数据对象未知。

**所以**：使用指针时，指针这个对象和指针所指向的目标数据对象两者之间的关联在你的程序里必须显示地构造它。

#### 多维数组作为函数参数

不能每维都不传递元素个数，语法规则不允许，二维数组只能第一个中括号里什么都不写，三维数组里也只能第一个中括号里什么都不写，后面的你都必须给写上，没有数据是不对的，编译器是通不过的。所以采用另一种方案，把二维数组当一维数组降维，但是找具体的a[i] [j]，使用运算a+n*i+j运算有点麻烦，到了高维数组以后要这么运算，能不能算出来都不好说了，到了高维降维都有可能出问题；而且从逻辑上讲明明是二维搞成一维有点怪怪的。

那么有没有一个妥当的方案呢？没有，不管是C还是C++里，当多维数组作为函数参数传递的时候，就没有一个好方案能够解决这个问题。所以实在没招，建议按照第一个方案写：

```c
void PrintTwoDimensinalArray(int a[8][8], unsigned int m, unsigned int n);
```



#### 指针与结构体

```c++
指向结构体的指针对象
struct STUDENT{ int id; STRING name; int age; };
STUDENT student = { 2007010367, "Name", 19 };
STUDENT * pstudent = &student;
```

**访问指针所指向的结构体对象的成员**

必须使用括号：选员(.)操作符优先级高于引领操作符，比如：（*pstudent).id

C/C++提供了一个新的操作符，选员操作符"->"，比如pstudent -> id

> 如果对象是使用 new 在自由存储区中实例化的，或者有指向对象的指针，则可使用指针运算符（->）来访问成员属性和方法。

**结构体成员类型维指针**

```c
struct ARRAY{ unsigned int count; int * elements; };
int a[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
ARRAY array = { 8, &a };
//访问指针类型的结构体成员
//访问 elements 的第 i 个元素： array.elements[i];也就是把element当作数组用
```

```c
//若有定义：ARRAY * parray = &array;

访问parray指向的结构体对象elements的第i个元素：

//(*parray).elements[i]或parray->elements[i]
```

#### 结构体指针的使用场合

有两个非常重要的使用场合：

​	**使用指向结构体对象的指针作为函数参数**

```c
好处一：节省结构体整体赋值的时间成本
好处二：（普通结构体类型的参数作为参数传进去，它不能把结果带回来，我们就觉得不方便，想带回来结果，传它的指针，结果就能带回来了）解决普通函数参数不能直接带回结果的问题，可以在函数内部改变目标结构体对象的值
//你又想快，又不想带回来结果，就指向const结构体的指针
```

​	**构造复杂的数据结构**

```c
我想创建一个数据结构，这个数据结构能够表达动态的数组信息，表达数组元素个数，可以在整个程序运行期间，随时发生变化的数据结构，它里边保存了一系列元素，这些元素的个数可以在程序运行期间动态的变化，可以大也可以缩小，这个我们就称它为动态数组，我们就需要使用很特殊的像这样的数据结构
动态数组：struct ARRAY { unsigned int count; int * elements; };
//count为数组元素的个数，然后用一个int * element来表达指向特定元素的指针，以后就可以通过element指针的运算来访问它的0号元、1号元、2号元；你定义好这个数据结构必须为它创建一系列对动态数组进行操作的函数
```

### 4.字符串

字符串的表示

三种理解角度：作为字符数组，作为指向字符的指针，作为抽象的字符串整体

#### 多个字符数组连续存储时的问题

如何区分存储空间刚好连续的多个字符数组?

解决方案：字符数组末尾添加结束标志'\0'，'\0'即ASCII码值为0的那个字符

**优** **点**

可以在程序运行时通过测试‘\0’字符确定字符数组是否结束，而不需要了解数组元素个数，使处理元素个数未知的数组成为可能通过指针运算直接操作字符数组中的字符，而不再使用数组格式访问字符元素

**字符指针量的定义、初始化与存储**

char *s = "CPP-Prog"；

s作为一个指针它会分配一段存储空间4个字节，里面保存字符串的基地址，而那个字符串基地址里面会分配9个字节，来存"CPP-Prog\0"。注意，这里面双引号字符串文字尾部的'\0'是编译器为我们自动添加的。

**特别注意**：不管char *, int *, float *,所有类型的指针变量在32位系统上都是4字节， 64位系统上都是8字节。

**用char *s定义的时候它会多一个指针变量**

#### 字符数组与字符指针的差异

①按指针格式定义字符串，可以直接赋值

```c
示例：
char * s; 
s = "CPP-Prog"; // 正确
//字符串文字首先分配空间，然后将其基地址赋给 s，使 s 指向该字
//符串基地址
```

②按字符数组格式定义字符串，不能直接赋值

```c
示例：
char s[9]; 
s = "CPP-Prog"; //** **错误**

//不能对数组进行整体赋值操作
//char s[9]会分配9个字符的存储空间，然后“CPP-Prog”它本身也要分配9个字符的存储空间，保存进去，然后把这个基地址赋值给s，赋值不了，s是个数组，它必须接受9个字符，而不是接受9个字符的基地址。
//原因：数组空间已分配，字符串文字空间已分配，且它们位于不同位置，不能直接整体复制
```

示例：编写函数，将某个字符c转换为字符串

```c
typedef char * STRING
STRING TransformCharIntoString( char c )
{
 STRING _s = (STRING)malloc( 2 );
 _s[0] = c;
 _s[1] = '\0';
 return _s;
}
//分配2个字节的存储空间，分配出来的空间转换为STRING，然后把它初始化或赋值给STRING类型变量_s
```

```c++
char * TransformCharIntoString( char c )
{
 char _s[2];
 _s[0] = c;
 _s[1] = '\0';
 return _s;
}
//错误函数定义
	对于所有返回值为指针类型的函数，都不能返回在函数内部定义的局部数据对象——所有局部对象在函数结束后不再有效，其地址在函数返回后没有意义
```

#### 标准字符串库

**标准库中关于字符串处理的函数很多，均定义于头文件“cstring”中**，用C++的就包含“string”。

如果写C++，不建议使用标准字符串库，使用string类代替。

**string类**

```c
定义于头文件“string”中
声明与构造string对象
string s = "abcdefg"; //定义s然后把它初始化
string s( "abcdefg" ); //直接构造的时候对它初始化，这种方式更好
读取与写入string对象
cout << s << endl;
cin >> s; // 读取以空格、制表符与回车符分隔的单词
getline( cin, s, '\n' ); // 读取包含空格和制表符在内的整行
//从cin这个输入流里面去读取，然后把这个东西读到s字符串里面去，最后的'\n'表示以它结尾，读的是一整行
```

①获取string对象的长度

使用length()函数，从属于string类这个对象的。

②改变string对象的容量大小

s.resize(32); // 将s设为32字符长，多余舍弃，不足空闲
s.resize(32, '='); // 多余舍弃，不足补‘=’

③string对象的追加操作

string s1 = "abcd", s2 = "efg";
s1.append( s2 ); // 将字符串s2追加到s1尾部

或者更简单直接使用’+‘，提供了重载操作符，可以直接使用。

④string对象的比较操作

string s1 = "abcdefg", s2 = "abcdxyz";
int a = s1.compare( s2, 0 ); // 从0号位字符开始比较

⑤string对象的查找操作

string s1 = "abcdefg", s2 = "bcd";
int a = s1.find( s2, 0 ); // 从字符串开头开始查找，结果为
s2在s1中首次出现的位置

### 5.动态存储管理

#### 内存分配与释放

①静态内存分配方式

适用对象：全局变量与静态局部变量

程序运行前分配好，程序结束了它就释放

静态的方式分配的这些内存它的生存期是巨大的，它就和我们的程序一样长。实际上比我们真正的main函数运行还要长，它在main函数之前就能分完，main函数做完了它才能够销毁。

②自动内存分配

适用对象：普通局部变量
分配与释放时机：在程序进入该函数或该块时自动进行，退出时自动释放

③动态内存分配方式

你想让它什么时候分配就什么时候分配，想让它什么时候销毁就什么时候销毁，全由程序员编程说了算。

动态内存分配的目的
	静态与自动内存分配方式必须事先了解数据对象的格式和存储空间大小，部分场合无法确定数据对象的大小

动态内存分配的位置
	计算机维护的一个专门存储区：堆
	所有动态分配的内存都位于堆中

动态内存分配的关键技术
	使用指针指向动态分配的内存区
	使用引领操作符操作目标数据对象

​	也就是说没有指针这个动态内存分配是做不到的。

#### 标准库的动态存储管理函数

```c
动态存储管理函数的原型
头文件：“cstdlib”和“cmalloc”，两者包含其一即可
内存分配函数原型：void * malloc( unsigned int size );
内存释放函数原型：void free( void * memblock );

```

**void * 类型**

**<font color="00aaee">一个非常非常非常重要的数据类型</font>**

称它为哑型指针，特殊的指针类型，它非常特殊。

它表示指向的目标数据对象类型是未知的，它是一个指针没错，指针的目标数据对象类型void也没错，不是说它的目标数据对象没有类型，**目标数据对象一定是有类型的，但是它的类型是什么呢？我不知道**。

所以你绝不能在其上使用引领操作符访问目标数据对象

> This gives `void` pointers a great flexibility, by being able to point to any data type, from an integer value or a float to a string of characters. In exchange, they have a great limitation: the data pointed to by them cannot be directly dereferenced (which is logical, since we have no type to dereference to), and for that reason, any address in a `void`pointer needs to be transformed into some other pointer type that points to a concrete data type before being dereferenced.
>
> ---cplusplus.com/doc/tutorial/pointers
>
> ---它们指向的数据不能直接解引用(这是符合逻辑的，因为我们没有类型可以解引用）

可以转换为任意指针类型，不过转换后类型是否有意义要看程序逻辑
可以在转换后的类型上使用引领操作符（或称解引用操作符）

主要目的：作为一种**通用指针类型**，首先构造指针对象与目标数据对象
的一般性关联（我用一个指针，指向一个东西，那个东西类型是什么我现在还不知道，那我就用void * 指针，然后指向它），然后由程序员在未来明确该关联的性质（这就是void * 最重要的一个地方）

所以在C语言里，它是通用的类型，什么东西都可以表示，因为如果它不能表示，它一定能够表示那个东西的地址，比如那个结构体 void * 不能表示，但是我能表示指向结构体的指针，能够表示那个结构体的地址啊，int * 它也能表示，实际上因为在32位编译器下边，它这个void * 指针尺寸是固定的4个字节，如果int刚好也是四个字节呢，int就可以直接转换成void * ，反正尺寸是够的，你直接传进去就行了。它是通用的一个型。

1）malloc与free

示例：编写函数，复制字符串

```c
char * DuplicateString( char * s )
{
 char * t;
 unsigned int n, i;
 if( !s )
 	{ 
     	cout << "DuplicateString: Parameter Illegal."; 			exit(1);
 	}
 n = strlen( s );
 t = ( char * )malloc( n + 1 );
 for( i = 0; i < n; i++ )
 	t[i] = s[i];
 t[n] = '\0';
 return t;
}
//这个地方指针是不能直接赋值的，直接赋值那两个指针都指向目标字符串了
//这个字符串的构造我们一定要动态地构造，因为在调用这个函数之前，我压根就不知道s所指向的那个串有多少个字节，所以你没有办法预先假定新的串的存储空间要多大合适，你只能按照这个方式来，给我多长就分配多长。
```

特别说明：有分配就有释放

**free 函数释放的是 p 指向的目标数据对象的空间，而不是 p 本身的存储空间**，p本身不需要销毁，它要么是全局量，要么是局部量。

调用 free 函数后，p 指向的空间不再有效，但 p 仍指向它

为保证在释放目标数据对象空间后，不会再次使用 p 访问，建议按照下述格式书写代码：

```c++
free(p); 
p = NULL;
```

```c++
示例二：
int * p = ( int * )malloc( 10 * sizeof( int ) ); 
free( p );
//示例二分配能够容纳 10 个整数的连续存储空间，使 p 指向该空间的基地址，虽然指向0号元，实际上通过这个指针操纵的是40个字节的存储空间；最后调用 free 函数释放 p 指向的整个空间,而不是只销毁数组的0号元
```

2）new与delete

这个功能要比malloc和free强大很多；它事实上不仅能够替你分配内存，还能够替你构造所分配的那个目标数据对象。

new和delete是配对使用的，new[]和delete[]是配对使用的，malloc和free配对使用；c的与c++的不能混用。

**所有权与空悬指针**

指针为什么难用？它涉及到很重要的一个地方，就是这里面涉及到两个数据对象，一个是目标数据对象，还有一个指针数据对象本身，尤其是当目标数据对象本身它是没有名字的时候，那么这种情况下面，访问它的唯一的手段，就是需要通过一个指针数据对象来指向它。这种时候我们可以称之为这个指针拥有那个目标数据对象的所有权，问题就在于我们编程的时候，我们有可能很多个指针指向同一个目标数据对象，那么这种情况下谁拥有它，谁有权使用它，一个是使用权，一个不仅有使用权还有所有权。这个就需要决定。但是我们的程序中呢，其实也没有什么很好的方案能够解决这个问题，尤其是在C/C++早期的代码里，这个东西是没有办法解决的，你只能是程序员头脑中要很清晰地架构这个目标数据对象是谁所有 的，谁只有使用权而不是拥有权。这样才能保证你的程序不容易写错，否则的话非常容易出错。

（所以）指针使用的一般原则

```c
主动释放原则：如果某函数动态分配了内存，在函数退出时该目标数据
对象不再需要，应主动释放它，此时 malloc 与 free 在函数中成对出现
    
所有权转移原则：如果某函数动态分配了内存，在函数退出后该目标数
据对象仍然需要，此时应将其所有权转交给本函数之外的同型指针对象，
函数内部代码只有 malloc，没有 free
//因为这个内存区域是这个函数中某一个局部变量所拥有的，它有所有权，但是那个变量将会随着这个函数一样死掉了，所以这个所有权必须在这个函数结束之前要能够完成它的转移，往往都是通过函数的返回值转移给我们的主调函数
```

在编写指针类型的程序的时候，经常会出现两种问题，一个就是空悬指针的问题，

```c
//所有权的重叠：指针赋值操作导致两个指针数据对象指向同样的目
//标数据对象，即两个指针都声称“自己拥有目标数据对象的所有权”
示例：
int *p, *q; 
q = ( int* )malloc( sizeof(int) ); 
p = q;
产生原因：如果在程序中通过某个指针释放了目标数据对象，另一
指针并不了解这种情况，它仍指向不再有效的目标数据对象，导致
空悬指针
示例：free( p ); p = NULL; // q 为空悬指针，仍指向原处
//碰到这种情况，你一旦再尝试使用q去访问它的目标数据对象的时候程序就崩掉了，q这个指针就空悬了。
```

解决方案：

```c
确保程序中只有惟一一个指针拥有目标数据对象，即只有它负责目标数
据对象的存储管理，其它指针只可访问，不可管理；
若目标数据对象仍有存在价值，但该指针不再有效，此时应进行所有权移交；
在一个函数中，确保最多只有一个指针拥有目标数据对象，其它指针即
使存在，也仅能访问，不可管理；
如果可能，在分配目标数据对象动态内存的函数中释放内存，如 main 
函数分配的内存在 main 函数中释放（在哪一个函数内部分配的这段动态内存，那么就在哪个函数内部销毁它），//如果做不到这一点，那么就应该把这一段分配出来的内存把它的所有权转移给我们主调函数中对应的指针,如果在主调函数里仍然不能够销毁它，那么这个所有权还必须进一步地向主调函数的主调函数转移，一直转移到main函数，如果main函数还不销毁它，main函数结束的时候操作系统会全部销毁它。
退一步，如果上述条件不满足，在分配目标数据对象动态内存的函数的
主调函数中释放内存，即将所有权移交给上级函数

//这个所有权移交的过程，是要由内部最底层的函数一层一层地向它的主调函数上去移交的，所以用8个字总结：级级上报，层层审批
```

如果你不销毁，就应该做到8字总结，做不到这条，那么这个指针就会出问题，很重要的一个地方就是内存泄漏。

#### 内存泄漏与垃圾回收

你弄了一个函数，分配了一个动态内存区域，然后函数结束了，那个指针死了，动态内存分配区域呢你忘了销毁，没有任何一个指针指向它了，它那个区域又没有名字，那么它就会变成一个无主之物。无主之物的结果就是出了一个垃圾，对于内存来讲，就变成了内存泄漏，那片内存区域，操作系统已经分配给你了，你的程序本来可以用的，但是你没有任何一个机制可以访问它了，指针没了嘛，所以那个地方明明给了你，但是你不能用，就相当于内存那个地方被挖了一个洞一样。

```c
示例：
void f(){ int * p = new int; *p = 10; }
函数 f 结束后，p 不再存在，*p 所在的存储空间仍在，10 仍在，但没
有任何指针对象拥有它，故不可访问
//问题的实质：动态分配的内存必须动态释放，函数本身并不负责管理它
```

**垃圾回收机制：系统负责管理，程序员不需要主动释放动态分配的内存，Java有此功能，C 语言无**，C++也无。你可以自己写，但是效率可能不高。

垃圾回收机制有个巨大问题是：**垃圾回收机制在需要时效率很差，而不需要时效率很好**

### 6.引用

**和指针不一样**

#### 引用的定义

定义格式：数据类型& 变量名称 = 被引用变量名称；
示例：int a; int & ref = a;

> 定义引用的表示方法与定义指针相似，只是用&代替了*。引用（reference）是c++对c语言的重要扩充；
>
> 引用说明：
> 　　（1）&在此不是求地址运算，**而是起标识作用**。
> 　　（2）类型标识符是指目标变量的类型。
> 　　（3）**声明引用时，必须同时对其进行初始化**。
> 　　（4）引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。
>
> 学习的《面向对象的嵌入式软件开发》一书中做出了如下解释：
> 引用和const修饰的变量很相似。实际上，C++编译器在编译的过程中**使用常指针作为引用的内部实现**，即指向位置不可变的指针。因此引用所占用的空间大小与指针相同。从我们使用的角度看，引用会让我们误会它只是一个别名，没有自己的存储空间。这是C++为了使用性而做出的细节隐藏。

引用的性质：

引用类型的变量不占用单独的存储空间
为另一数据对象起个**别名，与该对象同享存储空间**

特殊说明
引用类型的变量**必须在定义时初始化**，除非引用类型的量作为函数参数；
此关联关系在引用类型变量的整个存续期都保持不变
对引用类型变量的操作就是对被引用变量的操作

> **引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起**；
>
> **初始化常量引用时允许用任意表达式作为初始值**

**引用的最大意义：作为函数参数**

前面我们谈到“&”和“*”是可逆的，那是指针，这里是引用，不可逆。

```c++
函数原型示例：void Swap( int & x, int & y );
函数实现示例：
void Swap( int & x, int & y ){
int t; t = x; x = y; y = t; return;
}
函数调用示例：
int main(){
int a = 10, b = 20; Swap( a, b ); return 0;
}
//在Swap函数内部，x就是main函数里面变量a的别名
//它最大的好处就是将主调函数中的两个量a、b把它们引入到Swap这个函数的名空间，换了一个名字访问它。可以直接修改我们的实际参数的值，而不是像指针那样修改指针所指向的目标对象的值
```

#### 引用作为函数返回值

常量引用：仅能引用常量，不能通过引用改变目标对象值；引用本身也不能改变引用对象(**也即自己不能变，也不能通过引用改变被引用对象**)

> **常量引用的定义方式：int b;const int &a =b;或者int b;int const &a=b;** 
>
> 对引用来说，引用的类型必须和其引用对象的类型必须一致，**但常量引用只要求其返回的结果能转换成引用的类型**。
>
> 常量引用只有2种情况会**绑定到实际的对象**:一是常量引用的初始值为const对象,且该对象类型与常量引用类型相同(如const int i ; const int &r = i;);二是常量引用的初始值为非const对象,且该对象也与常量引用类型(除去const的类型)相同(如int i; const int &r = i;)

引用作为函数返回值时不生成副本

```c
函数原型示例：int & Inc( int & dest, const int & alpha );
函数实现示例：
int & Inc( int & dest, const int & alpha ){
dest += alpha; return dest; }
函数调用示例：引用类型返回值可以递增
int main(){
int a = 10, b = 20, c; Inc( a, b ); c = Inc(a, b)++; return 0;
}
```

其重要性不仅仅于此，当我们想重载输出操作符的时候，你就能看到引用为什么那么重要，没有引用，新的面向对象的那种架构是非常非常难以实现的，

补充知识：形参中使用常量引用，常量，普通引用的区别

```c++
C++中的引用，给我们提供了一种区别于C指针的形参定义方式。一般我们可以将其定义为

1）普通引用

void foo(int &n);

2）常量

void foo(const int n);

3）常量引用

void foo(const int& n);

//三种方法用途不一样，都可以通过编译。
```

以普通引用为形参的函数，一般会更改实参的值，比如increment(int &n)等；**以常量以及常量引用为形参的函数，一般不对实参进行修改**。需要注意的是，当函数的功能确定后，不能把常量引用和普通引用混淆，虽然编译可以通过，运行也没有错误，但是会对函数的安全性以及功能造成影响：

1）如果一个本该是常量引用的形参定义成了普通引用，那么程序员会误认为这个形参可以修改。而且，在调用该函数的时候，会产生意想不到的错误。比如：

```c++
int getSize1(string &str){
    return str.size();
}
int getSize2(const string &str){
    return str.size();
}
void main(){
    getSize1("helloworld");//报错，普通引用应与某个对象绑定在一起，不能是字面量
    getSize2("helloworld");//正确
}
//显然，getSize2才是符合正常函数思维的实现。
```

2）常量引用为形参时，形参指向实参的空间，而常量为形参时，编译器会给形参重新分配空间。

```c++
void foo1(const int n){
    printf("%x\n", &n);
}
 
void foo2(const int &n){
    printf("%x\n", &n);
}
int main(int argc, char *argv[]){
    int n = 1;
    printf("%x\n", &n);
    foo1(n);
    foo2(n);
    return 0;
}
 
//输出：
//e25f58cc
//e25f58ac
//e25f58cc
```

## 八.链表与程序抽象

### 1.数据抽象

1）数据抽象的目的与意义

程序中的数据对象在C++里面有四个主要特征：VANT（值、地址、名称、类型），在真实的程序中最终只会留下两个---地址和值。N、T在程序运行的过程中就消失了。那么它就对我们的程序带来一个巨大的问题，就是我们真实编程的时候所希望所表达的那些信息或意义，有一些东西就没了。这个东西我们称为信息缺失。

解决这个问题的主要手段就是**抽象**

数据抽象最重要的地方就是：第一，怎么表示我们的数据，前面讲过，我们要用注释、**有意义的数据对象名称**来表示数据；第二、在我们的程序代码中应该在算法的关键处，对于特殊的数据结构的使用、对于特殊类型的使用要给出注释。这些都能够让我们**在源代码级别保持数据对象的意义**，这是一个非常重要的地方。

虽说这样的保持在编译成可执行文件以后它这个信息就没了，但是在源代码级别它能够让我们保持数据的意义。

2）结构化数据类型的性质

类型

​	细节由用户自定义，语言只给我们提供技术手段

成员

​	结构化数据类型的子数据对象

成员类型

​	每个成员具有确切的类型

成员数目

​	部分结构化数据类型可变，部分固定

成员组织

​	成员组织结构（线性结构或非线性结构）必须是显示定义

操作集

​	每个结构化的数据类型都会有一个可以和它相适应的操作集

3）数据封装

数据封装：将数据结构的细节隐藏起来

实现方式：分别实现访问数据成员的存取函数

数据封装示例：

```c++
struct DYNINTS{
 unsigned int capacity;
 unsigned int count;
 int * items;
 bool modified;
};
//动态数组
//平常访问count时使用.操作符，但是如果把count改为num_of_element，那整个程序需要很多修改，特别是如果给别人使用了你的库，他们的程序也需要大量的修改
//这是一个非常不好的设计方式，那么我们就想一个办法，就是提供一个函数，我为你实现一个函数的接口DiGetCount，用这样的函数来获取动态数组的元素个数
unsigned int DiGetCount( DYNINTS* a )
{
 if( !a ){ cout << "DiGetCount: Parameter illegal." << endl; exit(1); }
 return a->count;
}
```

我们希望通过一个技术手段，能够将整个程序分解成很多个库，并且这些库的修订、升级、改变这样的操作只要在接口不变的情况下不影响其它的库或者库的使用者，数据封装就是一个最重要的概念。

你不把细节藏起来，就没法保证这个库和其它的库是隔离的。我们怎么实现这样的数据封装呢？就是要对结构体里面的数据成员提供相应的存取函数。

4）信息隐藏

**数据封装的问题**

你如果只有数据封装这个是不够的，我们假设实现那个结构体，你也提供一系列的存取函数，把数据已经封装起来了，这实际上是暗示这个库的使用者，就是如果你想访问结构体里面的成员，你该使用相应的存取函数而不是直接访问成员的名字。这样的话数据才能封装起来。但是只有这些是不够的，因为struct这个结构体类型，它是设计并没有限定用户不能访问它的数据成员，虽然有了接口函数，可是你不能限制不使用这个函数而直接访问那个count成员，也就是说，对库的使用者来讲，他可以在DiGetCount函数的调用和直接访问那个count字段之间自由地切换，你没有办法限定他只能使用存取函数。

所以问题就是：只要将结构体类型定义在头文件中，库的使用者就可以看到该定义，并按照成员格式直接访问，而不调用存取函数

**解决方法**

将结构体类型的**具体细节定义在源文件中**，所有针对该类型量的操作都只能通过函数接口来进行，从而隐藏实现细节。

数据封装和信息隐藏合在一起才是我们编写抽象程序的关键，这是最重要的两个核心概念：数据封装、信息隐藏。

信息隐藏示例

```c++
/* 头文件“dynarray.h”*/
struct DYNINTS; typedef struct DYNINTS * PDYNINTS;
//要保证调用者能够正确使用这个结构体，那么就会在头文件里给出这个结构体的声明，并且提供一个指向这个结构体的指针，我们保证只使用这个指针来操纵它的目标结构体的数据对象。
/* 源文件“dynarray.cpp”*/
struct DYNINTS{
 unsigned int capacity; unsigned int count; int * items; bool modified;
};
```

5）抽象数据类型

```c++
设计能够存储二维平面上点的抽象数据类型
/* 点库接口“point.h”*/
struct POINT;
typedef struct POINT * PPOINT;
//注意：因为我们的目标结构体的定义是未知的，那么实际上这样的PPOINT型虽然可以在函数原型里面使用，但是我们实际上不能使用它的目标结构体的任何内部信息
PPOINT PtCreate( int x, int y );//返回值为struct POINT类型的指针，
void PtDestroy( PPOINT point );
void PtGetValue( POINT point, int * x, int * y );
void PtSetValue( PPOINT point, int x, int y );
bool PtCompare( PPOINT point1, PPOINT point2 );
char * PtTransformIntoString( PPOINT point );
void PtPrint( PPOINT point );
```

```c++
/* 点库实现“point.cpp”*/
#include <cstdio>
#include <cstring>
#include <iostream>
#include "point.h"
using namespace std;
static char* DuplicateString( const char* s );
struct POINT{ int x, y; };
PPOINT PtCreate( int x, int y )
{
 PPOINT t = new POINT; t->x = x; t->y = y; return t;
}
void PtDestroy( PPOINT point )
{
 if( point ){ delete point; }
}
```

```c++
void PtGetValue( PPOINT point, int * x, int * y )
{
 if( point ){ if( x ) *x = point->x; if( y ) *y = point->y; }
}
void PtSetValue( PPOINT point, int x, int y )
{
 if( point ){ point->x = x; point->y = y; }
}
bool PtCompare( PPOINT point1, PPOINT point2 )
{
 if( !point1 || !point2 ){ cout << "PtCompare: Parameter(s) illegal." << endl; exit(1); }
 return ( point1->x == point2->x ) && ( point1->y == point2->y );
}
void PtPrint( PPOINT point )
{
 if( point ) printf( "(%d,%d)", point->x, point->y );
 else printf( "NULL" );
}
```

```c++
char * PtTransformIntoString( PPOINT point )
{
 char buf[BUFSIZ];
 if( point ){
 sprintf( buf, "(%d,%d)", point->x, point->y );
 return DuplicateString( buf );
 }
 else return "NULL";
}
char* DuplicateString( const char* s )
{
 unsigned int n = strlen(s);
 char* t = new char[n+1];
 for( int i=0; i<n; i++)
 t[i] = s[i];
 t[n] = '\0';
 return t;
}
```



### 2.链表

#### 基础概念

链表的意义与性质：

存储顺序访问的数据对象集
数据对象占用的存储空间总是**动态分配**的

链表的定义：

元素序列，每个元素与前后元素相链接

结点：链表中的元素，一个NODE包括两个字段（两个域），一个叫数据域一个叫链接域，我们用data和next来表达；

实际上你在设计这个链表的过程中，你的data字段是有可能很多个域，你的数据可能很复杂，在这样的一个链表中为了维持数据之间的关系，需要一个表头结点和一个表尾结点，用head和tail表示，**head和tail分别指向头尾结点，没有data字段**；

表头、表尾：链表的头尾结点；
头指针、尾指针：指向表头、表尾的指针。

那么这样的链表数据结构，正常情况下面，如果想要符合数据封装和信息隐藏的基本要求的话，那么我们就需要通过这样的两个域--data域和next域来分别描述它的数据字段和链接字段。

假设定义的这个链表是用来表达前面的点结构体的，所以在这样的链表中，每一个结点都包含两部分

```c++
struct NODE; 
typedef struct NODE * PNODE;
struct NODE{
	PPOINT data; /* 当前结点的存储数据 */
	PNODE next; /* 指向下一结点，表尾此域为 NULL */
};
//注意在这个结构体类型的定义中，它里面有一个成员为指向结构体的指针，这是允许的，你如果让它的next字段为struct NODE类型的成员，那么这样的定义就涉及到了结构体的递归定义，这是不允许的。因为它没有办法决定这个结构体的存储空间的大小，而如果是指向本结构体的一个指针，这就是合法的，因为每一个指针存储空间的大小都是固定的，不管它是指向别人还是指向它自身。所以它不影响struct NODE结构体的内存的分配和管理，所以就可以用指向本结构体的指针作为结构体的某一个特定成员类型。
```

**仅有这个链表结点数据结构是不够的**，还要为它定义整个链表的结构来管理所有的结点。

```c
链表结构：封装结点表示的细节
struct LIST; 
typedef struct LIST * PLIST; // 一个指向链表的一个指针PLIST
struct LIST{
	unsigned int count; /* 链表中包含的结点数目 */
	PNODE head, tail; /* 链表头尾指针 */
    //PNODE为指向NODE的指针类型，head和tail就为指向NODE的指针变量
};
```

特别说明：

结点总是动态分配内存的，所以结点逻辑上连续，物理上地址空间并
不一定连续；（因为没有办法规定malloc，没有办法规定new它们分配出来的存储空间一定是连续的）

时刻注意维护链表的完整性：一旦头指针 head 失去链表表头地址，
整个链表就会丢失；任一结点 next 域失去下一结点地址，后续结点
就会全部丢失；

单向链表、双向链表、循环链表、双向循环链表

单向链表的next域一般都设为NULL。

如果这个链表的最后一个结点（就是尾结点）不是NULL值，不是空值，而是指向这个链表的表头，就构成了一圈，就像我们自行车链条一样，这个就称它为循环链表。

#### 抽象链表接口

现在就使用数据封装与信息隐藏的技术手段来设计抽象的链表库

```c++
编写函数，实现链表的构造与销毁操作
PLIST LlCreate()
{
 PLIST p = new LIST;
 p->count = 0;
 p->head = NULL;
 p->tail = NULL;
 return p;
}
void LlDestroy( PLIST list )
{
 if( list )
 {
 LlClear( list );
 delete list;
 } }
//参数list实际上是一个指向struct LIST的指针，我们要销毁的就是那个struct LIST，目标数据对象；而这个目标数据对象有head指针和tail指针，尤其是head指针，它指向我们链表表头结点，而我们的链表结点都是struct NODE这样一个数据对象，而这样的数据对象又总是动态内存分配出来的，所以在我们销毁list所指向的链表目标数据对象之前，必须保证这个链表中所有的结点都已经被我们销毁了，如果你没有销毁链表中的全部结点，你就销毁了这个list所指向的struct LIST那个目标结构体，那么这个链表中全部结点都会丢掉，
```

```c++
void LlClear( PLIST list )
{
 if( !list )
 {
 cout << "LlClear: Parameter illegal." << endl;
 exit(1);
 }
 while( list->head )
 {
 PNODE t = list->head;
 list->head = t->next;
 PtDestroy( t->data );
 delete t;
 list->count--;
 }
 list->tail = NULL;
}
//data字段保存的是点的抽象数据，实际上保存的是指向POINT那个二维点的指针，所以在你销毁t所指向的表头结点之前必须调用PtDestroy(t -> data)，销毁这个data字段所指向的那个二维点的目标数据对象
```

链表头文件要包含“point.n”，list.cpp也要包含它，因为要使用PtDestroy来销毁t->data所指向的目标二维点。

**表头结点的删除**

表头结点从链表中抠出来，我们有临时指针t指向它，倒不担心内存泄漏，但是链表本身这个结点已经不存在了。

最后要递减链表的结点数目。

#### 结点的追加

操作步骤：

①动态构造一个新结点，用 t 指向它；

②使 t 的 data 域指向 point 参数指向的目标数据对象，next 域为NULL；

③如果链表的 head 域为 NULL，则说明当前链表中没有任何结点，将此结点作为链表惟一结点添加到链表中，此时简单将链表的 head 域与 tail 域设为 t 即可；

④否则，将当前尾结点的 next 域设为 t，即让其指向新结点；

⑤将链表的 tail 域设为 t，即将新结点作为链表尾结点；

⑥递增链表结点数目。

#### 结点的插入

表头插入的操作步骤：

①动态构造一个新结点，用 t 指向它；

②使 t 的 data 域指向 point 指向的目标数据对象，next 域为NULL；

③将 t 的 next 域设为 list 的 head 的值，即使得原链表首结点链接到 t 所指向的结点之后；

④修改链表首结点指针，使其指向新结点；

⑤递增链表的结点数目。

**③④的顺序不能变**，不然不是插入，而是替换了链表，新链表只有插入的这一个元素，原来的结点都丢了。

**注意**：不管是追加还是插入，在任何时候都要维持链表的链接关系不变

表中插入的操作步骤：

动态构造一个新结点，用 t 指向它；

使 t 的 data 域指向 point 指向的目标数据对象，next 域为 NULL；

从表头开始向后查找待插入位置的前一结点，用 u 指向它，例如若插入位置为 1，则用 u 指向 0 号结点；

将 t 的 next 域设为 u 的 next 的值，即使得原链表中位置 pos 处的结点链接到 t 所指向的结点之后；

将 u 的 next 域设为 t，**即将 t 指向的结点链接到 u 指向的结点之后**(后面）；

递增链表的结点数目

代码：

```c++
void LlInsert( PLIST list, PPOINT point, unsigned int pos ) {
 if( !list || !point )
 {
 cout << "LlInsert: Parameter illegal." << endl;
 exit(1);
 }
 if( pos < list->count )
 {
 PNODE t = new NODE;
 t->data = point;
 t->next = NULL;
 if( pos == 0 )
 {
 t->next = list->head;
 list->head = t;
 }
 else
 {
 unsigned int i;
 PNODE u = list->head;//存放头结点的地址，即指向头结点，0号结点，头指针
 for( i = 0; i < pos - 1; ++i )
 	u = u->next; 
    //下一个结点赋值给u，直到u指向pos-1
    //pos为1时u还是指向头结点，0号结点
 t->next = u->next;//t的next域指向2号结点
 u->next = t;//1号结点的next域赋值为t，
 }
 list->count++;
 }
 else //pos=list->count
 	LlAppend( list, point );
 
}
```

#### 结点的删除

表中或表尾删除的操作步骤：

使用临时指针 u 保存待删除结点前一结点的地址；

t 保存待删除结点的地址；

将 t 的 next 域赋给 u 的 next 域，这保证 u 跳过 t 指向下一结点；

如果t 的 next 域不再指向其他结点（t 指向的结点本身就是链表尾结点）则将链表尾结点设为 u；

释放 t 的 data 域所指向的目标数据对象；

释放 t 所指向的结点数据对象；

递减链表的结点个数。

```c++
void LlDelete( PLIST list, unsigned int pos ) {
 if( !list )
 {
 cout << "LlDelete: Parameter illegal." << endl;
 exit(1);
 }
 if( list->count == 0 )
 return;
 if( pos == 0 )
 {
 	PNODE t = list->head;
 	list->head = t->next;
     if( !t->next )
     	list->tail = NULL;
     PtDestroy( t->data );
     delete t;
     list->count--;
 }
 else if( pos < list->count )
 {
     unsigned int i;
     PNODE u = list->head, t;
     for( i = 0; i < pos - 1; ++i )
         u = u->next;
         t = u->next;
         u->next = t->next;
     if( !t->next )
     	list->tail = u;
     PtDestroy( t->data );
     delete t;
     list->count--;
 } }
    
```

#### 链表的遍历

#### 链表的查找

#### 上述链表设计中存在的问题

链表要存储点数据结构，就必须了解点库的接口；

这个抽象链表库，不能保存其他数据对象，只能保存二维点，如果你想保存其它东西，比如三维点，比如一个复数，那么你必须重新写一个抽象链表库，也就是说，像这样一个链表，它事实上是不抽象的。

如果你要想存储目前还没有实现的数据结构，那怎么办呢？那更糟了，这个头文件你包含不了，你压根就没有办法做，所以还是刚才那句话，现在实现的抽象链表实际上不是抽象的。从某种程度上来讲，像这样一个链表实际上是用来存储其它数据对象的，我们习惯上称它为一个容器，一个container，一个容器理论上应该是抽象的。

### 3.函数指针

在讨论如何编写更抽象的链表库之前，我们还需要补充一个知识点：函数指针。

函数指针的目的与意义：抽象数据与抽象代码

​	---数据与算法的对立统一

数据结构和算法从某种程度上来讲，是一个辩证统一的，他们既对立又统一，有了函数指针这个概念之后，数据和算法就能统一起来。如果没有它，它们就是对立的，有了它，两者就可以统一起来。

为什么能够做到这一点呢？最主要的一点，我们来看执行一个函数，我们怎么执行它，我们需要知道这个函数的入口地址，对于我们计算机系统结构来讲，只要知道这个函数的入口地址，实际上就知道这个函数第一条指令该怎么去做，只要知道它第一条指令怎么去做，那么这个函数就能够做下去，第一条做完第二条、第三条...如果有跳转，就跳转到指令的指令，当所有的指令都做完，它有个return语句，它能够返回给它的主调函数，这是很明确的执行流程，这也就是说，对于一个函数的执行过程来讲，函数的入口地址是个关键的地方，入口地址那也是地址啊，它和我们数据的地址有差别么？没差别！它放在我们计算机的内存条里，不管是数据还是代码，那个编号是统一编址的，所以说数据的地址也好，算法和函数的地址也好，对于我们计算机系统结构来讲，两者是无差别的，这就暗示着我们能不能够将一个函数的入口地址也保存起来呢？当然可以，这个就是函数指针，指向一个函数的指针。

```c++
函数的地址：函数入口位置，将该数值作为数据保存起来，就可以通过特殊
手段调用该函数
typedef void * ADT; 
typedef const void * CADT;
//对于一个指针来讲，不管它指向哪一种类型，指针的数据地址它实际上存储空间是固定的，所以事实上它可以表达指向任意类型对象的数据的这样一个概念，它既然可以表达任意对象的地址，就可以代表着任意类型的对象。到了这里，我们就很明确了，哑型指针它将充当我们抽象数据类型的概念。
```

当我们想把前面的抽象的链表和它所存储点的数据结构完全给割裂开的时候，那么就必须保证抽象的链表数据结构里面不能有对抽象的点库的任意函数的调用，也不能使用点库中定义的任意的类型，这样才能让他们完全的独立开，那么我们怎么指代抽象链表里节点里面的data字段？哑型指针，前面的代码用的是point * ，现在把它替换成void * 。这就意味着我们的抽象链表中将不再保存指向一个点的结构体的一个指针，而是指向一个哑型的指针。

特别注意，ADT作为一个指向void类型的一个指针，并不意味着它的目标数据对象是一个“无”的类型的一个概念，它仅仅意味着我们的目标数据对象类型是未知的，我不知道它的具体类型是什么。我们只知道有一个指针指向一个目标数据对象。**这样就完成了一个通用性的编程**。这就是抽象数据类型的根本意义之所在。

```c++
函数指针的定义格式
数据类型 ( * 函数指针数据对象名称 )( 形式参数列表 );
示例：
char * ( * as_string )( ADT object );
函数指针变量的赋值
// 这个变量的类型很特殊，它指向一个函数，那个函数有一个ADT 类型参数返回值是 char * ，凡是这样的函数它都能指向。这就意味着凡是具有这样特征的函数都可以把它的入口地址赋值给as_string 作为它的值！
    
// 函数指针变量可以像普通变量一样赋值;可以被赋值，可以赋值给别人
函数指针数据对象名称 = 函数名称;
char * DoTransformObjectIntoString( ADT object )
{ return PtTransformIntoString( (PPOINT)object ); }
as_string = DoTransformObjectIntoString;
```

#### 函数指针的使用

**通过函数指针调用函数**

函数指针被赋值后，即指向实际函数的入口地址；
通过函数指针可以直接调用它所指向的函数（通过引领操作符，引领完它就是那个目标函数了）。

```c++
调用示例：
 char * returned_value;
 PPOINT pt = PtCreate( 10, 20 );
 as_string = DoTransformObjectIntoString;
//把这个函数入口地址赋值给as_string之后，就可以像普通的函数一样调用as_string，你就可以认为as_string就是那个对应的实际函数

returned_value = as_string( (ADT)pt );//第一个小括号表示函数调用
//因为as_string需要带的是ADT类型的参数，而不是PPOINT类型的参数，而我们实际上是PPOINT类型的对象，要传进去，所以要把它转换成ADT，在它的内部，DoTransformObjectIntoString这个函数内部还要把pt从ADT类型再重新转换成PPOINT，然后才能去操作，中间这两步转换其实都是必要的。
要区分函数指针调用和函数直接调用，使用下述格式调用函数指针指向的函数：
 returned_value = ( *as_string )( (ADT)pt );
//严格来讲，as_string实际上是一个指针，你要想访问他的目标数据对象或者它的目标函数，需要使用引领操作符，其实标准格式就应该这么写： *as_string引领它的目标数据对象，这是一个函数，然后调用函数；
//第一个小括号对必不可少，如果没有这个小括号对，那就相当于as_string就是一个函数，然后调用，因为它是一个函数指针，那么你还可以调用，没问题，as_string就调用这个函数指针变量所指向的那个目标函数DoTransformObjectIntoString，然后去做点的转换，转换完以后它会返回一个字符串指针，前面用“*”去引领，返回那个目标字符串，实际上得到返回的目标字符串的0号字符，然后你想赋值给returned_value就出现赋值不兼容，把字符赋值给一个字符串，编译器就报错！
```

#### 实例

```c++
设计程序，随机生成 8 个 10~99 之间的整数，调用 stdlib 库的
qsort 函数对其进行排序
    
qsort 函数原型
void qsort( void * base, unsigned int number_of_elements,
 unsigned int size_of_elements,
 int ( * compare )( const void *, const void * ) ); 
// 第一个参数表示我们需要排序的数组的基地址；
//第二个参数表示数组的元素个数；
//第三个参数表示数组中每个元素所占的存储空间的大小，以字节为单位；
//第四个参数就是一个函数指针，它用于比较两个数据对象的大小关系。
//这个原型实际上是非常复杂的，但是三行就写完了，因为这里使用了一个函数指针变量来作为函数的形式参数，这个是非常非常常见的一个编程设计技巧。一定要会用！

调用时需按照下述格式实现自己的比较函数
 int ( * compare )( const void *, const void * );
//e1、e2可以省略，什么意思呢？我们将比较两个数据对象的大小关系，而这两个数据对象我们将作为函数的参数传给compare，也就是说compare在比较两个数据对象大小关系的时候，这两个数据对象本身对它而言是已知的，我们实际上并没有传递那两个数据对象，而是传递指向那两个数据对象的指针，因为我们不允许你在compare这个函数里面通过指针修改目标数据对象的值，所以这两个指针所指向的目标数据对象都定义成了const void 而不是 void。

当你想使用qsort函数的时候，你必须定义一个自己的比较函数，这个比较函数还必须按照如下格式来。你必须按照像这样的一个格式来定义compare所指向的那个目标比较函数。
比较函数示例
int MyCompareFunc( const void * e1, const void * e2 );

比较函数必须返回正负值（一般为正负 1）或 0 ，规则按照题目要求自定义
```

补充：qsort什么时候实现的呢？已经很有一些年头了，在C标准库出来的时候它就有了，那个时候实现这个qsort的那个程序员他知道你用它来对什么类型的数组进行排序吗？他当然不知道，也许是个整数数组也许是个浮点数组也许是个结构体数组（**数组的每个元素都是一个结构体**），如果是结构体数组，那显然是你定义的结构体，这个结构体是什么样子，他几十年前怎么能够知道呢，他是不可能知道的。他不知道你未来才会实现的结构体，那么他哪里能够进行大小排序呢。当他实现qsor函数的时候，当他需要对未来才会实现的一个数组进行排序的时候他显然没有办法决定这两个元素之间的大小，在他不能够决定这两个元素大小关系的情况下面，他又想实现qsort函数，那么他只好把这部分悬而未决的东西留待实现数据结构的程序员来去做，因为这个函数你没实现你就不能直接调用它，**那么就只能通过函数指针来调用它**。这个就是函数指针最重要的应用场合。就是**作为另外一个函数的形式参数**。

```c++
#include <iostream>
#include <cstdlib>
using namespace std;
#include "arrmanip.h"
#define NUMBER_OF_ELEMENTS 8
int DoCompareObject( const void * e1, const void * e2 );
int main()
{
 int a[NUMBER_OF_ELEMENTS];
 GenerateIntegers( a, NUMBER_OF_ELEMENTS );
 cout << "Array generated at random as follows: \n";
 PrintIntegers( a, NUMBER_OF_ELEMENTS );
 qsort( a, NUMBER_OF_ELEMENTS, sizeof(int), DoCompareObject );
 cout << "After sorted: \n";
 PrintIntegers( a, NUMBER_OF_ELEMENTS );
 return 0;
}
int DoCompareObject( const void * e1, const void * e2 )
{
 return CompareInteger( *(const int *)e1, *(const int *)e2 );
 // 我们必须把e1和e2转换成const int * 之后，才能去引领；你不能先引领后转换，你先引领 * e1，它实际上表示什么呢，表示const void，然后你想把它转换成const int ，这事不能做，因为void类型和const void类型的量它不能参与实际的操作，你想访问它这事非法的，类型未知。
}
```

函数指针的赋值

同类型函数指针可以赋值，不同类型则不能赋值（即指针可以赋值给指针）
如何确定函数指针类型是否相同：函数参数与返回值不完全相同

函数指针类型：用于区分不同类型的函数指针
typedef int ( * COMPARE_OBJECT )( const void * e1, const void * e2 );

前面添加 typedef 关键字，保证 COMPARE_OBJECT 为函数指针**类型**（表示类型的时候我们全部大写），而不是函数指针**变量**

可以像普通类型一样使用函数指针类型定义变量：

```c++
COMPARE_OBJECT compare = DoCompareObject;
qsort 函数的简明书写方法
void qsort( void * base, unsigned int number_of_elements, unsigned int
size_of_elements, COMPARE_OBJECT compare );
```

### 4.抽象链表

qsort函数里它有一个函数指针类型的形式参数，那个函数指针指向的那个函数我们就称它为回调函数。

#### 回调函数

允许通过函数指针调用未来才会实现的代码，这个就叫回调函数；

示例：DoCompareObject

凡是回调函数它都会需要依赖后续的设计，否则你不知道它调用哪一个。你传哪个函数的入口地址给它，它就调用哪一个对吧。而这个函数本身还是你未来才会实现的，就相对于qsort那个函数的设计和编写的那个实现而言，DoCompareObject这个函数实现是远远在它未来之后，所以对qsort来说它会调用你未来才会实现的DoCompareObject替你排序未来才会实现的数组，qsort本身只能完成排序的基本动作，它不知道你的数组是什么样子，它只知道你的数组的入口地址在哪里，你的数组里包含多少个元素，你的数组每个元素的尺寸是多少，所有这些还是你在调用qsort的时候告诉它的，其次它也不知道怎么比较元素的关系，怎么比较也是你告诉它的。你写一个比较函数，把这个函数的入口地址给它，它就调用你的函数，替你比较你的数据，**这是非常重要的一个设计**。回调函数的作用就体现在这里！

**回调函数参数**

有的时候我们需要在回调函数和主调函数之间产生一个很特殊的信息的交互，这种东西我们称它为附加的信息，那传多少个呢？

我们有一个通用型的数据抽象类型，void * ，ADT嘛，就用它来表达这个附加的参数，如果传的附加信息是一个，我们就直接传这个附加信息或这个附加信息的地址，如果这个附加信息和void * 尺寸刚好一样，你就不用传它的地址了，直接传它就可以了。附加信息如果是一个，很典型，我用一个ADT代替它，如果附加信息是两个或者多个呢，就把附加信息做成一个结构体，然后传那个结构体的地址，转换成ADT。所以一个ADT事实上就可以传递所有的东西。

如果我们使用这个链表来保存的是一些整数，实际上是可以把这个int直接转换成void * （在32位系统和编译器下两者尺寸一致）就存在data字段里，这个时候我们的data字段它并不指向任意的有意义的存储区，它其实原始意义就是一个整数，结果被我们当成void * 存在data字段里面了，所以在这种时候，如果我需要销毁这个链表的结点，那么data字段是不需要去管理它的，也就是说这个时候你是不可以销毁data字段所指向的那个目标数据区域的，那个并不是我们真正内存分配出来的存储区域，所以当我们设计抽象链表的时候就需要考虑到这一点。

**数据对象的存储与删除**

删除链表结点时，其中的目标数据对象是否需要删除？

**如果链表结点存储的是指针，就需要删除；否则不需要**

**设计抽象链表时，并不了解结点实际存储的数据是否为指针，因而无法确定结点数据操作逻辑**。这点特别需要注意。

#### 实例

当我遍历链表的时候我只知道我要做一件事，但是这件事情具体做什么，其实我不清楚，至少我在实现这个函数的时候还不清楚，也就是说有些信息在我实现这个函数的时候是未知的，怎么办呢？凡是未知的东西都应该用量来代替，就像我们使用量来代替一个具体的数一样，你不知道那个数是什么，没关系，我们操纵的是这个量，你不知道操作是什么，没关系，我们使用一个函数指针，就这个意思。

所以我们使用一个回调函数来提供这个结点数据的具体的操作方法。

```c++
编写函数，遍历链表，结点数据的具体操作方法目前未知，由未
来的回调函数提供
typedef void ( * MANIPULATE_OBJECT )( ADT e );
void LlTraverse( PLIST list, MANIPULATE_OBJECT manipulate )
// 注意：平时我们用参数的名字，不管形式参数还是实际参数的名字还是变量的名字，我们平时都使用名词对吧，这个bool量偶尔会使用形容词，在这里，我们使用的是动词，因为它是函数指针类型的变量。所以它往往代表一个动作，所以我们使用一个动词，这是可以的。
{
 PNODE t = list->head;
 if( !list )
 {
 cout << "LlTraverse: Parameter illegal." << endl;
 exit(1);
 }
 while( t )
 {
 if( manipulate ) /* 通过函数指针调用实际函数操纵目标数据对象 */
 ( *manipulate )( t->data ); 
 t = t->next;
 } }

// 因为我在LlTranverse这个函数里提供了一个回调函数，这实际上就意味着我们这个LlTranverse可以在遍历的时候执行你想要它做的操作，你想要它打印，你就写一个打印函数作为实际参数传给LlTranverse，让manipulate指向这个打印函数，它就会打印；如果你想求和，那么你写一个求和的函数传给manipulate。
//按照这样的程序设计，LlTranverse这个函数它的适用性显然要比之前那个方式要灵活得多，至少在LlTranverse函数内部没有对PtTransformIntoString函数的调用，这就意味着对LlTranverse来讲，它不需要知道PPOINT、点库的任何细节，管你是点库还是什么库，尤其是注意到，一旦形成一个抽象的链表库的话，那么我们的data字段它压根就不是PPOINT类型的，它是ADT类型的，完全把它抽象化了，你想用的时候把PPOINT转换成ADT，然后在内部再重新把ADT转换成PPOINT回去，它是按照这样的方式将链表库和点库完全给独立开来的。数据结构，他们互相不使用了，算法，它们互相之间也不使用了。这样不就独立了嘛，点库是点库，抽象链表库是链表库，这样我们的抽象链表库的应用场合也就不再局限于点库了。
```

#### 回调函数参数使用

```c++
typedef void ( * MANIPULATE_OBJECT )( ADT e, ADT tag );
/* 链表遍历函数 */
void LlTraverse( PLIST list, MANIPULATE_OBJECT manipulate, ADT tag )
{
 PNODE t = list->head;
 if( !list )
 { 
 cout << "LlTraverse: Parameter illegal." << endl;
 exit(1);
 }
 while( t )
 {
 if( manipulate )
 ( *manipulate )( t->data, tag ); 
 t = t->next;
 } }
//第三个参数ADT tag，LlTraverse并没有使用而是传给manipulate使用
```



```c++
/* 点数据到字符串的转换函数，最终程序员任意定义 */
/* 参数 format 表示点数据对象的转换格式 */
/* 其中只能包含两个格式码 %d，其他内容任意 */
/* 例如格式“(%d,%d)”或“[%4d, %4d]”等 */
char * PtTransformIntoString( const char * format, PPOINT point )
{
 char buf[BUFSIZ];
 //定义一个buf，缓冲区
 if( point )
 {
 sprintf( buf, format, point->x, point->y );
 //按照它的那个format传进来的格式生成它对应的字符串
 return DuplicateString( buf );
 //然后返回这个字符串
 }
 else
 return "NULL";
}
```

```c++
/* 回调函数 DoPrintObject */
void DoPrintObject( ADT e, ADT tag )
{
 printf( PtTransformIntoString( (const char *)tag, (PPOINT)e ) );
 //ADT转为相应的类型
 printf( " -> " );
}
/* 回调函数参数的意义 */
/* 调用遍历函数时将点数据的输出格式传递给遍历函数 */
/* 再由遍历函数传递给回调 */
LlTraverse( list, DoPrintObject, "(%d,%d)" );

//第三个为回调函数参数
//当你想“（%d，%d）”格式调用它的时候，那么你就按照这个格式(%d,%d)传一个字符串进去，这个就是它的第三个参数，附近参数。
```

---使用抽象的链表库存储我们抽象的点库，注意抽象的链表库是我写的，抽象的点库可能是张三写的，你呢，要使用我和张三写的那段程序代码来实现你的程序，那么当你想按照一个特定格式输出这些点信息的时候，我们就调用LlTraverse这个函数，传递抽象的链表，传递回调函数，传打印的格式。

注意："(%d,%d)"不能写在DoPrintObject里面，写进去那只能做小括号对了，不能做中括号对了[%d,%d]、尖括号对等。

所以可以看到：**用一个附近参数作为回调函数的主调函数和回调函数两者信息交互的一个关键点**。

**回调函数参数的重要意义**

程序的参与者：抽象链表的设计者、点库的设计者、最终使用前两者的第三方程序员。只有使用抽象链表库来存储点的那个程序员他才知道抽象链表库的接口是什么，点库的接口是什么，但是对应抽象链表库的实现是什么，点库的实现是什么，第三个程序员也一样不知道。他不需要知道，反正能用就行了对吧。抽象的目的就体现在这里，我让这些模块尽可能独立，你能用就行了，你压根就不需要知道它内部的实现细节。

所以总结其优势：**三者完全不了解其他人的实现细节**

**容器与容器中的对象**

抽象链表作为一个容器和容器中的一个对象我就把它独立开了、分离开了。

容器：能够容纳其他数据对象集合的东西

**两者完全无关，即容器与容器中容纳的数据对象完全独立，**这个就叫抽象。

**抽象链表事实上可以存储任意类型的数据对象**

#### 数据对象的存储与删除

在编写程序的时候需要特别注意的：

第一，你链表中的那个data域是不是一个指针？

第二，data域是否真正指向存在的目标数据对象？如果不指向怎么办？如果指向怎么办？是否需要指向一个真正存在的目标数据对象？这个目标数据对象是你动态分配的还是你静态分配的。这些都需要你在使用抽象链表库的时候明确的。

第三，如果节点要被删除的话，data域所指向的一个目标数据对象是否需要被删除？链表这节点被删除了，data域所指向的目标数据对象是不是需要删除。就像我们前面讲的，如果我是把一个int直接转换成void * 存在data域里面的，那我这个节点被删除的时候目标数据对象不存在，所以不需要删除。那个data字段它真的指向目标数据对象，当我删除这个节点的时候，那个目标数据对象是不是一定需要删除，虽然在大部分情况下真需要删除，但是并不意味着每次总是这样，并不意味着一定需要删除，**这个地方一定需要注意，编程的时候要非常小心**。

第四，如果需要删除，如何删除？

第五，抽象链表的设计者能不能完成这样的删除任务？如果能，你就删就行了。如果你不能，你怎么办？这点你写程序的时候要时刻注意到。

```c++
typedef void ( * DESTROY_OBJECT )( ADT e );
//销毁目标数据对象的一个函数指针类型，传递一个哑型指针ADT e，用来代表待销毁的那个目标数据对象的地址。
void LlDelete( PLIST list, unsigned int pos, DESTROY_OBJECT destroy )
//使用一个回调函数作为它的函数参数
{
 // ……
 if( pos == 0 )
 {
 // ……
 if( destroy )
 ( *destroy )( t->data );
 // ……
 }
 else if( pos < list->count )
 {
 // ……
 if( destroy )
 ( *destroy )( t->data );
 // ……
 } }
//destroy如果你传的是一个非0值，不是NULL的一个值，那么我们就调用destroy所指向的那个目标销毁函数，销毁它的目标数据对象。如果传了一个NULL，我就不销毁，很明确吧。
```

```c++
若需要删除目标数据对象，实现下述代码
void DoDestroyObject( ADT e )
{
 delete (PPOINT)e;
}
/* 调用 DoDestroyObject 函数释放 data 域指向的存储空间 */
LlDelete( list, 1, DoDestroyObject );

若不需要删除目标数据对象，实现下述代码
LlDelete( list, 1, NULL );
```

最后，我们的抽象链表库该怎么设计？

设计不依赖所存储的具体数据类型的抽象链表

```c
typedef struct LIST * PLIST;
typedef int ( * COMPARE_OBJECT )( CADT e1, CADT e2 );
typedef void ( * DESTROY_OBJECT )( ADT e );
typedef void ( * MANIPULATE_OBJECT )( ADT e, ADT tag );
PLIST LlCreate();
void LlDestroy( PLIST list, DESTROY_OBJECT destroy );
void LlAppend( PLIST list, ADT object );
void LlInsert( PLIST list, ADT object, unsigned int pos );
void LlDelete( PLIST list, unsigned int pos, DESTROY_OBJECT destroy );
void LlClear( PLIST list, DESTROY_OBJECT destroy );
void LlTraverse( PLIST list, MANIPULATE_OBJECT manipulate, ADT tag );
bool LlSearch( PLIST list, ADT object, COMPARE_OBJECT compare );
unsigned int LlGetCount( PLIST list );
bool LlIsEmpty( PLIST list );
```

作业1： **实现动态数组库**（学了操作符重载这个就更简单了）

作业2：**实现抽象链表库**

## 九.类与对象

### 1.程序抽象与面向对象

```c++
抽象数据类型：设计能够存储二维平面上点的抽象数据类型
/* 点库接口“point.h”*/
struct POINT;
typedef struct POINT * PPOINT;
PPOINT PtCreate( int x, int y );
void PtDestroy( PPOINT point );
void PtGetValue( POINT point, int * x, int * y );
void PtSetValue( PPOINT point, int x, int y );
bool PtCompare( PPOINT point1, PPOINT point2 );
char * PtTransformIntoString( PPOINT point );
void PtPrint( PPOINT point );
```

前面设计的程序代码有个小问题，问题在哪里呢？问题就在你只能定义指向这个结构体的指针，你并不能够定义这个结构体类型的变量。因为我们这个结构体的类型是未知的，我们仅仅声明了它，并没有定义它。所以你是不可以使用POINT这个结构体来定义变量的，你只能定义PPOINT类型的变量，也就是指向这个结构体的指针。也就是说，像这样一个库的接口使用其实是受限的。

 **类与对象的概念与意义**

接上面，第二，虽然我们将这个结构体的声明和这个结构体所能够具有的方法也就是它的行为实际上封装在一个抽象的点库里面，属性和行为从我们实现角度来讲，似乎是统一的。但我们其实并没有办法要求程序员对所有的库的结构按照一个特定的方式这样组织和使用，比如，他有可能把那个结构体的定义抽取出来然后放到了头文件里，这样的话他不就可以用了嘛。

我们按照这样一个实现完成了这样一个抽象库的表达，我们将它的属性也就是这个结构体所具有的数据的那些成员信息和在这些信息上边所能够进行的操作把它统一地封装在我们的源文件里，而在我们的接口上面只提供它的型的一个描述---一个简单的描述，而不是内部的实现细节，不是类型的实现细节，只有类型的简单描述，以及可以在这个型上所进行的一种操作。当然这里我们使用的是指向这个结构体的指针。我们希望达到的目标就是：**属性和行为的辩证统一**。每一个库都按照这样一个方法来实现，那我就会说在我们程序中结构体和结构体中所具有的方法，我们这个抽象的数据结构和我们数据结构上可以进行的操作集全部封装成了一个单一的库。可是在结构化的程序设计里面这样的属性和行为统一并不是特别的完美无缺。因为实际上，我们的操作集和我们的抽象数据结构仍然是分裂的，虽然我们表达在了同一个头文件里，这种分裂会导致用户也就是库的使用者在理解整个程序代码的时候出现问题，尤其当你把很多个这样的结构体混杂在一起的时候，很多个这样的抽象数据型封装在一个单一的库的时候，属性和行为上边就有可能在理解这个库的代码的时候会带来额外的负担。

所以说当我们想表达这个数据封装和信息隐藏概念的时候，如果你没有这样的一个类的概念，你就没有办法清晰的定义，这是我们前面特别谈到的。最重要的一个地方就是我们怎么才能够通过一种特殊的机制将这样一个抽象的数据类型的数据封装和信息隐藏很好的利用起来，同时又让它的属性和行为在语言的实现的概念上完成辩证统一，实现这一点就是面向对象技术。

**程序抽象**

－数据封装、信息隐藏

－如果没有类的概念，无法定义非指针量，且控制性不佳

**对象的概念与意义**

－量（对象首先要表达的一个概念就是量，它仍然是一个我们说的变量和常量）

－（这样的量和它的行为应该统一地组织在一起）同时增强对象行为的主动性（我们不是在一定对象上施加一个操作，比如将，我们的PtDestroy，我是要销毁一个特定的点，那么我们就要传那个点的指针给PtDestroy函数，这样的一个销毁动作从行为角度来讲，它实际上是被动的，因为我要传一个参数进去给PtDestroy函数，让PtDestroy负责销毁它，我们希望所表达的是这个对象的行为主动性，也就是说，我们希望是一个点对象它自己发出一个销毁动作，然后释放它自己。这个就叫**对象行为的主动性**。

这个思考方法和结构化程序的思考方法是有很大不同的：一个是被动性的思维，一个是主动性的思维；从程序设计这个角度来讲，一个是被动式的思维模式，一个是主动式的思维模式。

那么很自然地我们就想，如果我们有这样一个接口库

```c++
// 想象的代码，非C++标准实现
struct POINT
{
 int x, y; // 公开量，不符合数据信息隐藏规则
 // x和y两个数据成员
 Create( int x, int y );
 void Destroy();
 void GetValue( int * x, int * y );
 void SetValue( int x, int y );
 bool Compare( const POINT* point );
 char* TransformIntoString();
 void Print();
}
//当你使用一个struct结构体关键字来定义对象的时候，这里面所有的成员都是工开的，除非你限定它，否则他们都是公开的，x和y外界可见，你没有做到数据封装和信息隐藏，虽然能编译能运行。
```

那我们整个程序的架构就算相当完整了。我把这个点库所有的数据和它的操作集封装在一起，全都放在它的结构体的内部，这样的话不就完成了数据和代码它的属性和行为的有效地统一了么。我们想要的就是这样一个机制，这样的一个机制就叫面向对象技术。

### 2.类类型

我们需要的就是能够对程序的访问和控制加以限制的特殊数据结构。这样的特殊的数据结构我们就称它为类类型。

#### 类的声明与定义

类的声明：仅声明类的存在，没有提供细节

-关键字：class     -示例：class A;

这种声明我们俗称前置声明

类定义
－一般定义格式
－类成员：数据与函数
－三个保留字顺序任意
－public：其后成员公开
－protected：其后成员有限公开（在自己这个结构体或这个类的内部都是可以自由访问的，**但是外界想访问它是有一个限制条件的，只有这个类的派生类才能访问它**）
－private：其后成员私有，仅本对象可直接访问

**注意**：这个三个关键字定义的顺序没有要求，都可以放在前面，而且每一个关键字都可以出现很多次。C++语言规定，我们class定义的类类型里，没有访问控制的成员和成员函数（前面没有关键字）缺省是私有的，也就是缺省是private的。如果你使用struct关键字来定义类类型，那么缺省的这样的数据成员和成员函数就是public的。这是struct和class最重要的区别。

```c++
class A {
public:
 成员类型 成员名称;
protected:
 成员类型 成员名称;
private:
 成员类型 成员名称;
};
//public/protected/private:这样的控制规则，我们称它为访问控制，你把这个访问控制规则去掉，你就会发现这个类的定义和我们结构体的定义就没差别。实际上，在C++代码里面，使用struct一样可以定义类，它们唯一的差别就体现在它的访问控制上，尤其是它的缺省的访问控制上面，
```

#### 示例

```c++
/* 点类库接口“point.h”*/
class Point
{
public:
 Point( int x, int y );
 ~Point();
 void GetValue( int * x, int * y );
 void SetValue( int x, int y );
 bool Compare( const Point & point );
 char* TransformIntoString();
 void Print();
private:
 int x, y;
};
//我们将它的成员x和y完全定义为私有的，外界是不可以访问的，我即使把它写在这个点库里面，放在“point.h”这个头文件里，一旦包含了这个“.h”这个头文件，从理论上来讲，它就能够看到这个class定义里全部的细节，它实际上是能够看到这两个成员x和y的，但是因为访问规则的限制，导致在外界，也就是class Point这个类的外界，没有权利去访问它。
我们通过这点达到了数据封装与信息隐藏的目的。同时因为我们将这些数据成员和数据成员上面所应该具有的操作集，统一地封装在这个class Point这个类的内部，从而完美地实现了属性和行为的统一。为什么我们要引入面向对象，就是这个原因。
```

**圆类库**

```c++
设计表示二维平面上圆的类类型
/* 圆类库接口“circle.h”*/
class Circle
{
public:
 void GetOrigin( double * x, double * y );
 void SetOrigin( double x, double y );
 double GetRadius();
 void SetRadius( double r );
 double GetPerimeter();
 double GetArea();
private:
 double r, x, y;
};
```

```c++
/* 圆类库实现“circle.cpp”*/
#include "circle.h"
const double pi = 3.141592653589793;
void Circle::GetOrigin( double * x, double * y )
//怎么表达这个函数是从属于一个特定类的信息呢？使用类名加::，::为解析操作符。
{
 *x = this->x;
 *y = this->y;
 //为了区分我们的参数和我们的类的数据成员，所以C++给我们的对象提供了一个this指针；
 //this关键字它指代这个对象本身，这个对象在哪里呢？你这么想，当我这个程序在运行的时候，这个成员函数将会由某一个对象来发起，注意这个操作是主动性的，这个函数必须是在一个对象上调用，发起调用的那个对象当然是属于我们这个Circle类的，它是谁呢？我们就用this指针指向它。this指针也就代替了那个对象自身。
}
void Circle::SetOrigin( double x, double y )
{
 this->x = x;
 this->y = y;
}
```

**this指针：指向当前对象的指针，由系统自动定义**。



#### 关于类声明与定义的说明

```c++
仅限于函数原型使用类类型的声明
不能用于定义类的数据成员
示 例
class B;//类类型的前置声明，没有定义它
class A {
public:
	void func( B b ); // 正确
    //A类的成员函数可以带有B类的形式参数，你不能作为函数定义的参数，因为真正到函数定义就必须使用那个类的对象了，所以那个仅有类类型的声明是不够的，但在函数原型里面可以只有类类型的声明。
private:
	B b; // 错误
    //这一点是和函数实现里面那个形式参数一样，你是不能够定义它的数据对象的。因为你要定义这个数据对象，就涉及到对这个数据对象进行内存分配，而内存分配的模式实际上我们是不知道的，只有类的声明的不知道的，必须要有定义。所以类类型的声明是不能用于定义类的数据成员的。
};
class B{ … };
```

### 3.对象

怎么使用类类型来定义我们的对象

#### 对象的定义与使用

正常情况下边，我们用class定义的类和用struct定义的类和struct定义的结构体，在数据的存储表示上面，实际上是非常类似的。那么其实就可以像结构体一样，定义和使用对象。当然在外界只能使用对象的公开成员。

**对象的定义**

－像结构体一样定义和使用对象及其公开的成员

－私有成员不可在对象外部直接访问

```c++
对象示例
/* 源文件“main.cpp”*/
int main()
{
Circle circle;
circle.SetOrigin( 0.0, 0.0 );
circle.SetRadius( 1.0 );
 cout << "Perimeter: " << circle.GetPerimeter() << endl;
 cout << "Area: " << circle.GetArea() << endl;
 return 0;
};
```

补充：在早期的C++实现里面，其实是没有C++编译器的，这样的代码都要转换成C的结构。然后调用C的编译器来编译我们的程序。像这样的函数调用：circle.SetOrigin(0.0,0.0)它实际上将会转换成SetOrigin(this,0.0,0.0)，它会按照这样的模式来调到C的编译器来编译我们的程序。当然了，它有能够区分Circle类的SetOrigin和另外一个类的同样同名的函数，它能够区分这一点就可以了。this指针的重要性就体现在这个地方。

#### 对象的构造

**非常重要！！！**

从某种程度来讲，构造就是初始化。要创建一个对象，我们就是要构造这个对象，构造这个对象那么你就要给它设定一个初始的值。因为在内存里边分配一段存储空间，要存储这个数据对象，这个内存一分配出来，里面一定是有数据的，要么是有意义的数据，要么是无意义的位序列。如果你没有对它进行初始化，这就意味着这样一个对象一开始的值是不可信的，你不知道它是什么，从某种程度上来讲，构造的目的就是为了让这个对象在构造的一瞬间就应该具有一个**有意义的数据**。就是从这一点上来说，构造就是初始化。

```
在这点上我之前理解一直有偏差，这是个类对象，不是普遍的变量，不算int a = 10这种初始化，脑海中不要想成是 定义了一个A类，然后 A a = xx 这种初始化；类的对象在第一章就说到了它是属性和行为的集合，你对这样一个集合初始化说白了就是对其成员（属性）进行初始化，行为是操作是方法不需要初始化的。
```

> ---百度知道：你只要定义了对象，就会分配内存，不管有没有初始化。 没有初始化的变量的值是该变量所分配到的内存中的数据，是一个不确定的值。
>
> 没有加static，默认为auto 型，此时，不给初值，变量的初值是随机的；如果加了static不给初值，变量的初值是默认的 0。
>
> 不能说不赋初值就不行，对于局部变量，不赋初值的话，其实里面存的是一个随机的值，谁也不知道是多少。事实上，如果使用未初始化的局部变量，编译器一般会给出警告。

**对象构造的意义**

－构造就是初始化，其目的就是在**定义对象时初始化其数据成员**

**对象构造的技术手段：使用构造函数**

－与类类型同名，没有返回值类型（包括**void**类型），即名字前面啥都没有。

－构造函数允许重载

－**构造函数可以带缺省参数，但是不建议**（你在声明这个构造函数的时候可以为这个构造函数的某些参数定义一个缺省的值，就是当你没有传递这个参数的时候，编译器就自动地传递一个缺省的参数进去，实际编程不建议这样写，它会影响你判断这个构造函数真实的参数到底有几个，从源代码级别你是看不出来的，比如，如果一个构造函数有两个参数，它的第二个参数是缺省的，当你只传一个参数构造这个对象的时候，仅仅看它的源代码你实际上不知道这个构造函数到底是一个单参数的版本还是一个双参数的版本，如果你这个类同时还提供一个单参数的构造函数，两者就有可能混淆。不仅你会混淆，编译器也会混淆。另外，**如果带缺省参数，必须是这些参数列表中的最后几个**。

－**至少公开一个构造函数**（因为构造这个对象是在类的外部去做的，在程序运行的时候这个对象需要构造出来，它可能是在全局的堆里构造的，也可能是在函数的栈上构造的，也可能是动态构造的，不管哪种构造模式都需要在类的外部调用它的构造函数对这个类的对象进行初始化，所以说你要想在外界构造这个对象，那你必须公开一个构造函数，外界可用）。实际上，构造函数你写在public里可用，写在protected里也是可以的，写在private里也是可以的。但是你要想让外界能够构造这个对象必须至少公开一个构造函数。后面会讲到一个很特殊的例子，就告诉大家如果我有一个对象，我就不想从外界构造它呢？那么你就可以将它的全部的构造函数都写在private后面，让外界不能构造这个类的对象，**所以一般来讲至少公开一个构造函数，但并不绝对**。

－只能由系统在**创建对象时自动调用**，程序其他部分不能直接调用（从实现这个角度来讲，我们不能够在这个类的外部来调用它的构造函数吗？当然不是，有的面向对象语言就允许你主动地调用构造函数，但是对于C++代码来讲，它是不可以的）

```c++
设计表示二维平面上圆的类类型
/* 圆类库接口“circle.h”*/
class Circle
{
public:
 Circle();
 //Circle( double r, double x = 0.0, double y = 0.0 ); // 缺省参数，不建议
 Circle( double r, double x, double y );
 ……
private:
 double r, x, y;
};
```

```c++
/* 圆类库实现“circle.cpp”*/
Circle::Circle()
{
 r = 0.0, x = 0.0, y = 0.0;
}
Circle::Circle( double r, double x, double y )
{
 this->r = r, this->x = x, this->y = y;
}
/* 主程序“main.cpp” */
int main()
{
 double r = 1.0, x = 0.0, y = 0.0;
 Circle circle( r, x, y );
 //实际上C++编译器在看到这段代码的时候，它就会为我们分配一个Circle类的存储空间，也就是为我们定义好这个对象，然后会调用构造函数，将r、x、y三个值写进去。
 //即构造的时候同时初始化
}
```

> 定义对象时初始化的两种方式：
>
> ```c++
> ClassTest ct1("ab");  // 直接初始化
> ClassTest ct2 = "ab"; // 直接初始化
> // 使用第一种更好
> ```

如果类里面没有明确的构造函数，其实是可以的，如果你真的没有定义这个对象的构造函数，那么编译器会自动地为我们创建一个**缺省的构造函数**，并且自动调用，**缺省的构造函数本身是没有参数的，函数体里也没有任何代码，空的**！它什么都不做，就**只是自动地完成构造函数的逻辑。它其实就是分配好空间**。如果定义了构造函数，编译器就不再替你生成一个缺省的构造函数，所以如果你生成的构造函数是带有参数的版本，并且这些参数没有全部设置为缺省参数的话，那就意味着缺少一个不带参数的构造函数版本，某些时候可能会导致问题。

```c++
缺省构造函数调用示例
－正确示例：Circle circle;
//自动替我们调用缺省的构造函数
－错误示例：Circle circle(); 
－在构造函数无参数时，不能使用函数形式构造对象。原因？
  这在C++的编译器里是没法通过的
```

**拷贝构造函数**

拷贝构造函数用于构造已有对象的副本；（它将完成从一个对象拷贝到另外一个对象上的任务，拷贝构造必须要求已有对象才能创建它的副本）

拷贝构造函数单参数（它接受某一个对象进来，然后才能拷贝它），**接受的格式是固定的**必须是本类的某一个**常对象的一个引用**（比如如果是个Circle类，你传过来的应该是const Circle&，对const Circle类的对象的一个引用）；

如未定义，系统自动产生一个缺省拷贝构造函数；

**缺省拷贝构造函数为位拷贝**（浅拷贝，即把那个对象的**内存区域**一个字节一个字节完全地搬到另外一个对象里，不管那个字节里面的信息是什么意思，全部拷贝过去就行了，即只拷贝指针的四个字节，不拷贝字节所指向的数据对象），如需深拷贝（例如成员为指针），需自行定义。

> “浅拷贝”即将被拷贝对象的数据成员的值一一赋值给新创建的对象，若该类的数据成员中有指针成员，则会使得新的对象的指针所指向的地址与被拷贝对象的指针所指向的地址相同;

---为啥是浅拷贝呢，你想啊，如果我这一个类的数据成员中有一个指针，这个指针指向一个动态分配的目标数据对象，当我拷贝这个对象的时候，你是把那个指针所指向的目标数据对象拷贝到这个类的新副本里面去了呢还是仅仅是把那个指针的值拷贝过去了呢？浅**拷贝仅仅能够完成这个指针值的拷贝**，它不能够完成指针所指向的目标数据对象的拷贝。

> 如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。

```c++
/* 圆类库接口“circle.h”*/
class Circle
{
public:
 Circle( const Circle & that );
 ……
private:
 double r, x, y;
};
/* 圆类库实现“circle.cpp”*/
Circle::Circle( const Circle & that )
{
 this->r = that.r;
 this->x = that.x;
 this->y = that.y
```

在构造一个对象的时候，我们可以在构造函数的开头，也就是构造函数的头部定义它的初始化列表，基本的模式如下：

```c++
初始化列表的格式
class A
{
public:
 A( int a );
private:
 int a;
};
class B
{
public:
 B( int a, int b );
private:
 A a;
 int b;
};
A::A( int a ) : a(a)
{}
//(a)前面的a就是这个A类的那个成员的名字，括号里面的a就是构造这个对象的时候对它进行初始化的时候传给它的形式参数；即一个是成员一个是形式参数。
B::B( int a, int b ) : a(a), b(b)
{}
//a(a)这个两个参数可以名字不一样，这里不需要用this，写了编译器就通不过了，实际上编译器能知道这个名字a是写在小括号对里边还是在小括号对的前边，所以它就知道这个a就代表着这个类A中的成员还是它的形式参数。

```

**初始化列表的目的与意义**

－在构造对象时，**同步构造内部对象**

－**部分成员（常量与引用）只能初始化，不能赋值**

－部分成员（某个类的对象）如果赋值，将导致两次构造（因为你在构造这个对象的时候，如果这个对象的某一个数据成员，是另外一个类(B)的对象，你构造这个对象（类B的）的时候它分配整个对象的存储空间，然后对它进行初始化，**当你没有把这个类（B）的对象在初始化列表里面写出来的时候，它就会缺省的构造它，也就是调用（B类）缺省的构造函数去初始化这个对象**，然后它执行你的构造函数的函数体，发现里边还要构造一次它，你这个函数体里面调用了它的数据成员的那个类（A）的构造函数去构造那个数据成员啊，所以它就会再构造一次那个对象，又为它初始化了一遍；这个显然浪费了程序的执行时间，降低了程序运行的效率，所以如果你的类里它的某些数据成员是其它类的对象，那么这些数据对象都应该在这个类的构造函数初始化列表里边对它进行构造，而不要写在构造函数的函数体里）

​	· 在分配内存时，调用缺省构造函数构造，然后执行构造函数函数体内的赋值语句再次构造，效率不佳
​	· 若类没有缺省构造函数，则会导致问题（你定义了一个带参数版本的构造函数，没有定义缺省的构造函数，但是你已经有构造函数了，系统就不会为你自动生成缺省的构造函数；所以在这种情况下边，它就会调用缺省构造函数去构造你的那个对象的啊，但是你又不存在缺省构造函数，那么系统就会导致问题）

> [c++构造函数（初始化式）被忽略的东西](https://blog.csdn.net/gaotengguojianhong/article/details/7058111)
>
> ---内部使用Ctrl+鼠标点击来跳转
>
> 不管是在c++,还是c#，或是java中，当人们一提到构造函数是，马上就回有人回答，是用来初始化成员变量的，没错，但是殊不知，后面却隐含了很多东西。
>
> 首先：构造函数用初始化式列表与在函数体里面直接初始化有什么不同。
>
> 我先简单说一下初始化式，可能有人已经忘了什么是构造函数的初始化式。其实初始化式就是一个以冒号开始，接着是一个以逗号分隔的数据成员列表，**每个数据成员后面跟着一个放在圆括号里的初始化式**。而初始化式**只能在构造函数的定义中而不能再声明中指定**（因为初始化是构造时同步完成的，声明不能构造）。如：
>
> ```c++
> class A{
>   public: int a,b;
>   public: string c;
>   A(const string &s):a(3),b(4),c(s){ }
>   //这里是定义不是声明，有{}没有分号结尾
>   //用形参s初始化对象c
> };
> ```
>
> 我们也可以由下面的方式进行成员变量的初始化：
>
> ```c++
> class A{
>   public: int a,b;
>   public: string c;
>   A(const string &s){ a = 3;b = 4;c = s}
> };
> ```
>
> 那么上面两个有什么区别呢？
> 我们先说一下，构造函数的执行过程分为两个阶段：（1）初始化阶段；（2）普通计算阶段。
> 普通计算阶段是由构造函数的函数体内的语句来构成。
> 那么我们来分析一下第二种方式的初始化：
> 这个构造函数在给类A的成员变量赋值之前，**第一步要进行初始化变量c。所以这个构造函数使用了内部隐式的string类的构造函数对c进行初始化。当我们执行到普通计算阶段时，又对c进行了赋值。**
> 那么什么样的构造函数必须使用初始化式来对成员变量进行赋值呢？
> 我这里给出两种，一种是const，另一种是引用类型。
> 为什么呢？我们可以想一想const变量要求在声明的时候就进行初始化，而如果我们采用第二种方式的话，在构造函数的第二个阶段，又会对const变量赋一次值，而这又违反了const变量的性质。关于引用类型的探讨留给读者。
>
> 定义引用类型时：
>
> 将引用绑定到初始化对象；
>
> 因此定义引用类型时必须有初始值对象（必须为左值）
>
> 如果不提供初始左值的话，默认构造器无法生成左值。

注意事项

－**成员初始化按照成员定义顺序，而不是初始化列表里面的那个说明的顺序**（比如你定义的类，它第一个成员是a，第二个成员是b，第三个成员是c，构造的时候就是按abc顺序构造的，假如初始化列表是bac的顺序，它先看到b，再看到a，就会把a跳过去，因为a的构造的时机已经被你错过了，**前面就认为它是缺省构造，它就不管了**，直接去构造c，这样就会导致a没有被正确的构造）

－必须保持初始化列表和成员定义的顺序一致性，但允许跳过部分成员；否则后续成员可能不会正确初始化

---构造函数的初始化列表最主要的一个目的，就是当我们在创建这个对象，我们要对它进行初始化，**我们希望的就是能够同步地初始化它的全部的数据对象**，为什么要初始化列表呢？你把这些内部对象的那个初始化动作写在那个构造函数体里边不行么？大部分时候是行的，有些时候是不行的，因为两者的实现策略是不一样的。你把那个代码写在构造函数的函数体里边，那就意味着这些代码将是在这个对象被构造完成之后去调用的；而你写在这个构造函数的初始化列表里面，它将是在构造那个对象的瞬间去对它进行初始化的。还记得以前我们讲过，初始化和赋值之间的差异吗？这一点在构造函数初始化列表和构造函数体内部代码之间体现的情况是一样的。

#### 对象的析构

构造是决定我们这个数据对象的初始化，当我们这个程序运行到某一时刻或者程序结束的时候，这些对象生命期结束了。我们就要销毁它，销毁这个动作，不管是你主动地去销毁，你调用free或者调用delete去主动地销毁你动态分配的内存，还是由系统自动地去销毁，都涉及到这个数据对象进行一系列的清楚工作，我们要在对象的生命期结束的时候清楚它。

对象析构的意义

－**析构就是终止化，在对象生命期结束时清除它**

对象析构的技术手段：使用析构函数

－与类类型同名，前有“~”记号，无返回值类型（包括void类
型），无参数

－**析构函数必须是公开的**（因为当你想要销毁这个对象的时候，它可能会被使用delete这样的操作符来调用的，不管怎样，它都需要使用这个类的析构函数去销毁它，**那肯定是在这个类的外部调用析构函数**，不公开就没有办法销毁这个对象。同样析构函数一样可以设为私有或保护的，在这个类或派生类外部就没有权利去析构我们的对象，这样的程序代码也是存在的）

－可以由系统在销毁对象时自动调用，也可以由程序其他部分直接调用，但两者（系统调用和程序员主动调用）工作原理不同，因为**我们主动调用析构函数并不涉及到销毁这个对象所分配的那个内存，仅仅是销毁它里面的数据**。

－**每个类只能有一个析构函数**

－若未定义，系统会自动产生一个缺省析构函数，该函数无代码（系统给出的析构函数作用一般是释放定义对象时系统分配的对象空间；如果你声明动态内存的话，必须要显示的释放，
其他的是编译器处理）

总结前面我们就知道了：在类的声明里面有三个缺省的函数，缺省的构造函数、缺省的拷贝构造函数、缺省的析构函数；实际上还有第四个缺省的函数，接下来会讲到。

继续看圆类库接口

```c++
设计表示二维平面上圆的类类型
/* 圆类库接口“circle.h”*/
class Circle
{
public:
 Circle();
 Circle( double r, double x, double y );
 ……
~Circle();
//因为我们这个对象里没有任何动态内存分配的数据，所以析构函数你不写，系统自动生成的这个析构函数就够用。你写了，其实代码里我也不知道要写什么，什么其实都不用写，空着就可以了。但是你一定要实现它对吧，你不能只声明不实现它，那个不成，只声明不实现就意味着不能调用。实现方式如下：
A::~A() {

...

}
private:
 double r, x, y;
};
```

**定义析构函数的目的**

－用于释放对象中动态分配内存的目标数据对象

就像拷贝构造函数一样，缺省的，它只能完成浅拷贝，它缺省给你提供的那个析构函数只能完成浅层的释放，它不能完成深层的释放。

所以如果**你的对象里边有一个数据成员，它是一个指针**，指向一个目标数据对象，而那个目标数据对象是你动态分配的，并且你这个对象负有销毁它的义务。**那么你就应该写一个析构函数，在这个析构函数体内部销毁那个目标数据对象**。

```c++
使用示例
class A{
public:
	A( int x );
 	~A();
private:
 	int * p;
};
A::A( int x )
{
 p = new int;
 *p = x;
}
A::~A()
{
 delete p, p = NULL;
 //delete 释放new分配的单个对象指针指向的内存
}
//如果你没写这个析构函数，编译器自动生成的那个缺省析构函数，就什么代码都没有，就意味着它没有销毁p所指向的那个目标数据对象，而直接把这个对象本身销毁了，这叫导致了内存泄漏。指针没了，内存空间数据还在，那段内存空间就再也不能用了。

补充：
//一般操作系统会管理内存，程序运行的内存由操作系统分配，泄露的内存会在程序结束时回收。如果操作系统本身有问题，重启应当能解决内存泄露（除非操作系统启动代码就有问题）
//因为你占用的是操作系统分配的程序的虚拟内存地址，不是内存条的
//这段内存不能用了是指如果别的程序又分配到这个内存，它不能被使用了。
```

#### 对象数组

对象数组

－可以像普通数组一样定义和使用（也就是一个数组的每一个元素都是一个类的一个对象，我们可以定义一个类的很多个对象，然后构造成一个数组，这是没问题的）

对象数组的初始化

－当构造函数单参数时，像普通数组一样构造所有元素

就是初始化符号，后面花括号对，后面跟着一个值、一个值，逗号分隔开，系统自动替你将这样一个值转换成类的那样一个对象。其实就是完成一个类型转换，这就是单参数构造函数的意义，它看上去就像一个类型转换一样，它实际上就是类型转换。

－当构造函数多参数时，使用下述方法构造

```c++
Circle circles[2] = { Circle(1.0, 0.0, 0.0), Circle(2.0, 1.0, 1.0) };

//多参数时，你不知道这个逗号分隔开的这些数据成员到底是第一个元素还是第二个元素，所以就必须调用类的构造函数
```

### 4.类与对象的成员

#### 内联函数

**目的：程序优化，展开函数代码而不是调用**（和整个程序的gon功能和整个程序的实现本身它实际上是没有关系的，所以没有内联函数对程序来讲是没有关系的，就是程序运行的效率可能会低一些，其它没有任何影响）

---就是说，如果我有一个函数，它代码量其实很短，如果你每次都调用这个函数，由于函数调用是需要开销的，所以实际上在程序运行的时候会很不经济，从执行时间，也就是效率这个角度来讲，它实际上是调用函数还不如直接编写函数体内部的代码，直接执行它，内联函数就是做这个事情。**它就将这段代码直接展开到那个函数调用的地方，不进行函数调用**！从而提高了我们的程序效率。

**内联函数使用的注意事项**

－在函数定义前添加inline关键字，仅在函数原型前使用此关
键字无效（因为inline本身只和这个函数的定义有关，和它的原型其实没关系）
－编译器必须能看见内联函数的代码才能在编译期展开，因而
**内联函数必须实现在头文件中**（这也就意味着在大多数情况下，你的内联函数必须写在头文件里，工程项目包含很多文件，如果其它的源文件要使用这个内联函数，你要保证这个代码能够展开到另外一个文件里去，那么这个内联函数的实现你必须写在头文件里）
－在类定义中**给出了函数体的成员函数自动成为内联函数**（要在类定义中给出函数体的时候，比如你在类的定义里，实现一个函数，你不需要写它的函数原型---后面不是分号，而是直接跟着花括号体把它的函数实现代码都写在类里边，你前面不用写inline它也是inline）
－函数体代码量较大，或包含循环，不要使用内联（体量大使用内联的效果会导致我们整个程序的代码空间急剧膨胀，你程序效率可能是经济的，但是整个程序的空间是不经济的，所以并不是一个好的选择）
－构造函数和析构函数有可能隐含附加操作，**慎用内联**
－**内联函数仅是建议**，编译器会自主选择是否内联（你写了inline表示你建议编译器将这个函数实现为内联函数，编译器听不听你的它自己有自主决定权，比如代码体量很大时，编译器认为这个函数不适合作内联函数，它就不会inline）

注意：函数调用开销是远远大于函数本身的。

#### 常数据成员

**常数据成员：值在程序运行期间不可变**

－定义格式：const 类型 数据成员名称;

**－必须初始化：只能通过构造函数中的初始化列表进行**（类定义外）

```c++
使用示例
 class A
 {
public:
	A( int a );
private:
 	const int num;
    //不可以对它赋值，那么对它设定值的唯一一个机会就在初始化的那一瞬间
};
A::A( int a ) : num(a) { …… }
// 初始化列表如果写在类外只能写在源文件中，不能写在头文件中，否则会出现重复定义问题。初始化列表只能写在构造函数定义中不是声明，要么在类构造中写，要么写在源文件中，经测试正确。
```

#### 常成员函数

我在一个类里，定义了一个函数，它需要读取这个类中的数据，同时我们明确地知道这个成员函数是不会修改成员的数据的，那么这一点函数在实现的语义来讲，我们有必要把它实现成一个常函数。(只负责读取不能修改)

**常成员函数：不能修改对象成员值的函数**

－定义格式：类型 成员函数名称(参数列表)  const;（因为const是左结合的，所以你不能写在函数原型前面，只能写在函数原型的后边）

**－常成员函数不能调用类中非常成员函数**（因为非常成员函数它就有可能修改成员属性的值，所以你调用它就有可能打破常成员函数的语义，编译器本身不允许你做这样的调用）

**－静态成员函数不能定义为常成员函数**

> 原因：

**－如果对象为常量，则只能调用其常成员函数**（它的非常成员函数你都没有权利访问的）

​		正是在这个角度上来讲，如果你定义了一个类的类型，并且你知道未来你会用这个类类型定义一个常对象，那么这个类类型的接口里边，那些凡是不需要修改成员的属性值的，这样的函数都应该定义成常函数

```c++
使用示例
class Circle{
public:
double GetArea() const;
 ……
};
double Circle::GetArea() const{ …… }
//如果函数的原型或者实现时有一个没写const，编译器会认为这是两个不同的函数。所以要写就都写。
//一旦一个函数不需要修改成员变量的值，或者不能修改成员变量的值，那么就应该把它定义成常函数
```

#### 静态数据成员

**静态数据成员只有一份，由该类所有对象共享**（普通的数据成员，每一个对象都有自己的独立的一份，你用这个类类型定义一个对象，它就结构了一份它的全部数据成员，再定义一个对象，又构造一份，这两者是不一样的，它是两个物体，两个对象，两份数据，如果你要求一个特定的数据成员，在这个类中所有对象上都一样，就一份，那就应该使用静态数据成员）

－声明格式：static 类型 静态数据成员名称;
－仅声明，**不在类的对象上分配存储空间**（它是单独分配的，但是访问规则仍然是属于这个类的，**你要通过类名去解析**）
－定义格式：类型 类名称::静态数据成员名称 = 初始值;
－必须在**外部初始化**，初始化动作与访问控制无关（也就是说不管你是声明为public，还是protected，还是private都应该在这个类的外部单独地对它进行初始化，而不能在类的内部对它进行初始化）

```c++
示 例
class A {
private:
static int count;
};
int A::count = 0;
//初始化时不需要加static进行修饰
//初始化动作应该放在源文件而不是头文件里，因为它相当于一个变量的定义
//为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。
```

#### 静态成员函数

定义静态成员函数的目的仍然是**在一个类而不是在一个对象上面对它进行调用**，它就是未来**访问类的静态的成员而设置的**。

定义了一个静态数据成员，你要想访问这个类的静态数据成员，那么使用静态的成员函数是一个非常恰当的方式。如果你要访问这个类的非静态的数据成员，那么你必须提供这个非静态的数据成员到底是属于哪一个对象的，也就是说，你必须提供一个对象或者一个对象的指针或者一个对象的引用。

```c++
class A {
public:
 	static int f();
 	static int g( const A & a );
private:
	static int count;
	int num;
};
```

```c++
int A::count = 0;
int A::f()
{
 return count;
}
int A::g( const A & a )
{
 return a.num; 
 //num为非静态数据成员，这里提供了一个对象的引用访问它，这里传了一个const A的一个引用
 //因为静态成员函数并没有缺省的this指针
}
```

静态的数据成员和静态的成员函数非常非常有用，在我们的编程中，频繁地需要设计一个很特殊的程序功能。就是什么呢？**存在着某一个类的单一的共享对象**，这样的共享对象它是全局的，在整个程序中，它只能存在一个，并被整个程序中的所有的模块所共享。这样的一个东西，我们称它为是一个**单子**（singleton）。那么我们的编程呢，就必须能够保证这样的一个单子：①全局就存在一个②在全局的任何一个地方都能够访问到它，也就是说我们一定要有一个全局的访问策略，保证在程序代码的任何地方只要需要就能访问到它。操纵的那唯一一个数据对象，这个数据对象就叫单子。

单子模式呢，有很多种实现策略。

```c++
class Singleton
{
public:
 static Singleton * Get() { if (!_s) _s = new Singleton; return _s; }
 // 静态成员函数，对象不存在时构造，否则返回之，保证唯一性
 int GetData() { return ++a; }
 //来返回我们的验证数据看看对不对
private: // 私有构造和析构函数，禁止在外部构造和析构本类的对象
 Singleton() { a = 0; }
 Singleton( const Singleton & that ); // 只声明不实现，禁止拷贝和赋值构造
 Singleton & operator=( const Singleton & that );//赋值的重载构造函数
 ~Singleton(); // 只声明不实现，禁止析构
    
只声明而不实现，这就意味着这样的拷贝函数不仅外界不可以调用我们自己也是不会调用的，因为没有它的实现代码，你一调用编译器就报错，着实际上意味这我们通过这种手段保证我们这个单子模式它是一个不可拷贝对象，这个语义是非重要的，因为如果你允许这个对象可以被拷贝，那就意味着这个单子就不再单了，只声明而不实现它的拷贝构造函数和赋值构造函数就能让这个单子对象不可拷贝，从某种程度上来讲也保证我们的单子模式的唯一性。
接下来，我们要保证怎么真正地构造这个对象，你没有公开的构造函数，外界就不能调用它，那我们这个对象什么时候被构造出来呢？因为单子又不是无子，它总归要有一个子。那么就提供一个公共的Get函数。用这个Get函数来构造这个对象。因为这个Get函数是我们类的一个成员函数，当我们调用这个公开的Get函数的时候，那么它就会执行它的内部代码，而这个内部代码又在这个类的内部，所以它可以调用这个类的私有的构造函数去替我们构造它。在这里我们就可以用一个new操作符调用私有的构造函数去构造我们的这个对象，然后我们返回它构造出来的这个对象，构造出来的这个对象保存在什么地方，这是一个需要特别注意的问题。因为我们时刻要记录构造的对象分配的内存地址在哪里，这个指针必须要保存。所以我们要在这个类的Singleton里面定义一个私有的数据字段，是一个指向Singleton的指针来保存我们构造出来的这个类的，单子对象到底存在哪里，因为这个类中保存的单子就一份，所以这个指针_s应该只有一份，前面要加上static关键字，保证_s是指向本类唯一的对象的那个唯一的指针。
private:
 static Singleton * _s; // 静态数据成员，指向本类唯一对象的指针
 int a; // 作为我们的验证数据
};
Singleton * Singleton::_s = NULL; // 定义于源文件中
// 使用方法：以Singleton::Get()->GetData()方式直接访问，唯一的方式
Singleton::Get()
//我们得到这个指针之后就可以引领这个指针所指向的那个目标对象，就是Singleton的一个对象，然后调用它的GetData返回它对应的实际的那个验证数据递增以后的值。

在这里面我仅仅是写了一个析构函数的声明，所以我没有销毁在构造函数中分配的那个指针所指向的目标数据对象的内存，当程序结束的时候，绝大多数的操作系统都会自动地释放动态分配的内存，我们可以不实现它，大部分时候都没问题，但是偶尔，真的没有析构函数它确实有可能导致问题的，因为我们这里面毕竟有一个指针，指向一个动态分配的内存。
因为这个静态成员是从属于一个特定的类的，而不从属于那个类的某一个对象，所以要想解析这个静态数据成员那么前面必须加上类名Singleton::_s，初始化为NULL。
```

我们定义的这个单子模式里面，因为要求这样的数据对象，全局只能构造一个唯一的副本，这就意味着它的构造函数不能公开。

------

上述就是我们单子模式的第一版，没有析构。没有析构当然可能导致问题的。

```c++
class Singleton
{
public: // 静态成员函数，对象不存在时构造，否则返回之，保证唯一性
 static Singleton * Get() { if (!_s) _s = new Singleton; return _s; }
 int GetData() { return ++a; }
private: // 私有构造和析构函数，禁止在外部构造和析构本类的对象
 Singleton() { a = 0; }
 Singleton( const Singleton & that ); // 只声明不实现，禁止拷贝和赋值构造
 Singleton & operator=( const Singleton & that );
 // 析构函数实现为private，在外部是不能够调用的
 // 错误析构函数，即便访问控制改为public也不行，因为   delete操作符本身需要调用析构函数，Singleton::_s它是指向Singleton的一个指针，要销毁这个_s所指向的那个目标对象，目标对象就是Singleton，所以你就必须调用这个Singleton的析构函数才能够销毁它嘛。所以你在这个类的析构函数里边，调用这个类的析构函数本身是不可以的。
 // 另外非静态函数不能释放静态指针成员，否则在某些Linux系统下可能导致系统崩溃
 ~Singleton() { if(Singleton::_s) { delete Singleton::_s, Singleton::_s = NULL; } }
private:
 static Singleton * _s; // 静态数据成员，指向本类唯一对象的指针
 int a; // 验证数据
};
```

我们需要析构，上面的又不对，怎么办呢？这里有一个方案，我们希望这个析构函数它能正确地被调用，不是不实现它，但是我需要它在某一个恰当的时机能够被调用，那么什么样一个时机被调用呢？就是程序完全结束之前，所有的动态分配的静态量都应该销毁它们指向的目标数据对象，那么我们就想了一个很巧妙的一个技巧，使用到了**嵌套类**的概念，如果我在一个类的内部还定义另外一个类，那么这样一个类就从属于这个类，这个叫嵌套类。

```c++
class Singleton
{
public: // 静态成员函数，对象不存在时构造，否则返回之，保证唯一性
 static Singleton * Get() { if (!_s) _s = new Singleton; return _s; }
 int GetData() { return ++a; }
private: // 私有构造函数，禁止在外部构造本类的对象
 Singleton() { a = 0; }
 Singleton( const Singleton & that ); // 只声明不实现，禁止拷贝和赋值构造
 Singleton & operator=( const Singleton & that );
public: // 在部分系统下使用private亦可，系统简单释放全部内存，并不调用它
 ~Singleton() { } // 因此，如果函数非空（如需数据持久化），有可能导致问题
private:
 static Singleton * _s; // 静态数据成员，指向本类唯一对象的指针
 // Destroyer类的唯一任务是删除单子
 class Destroyer{
 public:
 ~Destroyer() { if(Singleton::_s) { delete Singleton::_s, Singleton::_s = NULL; } }
 };
 static Destroyer _d; // 程序结束时，由操作系统负责替我们销毁，在销毁它的时候操作系统就会调用静态成员_d的析构函数,而这个析构函数就会替我们销毁_s所指向的那个静态的Singleton那个单子对象，这个过程是自动的。
 int a; // 验证数据
};

这个析构也是有点问题的，一，这个销毁只能在程序结束的时候进行，因为它是自动进行的，什么时候_d需要被销毁，单子才能够销毁。销毁的时机我们别无选择；二，有些编译器在程序结束的时候，因为优化的目的，所有的资源都会直接返还给操作系统，也就是说，这样对象你不销毁其实问题也不大，所以它可能压根就不销毁_d，它不销毁_d，那么就不会销毁_s所指向的Singleton。如果你的单子模式中，它的析构函数里面写了一些特殊的代码，那么这个类可能会有问题。
假设Singleton是一个实际应用的类，它会一自己其它附加的信息专门去做某些特定的事情，那么这样一个析构函数因为要被外界调用，所以我需要把它变成public，同时呢，比如我这个类里面有一些数据，需要在这个单子对象被销毁的时候完成它的数据持久化，那么如果我把这段代码写在了Singleton的析构函数里，要确保这个Singleton的这个析构函数能够被调用，有些编译器，程序结束了，你所有动态分配的量不管三七二十一全返还给操作系统算了，根本就不用管，所以这个析构函数它压根就不调用，根本不管这个单一的一个对象，要不要销毁，它不释放_s,Singleton这个析构函数就不会被调用，你的数据持久化代码如果写在析构函数里它就不会被执行，你的程序语义就会有问题。
所以这个析构的方式是正确的，但是在某些特殊的情况下，我们的程序可能不像我们所期望的那么工作。
```

我们再想一个方案

```c++
class Singleton
{
public: // 静态成员函数，对象不存在时构造，否则返回之，保证唯一性
 static Singleton * Get() { if (!_s) _s = new Singleton; return _s; }
 // 不调用析构函数，Release调用时机由程序员确定
 static void Release() { if(_s) { free(_s), _s = NULL; } }
 int GetData() { return ++a; }
private: // 私有构造和析构函数，禁止在外部构造和析构本类的对象
 Singleton() { a = 0; }
 Singleton( const Singleton & that ); // 只声明不实现，禁止拷贝和赋值构造
 Singleton & operator=( const Singleton & that );
 ~Singleton();
private:
 static Singleton * _s; // 静态数据成员，指向本类唯一对象的指针
 int a; // 验证数据
};
```

不实现析构，我真释放那怎么办呢？我写一个public函数，自己写一个释放函数，因为要操纵的是静态对象，所以我们静态函数static void Release() 释放那个静态的对象。奇怪的是这个对象是new出来的，销毁的时候没有delete，而是free。当我们调用free的时候，它简单地清空那一片存储区，而不调用那个类的析构函数，如果你delete，它要作的事情就是调用那个目标对象的析构函数，然后清空那段内存，把那段内存还给操作系统，如果你free，它就不调用那个类的析构函数，直接返还那段内存给操作系统，这样我就能保证这一段内存区域，能够完整地正确的返还给操作系统，即使它是new出来的。也就是说，在某些特殊的时候，new和free一样是可以配对的。所以如果你要对它做数据持久化操作，简单，在free这个函数前完成它的持久化就行了。这就意味着有了release这个函数，那么你在任何时候想析构这个单子对象，就可以析构这个单子对象，调用它Singleton::Release() 它就会销毁那个单子对象。当你再次调用Singleton::Get() 的时候它就会再次创建一个单子对象，这个时候你要注意，销毁的那个单子对象和新创建的那个单子对象是两个不同的对象，它们存续的时间是不同的。虽然这两个单子对象在程序中都保证在它们存在的那段时间里它们都是唯一的，但它们仍然是两个不同的单子对象，当然也有可能放在内存的不同的地方。所以要特别区注意这个问题。

这个实现也会有一个小问题，如果程序员忘了调用Release怎么办，那就没有被释放嘛。所以如果你要保证在程序结束的时候要销毁整个程序中出现的所有单子对象（可能每一个类一个单子对象），那么你必须在程序结束之前最终要写一个清楚的一个函数来销毁所有的单子，你如果忘了写它，那这些对象就都没有被清楚，就有可能导致问题。所以我们使用一个新的结构来实现它。这个单子类和原来那个单子类实现有很大的差别了。它代码很短，但是可以解决原来那些问题。

```c++
class Singleton
{
public: // 静态成员函数中的静态变量，保证唯一性
 static Singleton & Get() { static Singleton _s; return _s; }
 int GetData() { return ++a; }
private: // 私有构造和析构函数，禁止在外部构造和析构本类的对象
 Singleton() { a = 0; }
 Singleton( const Singleton & that );
 Singleton & operator=( const Singleton & that );
 ~Singleton() { }
private:
 int a; // 验证数据
};
// 本实现没有动态内存分配，因而无需销毁单子对象
// 使用方法：定义引用或以Singleton::Get().GetData()方式直接访问
Singleton & sing = Singleton::Get();
//定义一个引用的别名，这个初始化动作既不会发生值的拷贝，也不会发生赋值，既然什么都不发生，我们引用的就是那个唯一的单子量。
int n = sing.GetData();

虽说这是一个不太好的方式，如果真是一个单子，其实建议同学们不要定义这样的量，即使是引用量，也不要定义它，每次都是Singleton::Get去得到它。这样的话，我们保证访问的就是那个唯一的静态局部量。而且在源代码级别能够看到它是完全唯一的。
```

没有指向单子类静态单子的一个指针，因为以前所有的构造和析构的问题，都是因为分配了一个动态内存区域所导致的，所以我们就不要指针了。那我们这个单子在哪里实现呢，那么我们就要在Get那个函数里边定义和实现它。所以我将在这个函数内部，定义一个静态的单子对象_s，使用它的无参数版本对它进行初始化。return _s 返回在这个Get函数内部定义的静态局部变量 _s ，不管这个静态局部变量是定义在普通函数里还是定义在成员函数里，所有的静态变量都将像全局变量一样分配存储空间在整个程序运行期间一直维持不变，我们返回的就是 _s ，不管你调用多少次Get，返回的都是它，这不就是单子了吗。尤其你考虑到，我们的构造函数全私有的，还好几个没实现，那不就是一定是这个样子吗。你只能通过Get得到那个单子，Get得到的就是唯一的那个静态局部量 _s 嘛，那不就是单子嘛。所以Get函数返回的就是 static Singleton 的一个引用。

#### 静态常数据成员

它混合了常数据成员和静态数据成员的两个特征。它的值不仅是在程序运行期间是不可以改变的，且每一个类只有唯一的一份。

**－定义格式：static const 类型 数据成员名称;**

**－初始化：只能在类的外部初始化**（有例外，数据是整型量或整型量存储的，比如int、bool、char、枚举型）

```c++
使用示例
class A {
private:
 static const int count;
};
const int A::count = 10;
//两个const都不能省略，而static只需在类的数据成员地方写上就行了
```

> 1、自定义类型（string等内置类型以及使用class定义的类等）
>
>    必须放在类外初始化，不可以放在xxx.h文件中，可以不加static修饰
>
> 2、基本数据类型(int char bool等)
>
>    可以在类内部进行初始化（唯一一个可以在类内进行初始化的）
>
> ```c++
> //example.h
> class Example{
> #include <string>
> using namespace std;
> 
> class Example{
> public:
>     Example(int a);
> public:
>     static int si;
>     const int ci;	//常成员变量，在构造函数的初始化列表中初始化
>     static const int scd = 1;
>     //static const int sci;
>     static const string scs;	//类类型的静态常量，必须在类外初始化
> };
> ```
>
> ```c++
> //example.cpp
> #include <iostream>
> #include "static_test.h"
> 
> int Example::si = 10;
> //const int Example::sci = 19;
> const string Example::scs = "zs";
> Example::Example(int a) : ci(a) {} 
> //对常成员变量ci进行初始化
> ```
>
> ```c++
> #include <iostream>
> #include "static_test.h"
> using namespace std;
> 
> int main()
> {
>     Example e(3);
>     cout << e.scd << "\n" << e.ci << "\n" << e.si << endl;
>     return 0;
> }
> ```
>
> 

#### 友元函数与友元类

友元就是朋友，有些特定的类在外界，有些函数或者另外一个类想使用它，不是想使用它的公开数据和公开成员，是想使用它的隐私数据和隐私成员。

友元：慎用！破坏类数据封装与信息隐藏

－类的友元可以访问该类对象的私有与保护成员
－**友元可以是函数、其他类成员函数，也可以是类**
－定义格式：friend 函数或类声明;
－两个类的友元关系不可逆，除非互为友元

```c++
使用示例
class Circle
{
 friend double Get_Radius(); // 友元函数
 friend class Globe; // 将Globe类所有成员函数声明为友元类
// 只能写在这个类的定义里。同时这个写法不需要加访问控制在前面，它只是一个声明，它不是类的成员，所以访问控制作用不到它上面。
private:
double radius;
};
```

虽然慎用，但是很多时候，在某些特定的场合下，你不使用这个东西，编程实际上是极其不方便的，所有呢，我们又离不开它。

### 5.继承

#### 继承与派生

继承的基本概念

把所有这些类共性都抽取出来，形成一个抽象的桌子（餐桌、写字台、床头柜），同时它们都从原来那个桌子继承下来，这是一个**非常重要的一个概念**。继承就构造了我们整个类库的各个类之间的层次关系。所谓继承就体现在这里。

餐桌是从桌子继承下来的，所以称餐桌是桌子的派生类，而那个抽象的桌子就是基类（父类）。

－类类型：描述分类的概念
－继承：**描述类之间的血缘（继承）关系**
－基类、派生类
－父类、子类（不恰当的概念；因为在类库层次下，有的时候我们说子类可能是另外一个词，叫subclass，翻译出来也叫子类，它这个写法和它的意义，和我们讲继承的时候这个子类是不一样的，所以未来不引起混淆，最好使用基类和派生类这个概念，一个叫base，一个叫derived，来描述类的继承和层次）

也就是说，在解决实际问题的时候，我声明了这么多类，我们既把它分解开，同时又形成继承的层次，这样的话，构造的类库的框架，它是立体的，它才能够完整地描述我们现实世界中的问题。因为我们现实中的事物事实上是普遍联系的，它们互相之间是构成一个复杂的网状连接关系的。所以没有继承，没有面向对象技术，它实际上就是不完整的，功能是极度受限的。

继承的意义

－派生类拥有基类的全部属性与行为（想取消是不可能的，只能添加新的功能，不能取消已有的功能）
－派生类可以增加新的属性与行为，而不能删除原有的属性和行为（这是继承本身特殊的要求）

#### 单继承

单继承的基本语法格式

－class 派生类名称 : 派生类型保留字 基类名称 { … };

派生类型保留字

－public：基类的public、protected成员在派生类中保持，private成员在派生类中不可见（属于基类隐私）

​		如果你的派生类型是public，称之为公有派生，从基类继承下来的属性尽可能地保留了基类的访问控制规则，原来是public还是public，原来是protected还是，原来是private，那是它的隐私，派生类是没有权利访问基类的私有数据的。

－protected：基类的private成员在派生类中不可见，public、
protected成员在派生类中变为protected成员

－private：基类的private成员在派生类中不可见，public、
protected成员在派生类中变为private成员

所以真实继承的时候，大部分情况下我们使用的都是public。

－在设计类的时候，因为我们需要频繁地在派生类里边访问基类的数据对象，如果每次都是使用存取函数，那个基类里提供的那个公有的存取函数来访问基类的那个对象，很多时候它是不方便的，即使那些函数被你定义成内联的，它也可能是不方便的，所以在这种情况下，我们在定义类的层次的时候，未来解决问题的方便，不用private定义基类的私有数据，而是使用protected定义基类的数据。（设计类时若需要使用继承机制，建议将派生类需要频繁使用的基类数据成员设为protected的）

从某种程度上来讲，它打破了这个类的私有规则，这个方式不是完美无缺的，它实际上是有一点小问题的，可是为了解决问题的方便，很多时候我们习惯于这么做。

**函数覆盖于二义性**

继承的时候有可能导致基类的成员函数和派生类的成员函数具有同名的情况，在这种情况下就有可能发生函数的覆盖，调用的时候有可能会发生二义性，我们在编程的时候必须要能够处理它。

```c++
class Point { void Print(); };
class Point3D: public Point { void Print(); };
Point pt( 1, 2 );
Point3D pt3d( 1, 2, 3 );

调用示例
－pt.Print()：调用Point类的Print成员函数
－pt3d.Print()：调用Point3D类的Print成员函数(继承下来的print函数没有被调用)
－Point类的Print成员函数在Point3D类中仍存在，但被新类中的同名函数覆盖
－访问规则（解析）：pt3d.Point::Print()
```

#### 多继承

C++本身它还提供了特殊的多继承的机制

```c++
多继承的基本语法格式
class 派生类名称: 派生类型保留字 基类名称1, 派生类型保留字 基类
名称2, … { … };
多继承示例
class A { … }; class B { … };
class C: public A, protected B { … };
//在C类里边上来就会放A类的一个存储空间，接下来放B类的存储空间，B类的存储空间是什么呢？B类的存储空间上来就是A类的存储空间，然后是B类新添加的数据成员，在此之后才是C类自己定义的数据成员；所以这里面有A类的数据成员的两个副本，而且第一个副本是公有派生下来的，第二个副本是保护派生下来的，访问控制还不一样，所以这种情况下取的是A类第一个副本呢还是第二个副本呢，你编程的时候就需要特别小心；另外还得问了，保存A类的两个副本有意义吗？大部分情况下，在C类保存A类的两个副本是没有意义的，所以多继承问题很多。
//A类和B类的私有成员在C类里都看不见
class A { … }; class B: public A { … };
class C: public A, protected B { … };
```

多重继承导致的问题比它能够带来的好处还要多，所以我们一定要慎用。理论上一个单继承能够解决我们任何问题，所以使用多继承在绝大多数情况下，其实是毫无必要的，所以不建议同学们在实际编程的时候使用多继承的机制。

它导致的问题就是：

​		一个派生类里面可能包含很多个基类的副本，这些基类副本的位置你没有办法去决定它，因为对于一个单继承来讲，它一个基类的一个数据对象，它的存储布局基本是这样一个模式，按照它的数据成员的顺序，一个接着一个分配好，放在那个地方，构造这个对象的时候就按照这个方式来构造，当我派生的时候，首先会继承基类这些数据成员，它的架构，包括它的存储布局，一模一样地全都继承下来，然后在后边继续添加自己的数据，这就形成一个非常明确不断扩展的数据存储布局；

​		如果多继承，那么它的第二个基类就只能写在第一个基类的后边，第三个基类就写在第二个的后边，这个存储布局，你看上去也是顺序的，但是如果它（注：指基类）有多个副本，就有可能导致它（注：指派生类）在后续某个位置还有基类的数据，访问的时候是非常讨厌的，操作起来很麻烦，一不注意就能搞错，所以大部分情况下我们应该慎用它。

```c++
派生类成员函数名称与基类相同
class A { public: void f(); };
class B { public: void f(); };
class C: public A, public B { public: void f(); };
C c;
调用示例
－c.f()：调用C类的成员函数
－c.A::f()：调用C类继承自A类的函数
－c.B::f()：调用C类继承自B类的函数
//名解析一样是可以工作，但是肯定不像单继承那么方便
```



#### 虚继承

一旦在一个多继承下，派生类就可能保留基类的很多个副本，那我们怎么限制这一点，让它只保留基类的唯一一个副本呢？后续的同样的副本我都删掉了，我不要了，那我们怎么保证这一点呢？那么我们就需要虚继承。

**虚拟继承的目的**

－取消多继承时派生类中公共基类的多个副本，只保留一份

－格式：派生时使用关键字virtual

```c++
使用示例：D中只有A的一份副本
class A { public: void f(); };
class B: virtual public A { public: void f(); };
//virtual写在virtual public A前就表示B类的这一个类的对象上，所有的A类的副本只有一个
class C: virtual public A { public: void f(); };
//C类上所有的A类的副本只有一个
class D: public B, public C { public: void f(); };
//当它继承C类的时候，发现D类已经有了一个A类的副本，那么这个继承的A类的副本就不要了
//virtual 和 pubic这种写法，前后颠倒没关系，它只和多继承有关，对于单继承，因为所有的继承都是单一的一条线，所以它不会产生多继承的情况，基类的副本不会有两个，那么虚继承它就不需要
//你写了虚继承，对C++来讲，需要做一些额外的操作，这个额外的操作实际上是会降低我们程序的效率的
```

#### 派生类的构造函数与析构函数

构造函数的执行顺序

－调用基类的构造函数，调用顺序与基类在派生类中的继承顺序相同（B继承A，C继承B，先调A的构造函数，再调B类的，然后才调C类的构造函数）
－调用派生类新增对象成员的构造函数，调用顺序与其在派生类中的定义顺序相同（如果派生类里你增加了一个数据对象，这个数据对象本身是类的一个对象，那么这个对象也有构造函数）
－调用派生类自己的构造函数

​		如果这些量写在初始化列表里边，它就用初始化列表里面的数据去构造它，最后调用我们的构造函数的函数体。这是派生类的构造函数的执行顺序。

析构函数的执行顺序

－调用派生类的析构函数（先把派生类的新增那些东西给它消掉）
－调用派生类新增对象成员的析构函数，调用顺序与其在派生类中的定义顺序相反（abc都是类的对象，构造的时候按这个顺序，析构的时候就是cba的顺序，一个接着一个来，当把所有这些新增数据成员全部析构之后，它才能调用基类的析构函数）
－调用基类的析构函数，调用顺序与基类在派生类中的继承顺序相反（如果它的继承层次是A、B、C，那么它析构的时候就是C、B、A）

#### 类的赋值兼容性

非常重要！！！因为我们在写面向对象的程序的时候，我们实际上是建构了一个类库的层次，而我们操纵这个类库层次的时候，我们往往会使用指向基类的一个指针或者是一个基类的一个引用。

**公有派生时，任何基类对象可以出现的位置都可以使用派生类对象代替**（这保证了广泛的赋值兼容性，为我们编程提供了极大的灵活性，这是必不可少的一个东西）

涉及到三种情况：

－将派生类对象赋值给基类对象，这个时候它仅赋值它的基类部分，可以赋值但有些信息丢了

－用派生类对象初始化基类对象引用，仅能操作它的基类部分(一样的，一个基类的一个引用它也只能引用它的基类的那一部分的数据，我把一个派生类的对象初始化给它，那它引用的仍然是它的基类的那一小部分，所有的派生类数据它是访问不到的)

－使指向基类的指针指向派生类对象，仅能引领它的基类部分

也就是说，不管怎样，当你把一个派生类的对象赋值为基类对象的时候，要么是赋值基类的部分，要么是只能操作那一部分，要么是只能引领它的那一部分。派生类的那个部分都没有办法去处理的。

保护派生与私有派生本身因为它的访问控制原因不可以直接赋值，所以这种时候它就完全打破了我们类继承的层次它的编程的灵活性，我们在设计这个类库继承层次的时候需要的就是这个**将派生类的对象或派生类的引用或者指向派生类的指针来赋值给一个基类的对象、一个基类的引用，一个指向基类的指针**，如果缺了这个类的赋值兼容性，那么实际上，面向对象的这个继承的架构它的好处已经取消了一大部分，所以真正派生的时候使用保护派生和私有派生场合是极少极少的。

**－尽量不要使用保护派生与私有派生**

所以我们总结：你应该单继承、公有派生。这是写面向对象程序中保证自己不犯错误的最简单的方式。反正这种方式能够解决任何问题，那不就行了嘛。

```c++
#include <iostream> 
#include <string> 
using namespace std; 
class Base 
{ 
public: 
 Base(string s) : str_a(s) { } 
 Base(const Base & that) { str_a = that.str_a; } 
 void Print() const { cout << "In base: " << str_a << endl; } 
protected: 
 string str_a; 
}; 
class Derived : public Base
{ 
public: 
 Derived(string s1,string s2) : Base(s1), str_b(s2) { } 
 // 调用基类构造函数初始化
 // 派生类的形参传给Base(s1)，s1作为Base的形参通过初始化列表构造出str_a
 void Print() const { cout << "In derived: " << str_a + " " + str_b << endl; } 
protected: 
 string str_b; 
};
```

重要的事说三遍：我们的派生类构造函数里，首先要构造它的基类的部分，而这个基类的构造函数怎么构造呢？**就应该写在这个构造函数的初始化列表里，要写在这个类的构造函数的初始化列表里，要写在这个类的构造函数的初始化列表里**。

基类部分构造完，然后构造派生类的自有对象 str_b （注：string是标准模板库里为我们提供的一个类——string类），str_b 倒是可以写在花括号体内，但是会导致两次构造。

> 同样，对派生类进行拷贝构造时，如果想让基类的成员也同时拷贝，就一定要在派生类拷贝构造函数初始化列表中显示调用基类拷贝构造函数。

```c++
int main() 
{ 
 Derived d1( "Hello", "World" ); 
 Base b1( d1 ); // 拷贝构造，派生类至基类，仅复制基类部分
 d1.Print(); // Hello World
 b1.Print(); // Hello
 Base & b2 = d1; // 引用，不调用拷贝构造函数，仅访问基类部分
 d1.Print(); // Hello World
 b2.Print(); // Hello
 Base * b3 = &d1; // 指针，不调用拷贝构造函数，仅引领基类部分
 d1.Print();
 b3->Print(); 
 return 1; 
}
```

### 6.多态

多态其实就是一种物体的几种不同的形态，所以叫多态。听上去很高级，多态是非常重要的一个概念，**想写好程序，不理解多态性肯定是不行的**。但实际上，这个概念我们一直在用，而我们压根就没有注意到。

首先，你从小学开始，你用到的那个操作就是多态的，比如说加法，开始学1+1=2，后来你学1.0+2.0=3.0，先学了整数加法后来你学了小数加法，后来学了整数和小数的加法，再后来你又学了代数的加法，又学会抽象代数的加法，所有的这些操作，这个加法操作本身实际上就是多态的。就一个加法符号，我们其实把它理解成多态的一个加法操作，它在整数加法，小数加法，代数加法，它的做法可能都是不一样的，这个其实就叫多态，到我们计算机里边，那更是完全不一样了，因为整数加法指令是整数加法指令，小数加法指令是小数加法指令，那是两个不同的指令，同样的一个加法操作，是会翻译成两条不同指令的，压根就不是一回事，所以那个加法一定是个多态的。

多态性

－目的：让不同对象在接收到相同消息时能够进行不同的响应
－现象：对应同样成员函数名称，它在不同的基类和派生类里面执行不同函数体

#### 多态性的实现

－虚函数：使用virtual关键字声明**成员函数**（就让成员函数成为多态的；注意**多态性只影响函数**，数据成员不存在多态这个概念，因为成员函数对应的是操作，成员函数将成为一个虚函数，维持它的多态性，这个维持是指从这个类把这个函数定义成虚函数之后就开始了，它的派生类里不管这个同名的函数有没有写virtual，它也是virtual的，也就是说一日为virtual终生为virtual，）

－声明格式：virtual 函数返回值 函数名称(参数列表);

在函数实现的时候不需要写virtual。

非虚函数示例：处理的是一个银行的账户（银行账户分两类，一个是储蓄账户，定期存款啊、活期存款啊；另一个是给予你做结算的目的的，主要是企业在用的那种结算的账户，和储蓄账户不一样）

```c++
// 头文件
//它们两个是不同的账户，但是它们是相关的，所以我们要定义一个账户的基类。
#include <iostream>
using namespace std;
class Account
{
public:
 Account( double d ) : _balance(d) { }
 //构造函数直接写函数体的也被内联了
 double GetBalance() const;
 void PrintBalance() const;
private:
 double _balance;
 //表示这个账户的余额
};
inline double Account::GetBalance() const
{
 return _balance;
}
```

```c++
class CheckingAccount : public Account
{
public:
 CheckingAccount(double d) : Account(d) { }
 void PrintBalance() const;
};
class SavingsAccount : public Account
{
public:
 SavingsAccount(double d) : Account(d) { }
 void PrintBalance() const;
};
```

```c++
// 源文件
void Account::PrintBalance() const
{
 cerr << "Error. Balance not available for base type." << endl; 
}
//标准账户因为它是一个抽象的账户，所以实际上我们在Account这个账户上PrintBalance想打印余额实际上是不可以打印的。所以我们cerr直接向标准错误流里输出“余额不可用”信息就完了。
void CheckingAccount::PrintBalance() const
{
 cout << "Checking account balance: " << GetBalance() << endl; }
void SavingsAccount::PrintBalance() const
{
 cout << "Savings account balance: " << GetBalance() << endl; }
```

接下来看看怎么使用

```c++
int main()
{
 CheckingAccount * checking = new CheckingAccount( 100.00 ) ;
 SavingsAccount * savings = new SavingsAccount( 1000.00 );
 Account * account = checking;
 //用结算账户初始化我们的一个抽象账户
 //checking为指向派生类的指针，赋值给指向基类的指针
 account->PrintBalance();
 account = savings;
 account->PrintBalance();
 delete checking;
 delete savings; 
 return 0; 
}
//显然打印出来的都是cerr的信息
//但是我们要的是如果account是一个指向基类的指针，那么当我们用它指向派生类的时候，我们应该调用派生类的那个成员函数，把它的余额打印出来。而不是调用基类的那个函数。当在非虚函数情况下，这个工作是做不了的，所以我们必须使用虚函数。
```

虚函数示例

```c++
// 头文件
#include <iostream>
using namespace std;
class Account
{
public:
 Account( double d ) : _balance(d) { }
 double GetBalance() const;
 virtual void PrintBalance() const;
 //并不需要改变_balance的值，所以它本身是个const
private:
 double _balance;
};
inline double Account::GetBalance() const
{
 return _balance;
}
```

```c++
class CheckingAccount : public Account
{
public:
 CheckingAccount(double d) : Account(d) { }
 virtual void PrintBalance() const;
 //虽然不加virtual它也是virtual了，但是建议写上，这样一看就很清楚了
};
class SavingsAccount : public Account
{
public:
 SavingsAccount(double d) : Account(d) { }
 virtual void PrintBalance() const;
};
```

这样按之前的主函数调用就可以实现我们想要的功能了。

account是个基类指针，如果它指向基类，它就调用基类的PrintBalance，如果指向派生类就调用派生类的函数，不管那个派生类是CheckingAccount还是SavingsAccount，总之那个派生类是哪一个它就调用哪一个类的对应虚函数。很明确吧，这个就叫自适应。它能够自动适应它所指向的目标类。它自然就体现出了多态。**这就是虚函数最重要的一个地方**。

另外，如果基类里有一个虚函数，你的派生类里不想动它，你可以不写，因为派生类自动地能够继承基类的全部数据对象和成员函数，所以那个基类的虚函数自动地在你的派生类中就存在了。

在C++里这是怎么实现的呢？

​		C++代码里边它会为每一个这样的类的一个对象，维持着一个虚拟表，我们称为虚拟表的指针，用一个虚拟表的指针指向这样的一个虚表，每一个虚表里就会记录你这个类所实现的所有的虚函数的入口地址，当它是一个基类的时候，它就把基类的虚函数的入口地址写进去，如果它是派生类，它就把派生类的虚拟函数的基地址写进去。当你构造的是一个派生类的对象的时候，它写的实际上是派生类的那个虚函数的入口地址，所以即使你是使用一个指向基类的指针指向这个派生类的对象，当它调用那个虚函数的时候，它一查那个虚拟表，查到的依然是派生类的那个虚函数的入口地址，所以我们指向基类的那个指针才能够调用派生类的虚函数。

通过示例可以发现：

关于多态【接口和实现分离，父类指针指向子类的实例，然后通过父类指针调用子类的成员函数，这样可以让父类指针拥有多种形态，所以称之为多态】

#### 纯虚函数

刚才的那个例子，Account账户本身实际上充当的是一个抽象的账户，也就是说实际上在它里面打印一个余额是没有意义的，因为不管怎样，它要么是结算账户要么是储蓄账户，实际程序运行过程中不存在既不属于储蓄账户也不属于结算账户的抽象账户，我们也许会有一个这样的指针也许会有这样一个引用量，但是一定没有真实的Account账户的存在，我们不会构造它的，这点很重要！我们要构造的要么是结算账户要么是储蓄账户，不会构造一个抽象的Account账户，它只是表达我们整个类库设计的时候最顶层的抽象的一个模式，表示所有的账户类的最顶层的共性。所以为它实现PrintBalance是没有意义的，就像我们的代码中，我实际上是向标准错误流里输出一串信息，并不是真正地输出它的账户余额信息。

明确了这一点，我们就不该实现基类的这个函数，实现了也没有意义，反正我们也不会调用它，那么怎么办呢？

​		C++为我们提供了一个纯虚函数的机制来实现它。

**纯虚函数**

－充当占位函数，没有任何实现

－派生类负责实现其具体功能

－声明格式：virtual void f( int x ) = 0;（初始化为0其实就是个NULL，就表示这个函数将没有任何实现，这个函数没有代码体，但不是只声明不定义，只声明不定义它也叫没有，但是编译器---如果你调用它的时候，就会告诉你它有问题，因为那个函数不存在，调用就出错，编译通不过；纯虚函数编译器也会告诉你不能调用，但是实际上这个函数的指针是存在的，在这个对象的虚拟表里边，f这个函数的虚拟表指针---虚函数指针是存在的，只不过那里被填了0，表示这个函数入口地址是0，函数本身不存在，但是这个指针是存在的）

**抽象类**

－所有带有纯虚函数的类在C++里都叫纯虚类，更一般地我们其实应该称它为抽象的类。因为我们绝不可能构造这样类的一个对象。语言机制不允许的，因为里面有一个函数没实现。这样的话就是一个抽象的一个类。

－最主要的目的是作为类继承层次的上层，一般来讲是最上层，也可能如果下一层需要抽象，它还可以是个抽象类。也就是说，它往往都位于类库层次的顶层。它形成的是一个抽象的机制，它不承担实际的工作，这个就叫抽象类。**对于类库的程序设计是非常非常有用的**！

**虚析构函数**

**－保持多态性需要虚析构函数，以保证能够正确释放对象**（保持整个类的多态性的一个最基本的需要，我们需要用到它，如果是一个非虚的，它实际上就和特定的类是相关的了，**当你在指向基类的一个指针上，去销毁它的派生类的那个对象的时候**，那么实际上是没有办法正确销毁的，所以析构函数往往都是虚的）---保证指向基类的指针能够操作派生类的对象的销毁

示例：

```c++
// “Point.h”
#include <iostream>
using namespace std;
class Point
{
public: 
 Point() { }
 virtual void Print() const = 0;
// virtual ~Point();
};

//真正抽象的一个点应该是0维的点，所有的属性都不存在。那么对于这样的一个类来讲，如果我想定义它的一个Print成员函数，显然我不知道该写什么，其实就是我什么都不应该写，我把Print定义成纯虚函数，这样Point就是一个纯虚类，它就是足够抽象的一个顶层逻辑。所有的点都将从我们的class Point派生下去。对于点库的继承层次来讲，Point就是它们唯一的根。
```

```c++
class Point2D : virtual public Point
//虚继承，单根的话，virtual不写也没问题
{
public: 
 Point2D( int x = 0, int y = 0 ) : _x(x), _y(y) { }
 Point2D( const Point2D& pt2d ) : _x(pt2d._x), _y(pt2d._y) { }
 int GetX() const { return _x; }
 void SetX( int x ) { _x = x; }
 int GetY() const { return _y; }
 void SetY( int y ) { _y = y; }
 virtual void Print() const;
protected:
 int _x, _y;
};
```

```c++
class Point3D: virtual public Point2D
{
public:
 Point3D( int x = 0, int y = 0, int z = 0 ) : Point2D(x,y), _z(z) { }
 Point3D( const Point3D& pt3d ) : Point2D(pt3d._x, pt3d._y), _z(pt3d._z) { }
 //这个地方写成Point2D(pt3d)更好理解，是对的；上面那个也是对的，不好理解
 int GetZ() const { return _z; }
 void SetZ( int z ) { _z = z; }
 virtual void Print() const;
protected:
 int _z;
};
```

```c++
// “point.cpp”
void Point2D::Print() const
{
 cout << "( " << _x << ", " << _y << " )";
}
void Point3D::Print() const
{
 cout << "( " << _x << ", " << _y << ", " << _z << " )";
}
// “main.cpp”
int main()
{
 Point * pt1 = new Point2D( 1, 2 );
 //创建一个二维的点对象，它的内存是动态分配的，把它的地址传给pt1。
 Point * pt2 = new Point3D( 1, 2, 3 );
 pt1->Print();
 pt2->Print();
}
//如果写了虚析构函数，那么你在pt1上面删除和pt2上面删除都是它对应的二维点和三维点的那个对象。
//派生类虚函数实现的时候const也得加上，老师课件里没有，编译出错
```

## 十.操作符重载

### 1.四则运算符重载

```c++
设计一个数偶类，定义专用的四则运算
// 数偶是一个包含两个元素的特殊的数据结构，这样的两个数据我们往往是以成对的方式来操纵和访问的。在C++的标准模板库里，事实上替我们提供了一个类似的概念，它称之为pair，我们这里使用Couple。
//四则运算加减乘除余总共5个，这里只以+和*举例说明
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b) { }
 Couple operator+( const Couple & c );
 //operator+就是这个加法操作符的函数的名字，+前要有operator表示它是一个操作符，括号里要提供这个操作符的参数，对加法来讲，它实际上是带了两个成员，左操作数就是this指针所指向的那个对象，而右操作数就是我们提供的这个参数。
 Couple operator*( const Couple & c );
private:
 int _a, _b;
};
```

```c++
Couple Couple::operator+( const Couple & c )
{
 Couple _t( this->_a + c._a, this->_b + c._b );// 构造一个新的Couple对象
 return _t; // 返回这个对象
}
Couple Couple::operator*( const Couple & c )
{
 Couple _t( this->_a * c._a, this->_b * c._b );
 return _t;
}
int main()
{
 Couple a( 1, 2 ), b( 3, 4 ), c, d;
 c = a + b; // 等价于 c = a.operator+(b) ==> c( 4, 6 )，括号里的参数b当然接受的实际上是b的一个常引用
 d = a + b + c; // 等价于 d = a.operator+(b).operator+(c) ==> d( 8, 12 )
 c = a * b; // 等价于 c = a.operator*(b) ==> c( 3, 8 )
 return 0;
}

//在c++的内部实现中，加法操作并没有应用到我们自己定义的Couple类上，我们要想让加法能够在我们的Couple类上工作，那么我们就必须在Couple类上重载operator+；如果你提供一个成员函数名字叫Add，可以不，可以。但是我们有了重载的加法操作，我就可以让Couple这两个对象看上去就像普通的数学运算一样，就用数学的加法就把它们加在一起了。这多方便啊，对于这个对象的使用者，对于这个类的使用者来讲，你这个类库的架构别人用起来就非常方便。重载操作符的目的其实就在这里，
```

**问题一：假设需要数偶倍乘运算（标量运算），将整数k同时乘到两个成员上。如何实现？**

为什么要用标量乘，因为我要模拟两个同样的数偶的加法。

```c++
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b) { }
 Couple operator*( const int & k );
private:
 int _a, _b;
};
Couple Couple::operator*( const int & k )
{
 Couple _t( this->_a * k, this->_b * k );
 return _t;
 // 这里为啥是const int & k 其实前面引用那部分我也提到了“初始化常量引用时允许用任意表达式作为初始值”
}
```

```c++
int main()
{
 int k = 3;
 Couple a( 1, 2 ), b( 3, 4 ), c, d;
 c = a + b; // 等价于 c = a.operator+(b) ==> c( 4, 6 )
 d = a + b + c; // 等价于 d = a.operator+(b).operator+(c) ==> d( 8, 12 )
 c = a * b; // 等价于 c = a.operator*(b) ==> c( 3, 8 )
 c = c * k; // 等价于 c = c.operator*(k) ==> c( 9, 24 )
 d = d * 2; // 等价于 d = d.operator*(2) ==> d( 16, 24 )
 return 0;
}
```

**问题二：参数必须是Couple类对象的常引用吗？**

- 可以不使用引用，但会产生对象拷贝动作，降低效率（如果你不使用引用，就会产生一个值传递，在C++语言里实际上就两种参数传递方式，一个值传递，一个引用传递，一个值传递就会产生一个拷贝动作，它要把实际参数的值拷贝给形式参数嘛，值拷贝动作，当数据对象很小的时候没关系，如果是个大对象，这个拷贝就会极大地消耗CPU的时间，降低程序效率)
- **可以不是常引用，但无法限制函数内部对参数的修改**（在这个函数体内部就有可能**通过那个引用修改那个目标对象的值**，不是常引用是有可能修改目标对象的值的，这是一个非常重要的设定；如果你的成员函数里并不需要修改目标对象的值，这个引用就必须设定成const Couple，而不能设定为Couple&）
- （可不可以使用指针作为函数参数呢？）可以使用指针，但与常规数学公式使用方式不符（真实的操作符重载我们从不传递指针，它和数学语义不吻合，这在重载操作符中是大忌）

**问题三：返回值必须是Couple类的对象吗？返回引用是否可行？**

- 可以返回引用，但必须是全局对象或通过参数传递进去的Couple对象的
  引用，不能引用函数内部的局部变量（在函数内部可以访问的并且在这个函数结束之后仍然存在的一个对象）
- **不建议使用引用类型的返回值** （普通四则运算不建议）
- 需要将右操作数累加到左操作数上并返回左操作数时就应该使用引用作为函数的返回值了，此时应该重载加赋等操作符，减赋、乘赋、除赋与余赋类似

**问题四：四则运算符必须重载为成员函数吗？**

​		不。可以重载为类的友元函数或普通函数。注意：普通函数无法访问类的私有成员。

​		**建议重载为友元函数**

**重载为友元函数**

优势：显式具有**双操作数**（左右操作数你都要作为参数传进去），且**格式一致**（成员函数的时候左操作数为指针，右操作数为引用，现在变为双操作数都是以引用的形式传进去）；操作不局限于当前对象本身，且**不要求左操作数必须为本类的对象**

劣势：显式具有双操作数，不能省略左操作数

```c++
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b) { }
 friend Couple operator+( const Couple & c1, const Couple & c2 );
 friend Couple operator*( const Couple & c1, const Couple & c2 );
 friend Couple operator*(const Couple & c, const int & k );
 friend Couple operator*( const int & k, const Couple & c );
private:
 int _a, _b;
};
//重载的操作符不并天然地支持我们的乘法交换律
```

```c++
Couple operator+( const Couple & c1, const Couple & c2 )
{
 Couple _t(c1._a + c2._a, c1._b + c2._b );
 return _t;
}
Couple operator*( const Couple & c1, const Couple & c2 )
{
 Couple _t( c1._a * c2._a, c1._b * c2._b );
 return _t;
}
Couple operator*( const Couple & c, const int & k )
{
 Couple _t( c._a * k, c._b * k );
 return _t;
}
Couple Couple::operator*( const int & k, const Couple & c )
{
 Couple _t( k * c._a, k * c._b );
 return _t;
}
```

```c++
int main()
{
 int k = 3;
 Couple a( 1, 2 ), b( 3, 4 ), c, d;
 c = a + b; // 等价于 c = operator+(a, b) ==> c( 4, 6 )
 d = a + b + c; // 等价于 d = operator+(operator+(a, b), c) ==> d( 8, 12 )
 c = a * b; // 等价于 c = operator*(a, b) ==> c( 3, 8 )
 c = k * c; // 等价于 c = operator*(k, c) ==> c( 9, 24 )
 d = 2 * d; // 等价于 d = operator*(2, d) ==> d( 16, 24 )
 return 0;
}
```

数偶倍乘运算重载的说明

- 应重载为类的友元函数
- 若非友元函数，当倍数为左操作数时，无法解析乘法运算，编译会出错
- 将左操作数k转换为Couple类的对象可以解决上述问题，但意义已不同
- 上述转换要求提供一个单参数的从整数到Couple类的构造函数，如果使用explicit修饰该构造函数，隐式类型转换会被禁止；虽然即使不禁止，很多编译器也不进行此转换
- 左右操作数不可互换，重载函数必须提供两个版本，它们的函数签名不同

### 2.关系操作符的重载

为数偶定义专用的关系操作符

​	这里以等于和不等于为例

```c++
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b){ }
 friend bool operator==( const Couple & c1, const Couple & c2 );
 friend bool operator!=( const Couple & c1, const Couple & c2 );
private:
 int _a, _b;
};
```

```c++
bool operator==( const Couple & c1, const Couple & c2 )
{
 return (c1._a == c2._a) && (c1._b == c2._b);
}
bool operator!=( const Couple & c1, const Couple & c2 )
{
 return (c1._a != c2._a) || (c1._b != c2._b);
}
int main()
{
 Couple a( 1, 2 ), b( 3, 4 );
 if( a == b ) 
 	cout << "a == b" << endl;
 else
 	cout << “a != b" << endl;
 return 0;
}
```

### 3.下标操作符重载

**下标操作符重载的场合与目的**

如果对象具有**数组成员，且该成员为主要成员**，可以重载下标操作符

\- **目的：以允许在对象上通过数组下标访问该数组成员的元素**

**下标操作符必须重载两个版本**

常函数版本用于处理常量

**数组下标越界错误**

\- **可以在重载函数中处理数组下标越界错误，或使用异常处理机制**

为数偶类定义专用的下标操作符

```c++
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) { _a[0]=a, _a[1]=b; }
 int & operator[]( int index );
 const int & operator[]( int index ) const;
 //当它是常函数的时候，返回的是const int &
private:
 int _a[2];
};
```

```c++
int & Couple::operator[]( int index )
{
 if( index < 0 || index > 1 )
 	throw std::out_of_range( "Index is out of range!" );
    //throw是c++为我们提供的异常处理机制，std::out_of_range,这是c++标准库里替我们定义好的一个异常类
 return _a[index];
}
const int & Couple::operator[]( int index ) const
{
 if( index < 0 || index > 1 )
 	throw std::out_of_range( "Index is out of range!" );
 return _a[index];
}
int main()
{
 Couple a( 1, 2 ), b( 3, 4 );
 cin >> a[0] >> a[1];
 cout << b[0] << " " << b[1] << endl;
 return 0;
}
//重载后就可以直接像数组一样操纵这个类的一个对象。明明是一个对象，但是看上去就像一个数组一样。
//如果一个对象被你构造出来后，它的主要行为像一个数组，其实你就应该提供一个小标操作符。如果不是，就不应该提供，因为你会让这个类库的使用者误以为它是一个数组。
//下标操作符不是必须要存在的操作符
//如果私有成员提供的不是数组，而是int _a,int_b;同样可以通过数组访问，相应的函数体也有变化，根据对应的索引返回对应的值，语句相对就长一点。
//所以重要的是我们能够通过这个方式“[]”重载让类库的使用者以一个和数组相一致的方式来访问我们这个类中的数据成员。
```

### 4.赋值操作符

#### 赋值操作符的一般形式

和以前的几种操作符的重载都不太一样，它最重要的一个地方就是将要返回对本对象的一个引用。赋值嘛，就是要把另外一个数据传给我们这个当前的对象。

当我们把赋值操作符重载为类的成员函数的时候，它的this指针将指向我们这个本对象，而本对象将接受别的对象的值，这是赋值操作最基本的语义。所以我们重载赋值操作符的时候我们应该返回当前对象的一个引用。这样能保证连续赋值的机制能够工作。这是非常重要的一个设计细节。

```c++ 
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b){ }
 Couple( const Couple & c ) : _a(c._a), _b(c._b){ }
 Couple & operator=( const Couple & c );
private:
 int _a, _b;
};
```

```c++
Couple & Couple::operator=( const Couple & c )
{
 if( *this == c ) 
     //这里为啥可以这样判断？
 	return *this;
 _a = c._a, _b = c._b;
 return *this;
}
int main()
{
 Couple a( 1, 2 ), b( 3, 4 );
 cout << a << endl;
 a = b; 
 cout << a << endl;
 return 0;
}
```

赋值它其实就是一个拷贝，它把另外一个对象拷贝给我们这个本对象。

在某些场合，不判定两个对象是不是相等，就直接拷贝其实更合适。因为大多时候两者不相等，如果涉及到需要频繁拷贝的时候，条件判定反而降低程序效率。

#### 复合赋值操作符重载

加赋、减赋、乘赋、除赋、余赋。其实还有。

```c++
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b){ }
 Couple( const Couple & c ) : _a(c._a), _b(c._b){ }
 Couple & operator+=( const Couple & c );
 Couple & operator*=( const Couple & c );
 Couple & operator*=( const int & k );
private:
 int _a, _b;
};
```

```c++
Couple & Couple::operator+=( const Couple & c )
{
 _a += c._a, _b += c._b;
 return *this;
}
Couple & Couple::operator*=( const Couple & c )
{
 _a *= c._a, _b *= c._b;
 return *this;
}
Couple & Couple::operator*=( const int & k )
{
 _a *= k, _b *= k;
 return *this;
}
```

**递增递减操作符重载**

单独列出来，因为"++"、"--"都涉及到对当前对象做一个加法或减法，它实际上也涉及到对本对象值的修改。所以它仍然算是一种广义的赋值。

```c++
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b){ }
 Couple( const Couple & c ) : _a(c._a), _b(c._b){ }
 Couple & operator=( const Couple & c );
 Couple & operator++(); // 前缀递增，返回本对象的一个引用
 Couple operator++( int ); // 后缀递增
 //int 后面跟着的那个参数我们从来不用，它是那个操作符第二个操作数，有吗？没有。写它的唯一目的是为了区分它和前缀操作符。
 //返回本对象的一个拷贝
private:
 int _a, _b;
};

//“++”操作符、“--”操作符，前缀、后缀的原始实现就是按照这个语义来实现的。所以当你重载的时候一定要维持这些操作符的原始的语义不变。
```

```c++
Couple & Couple::operator++()
{
 ++_a, ++_b;
 return *this;
}
Couple Couple::operator++( int t )
{ 
 Couple _t( *this );
 //用*this去拷贝构造它
 _a++, _b++;
 return _t;
 //返回原始对象的一个拷贝，这才能保证“++”操作符的运算将在我们这个表达式中，其它的表达式、操作符都算完了，它才最后算，先参与运算后递增递减。
}
```

**除后缀递增递减操作符，其它应返回对象的引用**，以与C++本身语义相符

\- **返回对象需要额外的对象构造，降低效率**（当这个对象尺寸很大的时候）

如果不需要使用返回值以进行连续赋值（c=b=a），可以将返回值设为void，但要注意此时重载的操作符语义与C++不符，不推荐

#### 赋值构造与拷贝构造

**赋值也是构造**

拷贝、赋值与析构三位一体，**一般同时出现**（如果你提供了一个拷贝构造函数，提供了一个赋值构造函数，也就是我们的赋值操作符重载，可以称之为赋值构造，那么理论上你应该同时提供析构函数；这三个往往同时出现或都不出现）

​	缺省情况下，编译器会给你自动生成拷贝构造函数、赋值操作符、析构函数，**缺省的都为浅拷贝** 

​	如果对象没有指针成员，缺省行为即可满足要求，无需实现或重载	这三个函数

​	如果对象有指针成员，并且涉及到动态内存分配的问题，一般需要重载这三个函数

```c++
class A
{
public:
 A() : _n(0), _p(NULL) { }
 explicit A( int n ) : _n(n), _p(new int[n]) { }
 A( int n, int * p ) : _n(n), _p(p) { }
 A( const A & that ) : _n(that._n), _p(that._p) { }
 A & operator=( const A & that ) { _n = that._n, _p = that._p; return *this; }
 virtual ~A() { if(_p){ delete[] _p, _p = NULL; } }
public:
 int & operator[]( int i );
 const int & operator[]( int i ) const;
private:
 int _n;
 int * _p;
};
```

**补充：**

explict关键字

C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发zhi生。声明为explicit的构造函数不能在隐式转换中使用。

C++中， 一个参数的构造函数， 承担了两个角色。 1 是个构造器 2 是个默认且隐含的类型转换操作符。
所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA**单参数构造器**的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。
这样看起来好象很酷， 很方便。 但在某些情况下（见下面权威的例子）， 却违背了我们（程序员）的本意。 真是成也萧何， 败也萧何。 这时候就要在这个构造器前面加上explicit修饰， 指定这个构造器只能被明确的调用，使用， 不能作为类型转换操作符被隐含的使用。 呵呵， 看来还是光明正大些比较好。

```c++
class Test1
{
 public:
 	Test1(int n) { num = n; } //普通构造函数
 private:
 	int num;
 };
class Test2
 {
 public:
 	explicit Test2(int n) { num = n; } 
 	//explicit(显式)构造函数
 private:
 	int num;
 };

 int main()
 {
 Test1 t1 = 12; //隐式调用其构造函数, 成功
 Test2 t2 = 12; //编译错误,不能隐式调用其构造函数
 Test2 t3(12); //显示调用成功
 return 0;
 }
```

普通构造函数能够被隐式调用。而explicit构造函数只能被显示调用。

> ```c++
> class Stack {
> explicit Stack(int size);
> ..
> }
> explicit 表示禁止从类型int到类型Stack的隐式转换:
> Stack s1(40); // OK
> Stack s2 = 40; // Error
> ```
>
>
> 推荐C++ 语言作者写的书《C++程序设计语言》，关于C++ 这门语言，你想知道的里面几乎都有哈！

#### 浅拷贝与深拷贝

浅拷贝拷贝指针，使b与a指向同一块内存区域，深拷贝要拷贝完整的副本，不仅拷贝指针，还拷贝指针所指向的目标数据对象的一个副本，然后指针各自指向自己的目标数据对象内存区域。

深拷贝：

```c++
class A
{
public:
 A() : _n(0), _p(NULL) { }
 explicit A( int n ) : _n(n), _p(new int[n]) { }
 A( int n, int * p ) : _n(n), _p(p) { }
 A( const A & that );
 A & operator=( const A & that );
 virtual ~A() { if(_p){ delete[] _p, _p = NULL; } }
public:
 int & operator[]( int i );
 const int & operator[]( int i ) const;
private:
 int _n;
 int * _p;
};
```

```c++
A::A( const A & that )
{
 this->_n = that._n;
 _p = new int[_n];
 for( int i = 0; i < _n; i++ )
 _p[i] = that._p[i];
}
A & A::operator=( const A & that )
{
 this->_n = that._n;
 if( _p )
 delete[] _p;
 _p = new int[_n];
 for( int i = 0; i < _n; i++ )
 _p[i] = that._p[i];
 return *this;
}
```

拷贝构造与赋值构造的区别：

1)拷贝构造函数无返回值，赋值构造（赋值操作符的重载）返回 *this；2)当我进行赋值操作的时候，事实上意味着我们的本对象已经存在了，那么它的_p就有可能指向一个有意义的数组，而这个数组在我们赋值操作后它就没有意义了，我们必须构造一个跟that那个对象一模一样的数组才成对吧，所以在new int[ _n ]之前你必须销毁 _p 所指向的那个目标数组。

#### 移动语义（C++11）

主要是解决深拷贝和浅拷贝的一些问题

深拷贝往往意味着我们要重新构造一片存储区，而且目标对象它的原始那片存储区往往又需要销毁，这里边频繁地产生动态的内存分配与销毁的动作，要分配一片内存，后来又不用了，销毁，又分配一片内存，又不用了。很多时候分配、销毁的工作完全是无用功。

要求拷贝构造和赋值构造的时候，目标数据对象的所有权必须移交给我们的新对象。

要想了解移动语义，必须了解几个概念

1）左值与右值

C原始定义
- 左值：可以出现在赋值号左边或右边的数据和数据对象
- 右值：只能出现在赋值号右边

C++定义

- 左值：**用于标识非临时对象或非成员函数的表达式**

  ​		因为在C里边没有引用传递，所以函数是不能返回一个引用的，函数不能返回引用，那它函数的返回值就是不可以用的，那么这样一个函数它事实上不具有左值。我们可以取到那个函数的入口地址，但是那个函数不能出现在赋值号的左边；有了引用传递后就可以为左值了。

- 右值：用于标识临时对象的表达式或与任何对象无关的值
（纯右值），或者用于标识即将失效的对象的表达式（失效值）

值和地址与我们这里讲的左值和右值具有极大的相关性，但并不是一个东西，我们说的值和地址，是指从程序运行的这个角度来看的，值是在内存的某个地方的里面的一个东西，而地址呢，是放东西的内存区域的编号；而左值和右值，实际上是编译器对待我们标识符的角度来看的，当它认为这样一个标识符可以出现在赋值号左边或右边的时候那么必须把它作为一个左值来对待，当它是个右值的时候它就只能出现在赋值号的右边。左值的意思是它可以被修改，右值比如一个整数一个字符它是不能被赋值的。

```
x = x；
1.取左边x的左值；
2.取右边那个x的左值（取到了x这个量所对应的地址）；
3.然后去右边x的地址去取x的右值，即x的值，然后把x的值赋值给x，也就是把这个值重新放到这个内存区域里面去；
其实我们的C编译器还做了最后一步动作
4.把这个刚刚放进去的那个值作为赋值表达式的结果返回
```

2）左值引用与右值引用

引入引用传递之前，C/C++只有值传递一种，哪怕你使用指针作为函数参数传递，**传递的仍然是那个指针对象的值**，这点一定要记住，它仍然是值传递！有了引用传递，传递的就不是值了，而是目标数据对象的一个引用，引用在函数内部只是充当那个目标数据对象的别名，访问的其实就是原始的目标数据对象，这在C++11出现之前，这样的引用事实上我们传递那个目标数据对象的左值，所以叫左值引用。

为了支持移动语义，我们需要使用一个与原先的左值引用不同的架构，这个架构我们现在称之为右值引用。

左值引用：&
右值引用：&&

左值引用是为了修改目标数据对象的值，是为了一个数学相一致的方式去访问目标数据对象，那么为什么又需要右值引用呢？

- 深拷贝需要频繁分配和释放内存，效率较低
- 移动语义的目的：所有权移交，不需要重新构造和析构 
- 为与构造函数兼容，移动语义必须为引用，而不能是指针或普通量 
- 普通引用传递左值，以允许函数内部修改目标数据对象
- 为区分左值引用，实现移动语义时必须传递右值引用
- 为保证能够修改目标数据对象，**在函数内部必须将右值引用作为左值引用对待**

3）移动赋值与移动构造

```c++
class A
{
public:
 A() : _n(0), _p(nullptr) { }
 explicit A( int n ) : _n(n), _p(new int[n]) { }
 A( int n, int * p ) : _n(n), _p(p) { }
 A( A && that );
 A & operator=( A && that );
 virtual ~A() { if(_p){ delete[] _p, _p = nullptr; } }
public:
 int & operator[]( int i );
 const int & operator[]( int i ) const;
private:
 int _n;
 int * _p;
};
```

```c++
A::A( A && that )
{
 // nullptr：C++11预定义的空指针类型nullptr_t的常对象
 // 可隐式转换为任意指针类型和bool类型，但不能转换为整数类型，定义它的目的是为了取代NULL这个宏
 _n = that._n, _p = that._p, that._n = 0, that._p = nullptr;
 // *this = that; // 此代码不会调用下面重载的赋值操作符函数
 // 具名右值引用that在函数内部被当作左值，不是右值
 // 左值不能传给右值引用，参数类型不匹配，编译器报错，除非你实现了一个左值引用版本，但是实现左值引用不就是深拷贝嘛，它就不是我们的移动拷贝了
    
 // 匿名右值引用才会被当作右值；理论上如此……
 // *this = static_cast<A &&>( that ); // 等价于 *this = std::move( that );
 // 上一行代码可以调用下面重载的移动赋值操作符，但是有可能导致程序崩溃
// 因this指向的本对象可能刚刚分配内存，_p字段所指向的目标数据对象无定义
}
A & A::operator=( A && that )
{
 if( _p ) delete[] _p; // 删除此行代码可能会导致内存泄露
 // 可以测试是否为同一对象，以避免自身复制操作，但意义不大
 _n = that._n, _p = that._p, that._n = 0, that._p = nullptr;
 return *this;
}
```

4）移动语义的成员函数重载的方式

```c++
class A
{
public:
 A() : _n(0), _p(nullptr) { }
 explicit A( int n ) : _n(n), _p(new int[n]) { }
 A( int n, int * p ) : _n(n), _p(p) { }
 // 可以同时提供拷贝语义与移动语义版本，前者使用常左值引用
 // 不能修改目标数据对象的值，后者则可以修改
 A( const A & that );
 // 左值引用版本完成我们的深拷贝语义
 A( A && that );
 // 右值版本完成我们的移动语义，右值引用是需要修改哪个目标数据对象的值的，所以不传const A &&
 A & operator=( const A & that );
 A & operator=( A && that );
 virtual ~A() { if( _p ) { delete[] _p, _p = nullptr; } }
 ……
};
```

```c++
int main()
{
 A a( 4 );
 for( int i = 0; i < 4; i++ )
 a[i] = i + 1;
 A b( a ); // 调用拷贝构造版本
 b = a; // 调用普通赋值版本
 // 把左值引用转换为右值引用，否则会调用左值版本
 A c( static_cast< A && >( a ) ); // 调用移动构造版本
 c = static_cast< A && >( a ); // 调用移动赋值版本
 return 0;
}
```

#### 移动语义再认识

一、如果我真的只需要实现刚才例子里的那个移动语义，其实左值引用就可以完成，因为引用本身就意味着可以修改目标数据对象的值，移动语义的目的，不就是把那个东西拷贝过来，同时把那个指针（那个所有权）给我转交过来嘛，我之所以在左值引用参数列表里面前面加一个const A &，变成对一个const A的一个引用（左值引用），目的无非是表明我这个函数内部不想修改它，如果你想修改它，把const去掉不就完了。而我们的移动赋值、移动拷贝要的不就是修改嘛。

```c++
左值引用同样可以实现移动语义
class A
{
public:
 A() : _n(0), _p(nullptr) { }
 explicit A( int n ) : _n(n), _p(new int[n]) { }
 A( int n, int * p ) : _n(n), _p(p) { }
 A( A & that ); // 重载非常量版本；移动构造语义
 A( const A & that ); // 重载常量版本；深拷贝构造语义
 A & operator=( A & that ); // 重载非常量版本；移动赋值语义
 A & operator=( const A & that ); // 重载常量版本；深拷贝赋值语义
 virtual ~A() { if(_p){ delete[] _p, _p = nullptr; } }
public:
 int & operator[]( int i ) throw( std::out_of_range );
 const int & operator[]( int i ) const throw( std::out_of_range );
private:
 int _n;
 int * _p;
};
```

```c++
A::A( A & that )
{
 _n = that._n, _p = that._p, that._n = 0, that._p = nullptr; }
A::A( const A & that )
{
 this->_n = that._n;
 _p = new int[_n]; 
 for( int i = 0; i < _n; i++ ) 
     _p[i] = that._p[i];
}
A & A::operator=( A & that )
{
 if( _p ) delete[] _p;
 _n = that._n, _p = that._p, that._n = 0, that._p = nullptr;
 return *this;
}
A & A::operator=( const A & that )
{
 this->_n = that._n;
 if( _p ) delete[] _p;
 _p = new int[_n]; 
 for( int i = 0; i < _n; i++ ) 
     _p[i] = that._p[i];
 return *this;
}
```

所以要移动语义干嘛，左值引用就可以做到，当然事情并不是这么简单。

```c++
// “Main.cpp”
int main()
{
 A a1; // 缺省构造
 const A a2; // 缺省构造
 A a3( a1 ); // 调用A::A( A & )，移动构造
 A a4( a2 ); // 调用A::A( const A & )，深拷贝构造
 // 对于非常量，必须转型为常量才能进行深拷贝
 A a5( const_cast< const A & >( a1 ) ); // 调用A::A( const A & )
 A a6, a7, a8; // 缺省构造
 a6 = a1; // 调用A::operator=( A & )，移动赋值
 a7 = a2; // 调用A::operator=( const A & )，深拷贝赋值
 a8 = const_cast< const A & >( a1 ); // 调用A::operator=( const A & )
 return 0;
}
```

移动语义的意义、目的并不仅仅体现在之前的功能上。

**右值引用的意义**

```c++
右值引用可以使用文字作为函数实际参数
// 不接受文字作为实际参数，因无法获取文字的左值
int f( int & x ) { return ++x; }

// 接受文字作为实际参数，传递右值引用
// 具名右值引用作为左值，匿名右值引用作为右值
// 在函数内部理论如此，但实际上……
int f( int && x ) { return ++x; }
int main()
{
 // 错误代码，++操作符的操作数必须为左值
 // std::cout << ++10 << std::endl;
 // 可能有问题，传递右值引用，但部分编译器可能将其作为左值
 // 10是一个文字，作为函数的参数传进去，我们实际上只能传那个文字的右值引用，而不能传它的左值引用，都没有左值，引用什么呢，对吧。10它是个匿名的右值引用，10是没有变量的名字的，它不是变量，它仅仅是个文字。
 std::cout << f(10) << std::endl; // 11?
 // 有的编译器会给你输出11，理论上不应该这样，因为++只接受左值，而你匿名右值引用在函数内部作为右值，这样++x就是非法的，它做不了。
 return 0;
}
```

更重要的，右值引用最主要的目的其实是这个：**1）避免编写过多的构造与赋值函数**

- 不管是左值引用还是右值引用， 若同时提供拷贝语义与移动语义，需要2对（4个）构造和赋值函数
- 如果你这个类里有很多指针对象成员，或者其它对象成员，而且这些对象涉及到指针所有权的问题，那么你可能需要或者你可能想为这些指针成员中的每一个都提供一个移动语义和拷贝语义，这事情就要命了。若通过单独提供成员值的方式构造对象，单成员至少需要2对（4个）构造和赋值函数，双成员至少需要4对（8个）构造和赋值函数，移动移动、移动拷贝、拷贝移动、拷贝拷贝，组合爆炸，写不过来。所以参数如果很多，而且都需要涉及到移动语义很拷贝语义的混合编程，编程写起来就累死人了。
- 使用右值引用，通过函数模板可以缩减代码编写量（光有右值引用也搞不定，必须会下一讲的泛型编程）

**2）它实际上用于实现一个实现完美转发**

​		意思是完成一个参数从一个函数到另外一个函数的传递，这叫转发。一个函数在运行期间它会接受一个参数，它内部可能不做处理，也可以只做简单处理，然后就把参数传递给另外一个函数，转发对库的设计可能是很重要的，在右值引用出现之前，我们就没有一个完美转发过程，不管你使用什么样的逻辑来实现它，这个转发总是有一些缺陷的，我们转发最好能够做到什么程度呢？就是接受什么样的值，就传出去什么样的值，而没有右值引用，这个事情是做不到的。

### 5.流操作符重载

#### 流操作符重载的一般形式

```c++
为数偶类定义专用的流操作符
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b) { }
 // 必须使用此格式，以与流的连续书写特性保持一致
 friend ostream & operator<<( ostream & os, const Couple & c );
 friend istream & operator>>( istream & is, Couple & c );
private:
 int _a, _b;
};
```

流式操纵，cout << a << b；它是连写的，这是流操作最重要的一个本质，所以cout << a 的结果它做出来后它会把a输出出去，但是这个结果做出来它必须能返回cout，然后才能 << b ，连写模式就意味着这个流操作符它的格式是固定的。它必须返回输出流或者输入流的一个引用，同时它的第一个参数也必须是那个输出流或输入流的引用，实际上返回的就是它的第一个参数。所以要重载为友元，必须按照这个模式来。第二个参数才是你要输出的，或者输入的那个对象。输出就是const Couple &，输入就是Couple &。

```c++
// 注意：此处实现的流输入输出格式不统一
ostream & operator<<( ostream & os, const Couple & c )
{
 os << "( " << c._a << ", " << c._b << " )" << endl;
 return os; }
istream & operator>>( istream & is, Couple & c )
{
 is >> c._a >> c._b;
 return is;
}
int main()
{
 Couple a( 1, 2 ), b;
 cin >> b;
 cout << a << endl;
 return 0;
}
```

#### 流与文件

**标准流类库：**

cin、cout实际上就是在标准流类库里面提供的全局的流对象。关于这个流，它有一些特定的格式的处理，包括如何设定整个流的输入输出格式，包括如何操纵这样一个流，我们称之为操纵符，包括如何和文件挂接在一起，形成文件流。

**流**：数据从源到目的地一个流动。所以它一定有两个方向，两个端口。

输入输出流

​	输入输出流：iostream；输入流：istream；输出流：ostream

字符串流类

​	输入输出字符串流：strstream；输入字符串流：istrstream；	输出字
​	符串流：ostrstream

文件流类

​	输出文件流：ofstream；输入文件流：ifstream；输入输出文	件流：fstream

全局流对象
- std::cout：标准输出流对象，一般对应标准输出设备（主要是我们计算机屏幕）
- std::cin：标准输入流对象，一般对应标准输入设备（主要是键盘）
- std::cerr：标准错误流对象，一般对应标准错误输出设备
- std::clog：标准日志流对象，一般对应标准日志输出设备
- std::cout、std::cerr与std::clog为std::ostream类的对象；
std::cin为std::istream类的对象

插入

目的：将数据对象插入到流中

 	插入操作符也称输出操作符

​	std::cout << "Hello World!"; // 将字符串插入到输出流

提取

​	从流中提取数据对象

​	提取操作符也称输入操作符

​	int a; std::cin >> a; // 从输入流中提取整数

注意：因为流可能被重定向或束定（即可以把一个输入流和一个输出流挂接在一起，它就形成两个流之间的一种束定的关系，把它们绑在一块的意思），所以有时使用输入输出描述流
操作可能会让人迷惑，它到底是在输入还是在输出，因为它往往涉及它从哪来到哪去，有一个主管的基本点，有个基准我才能说输入输出嘛，而插入和提取呢，我仅以那个流——所操纵的那个流来为对象，到底是把那个数据往流里放还是从流中取出来。**所以当我们说流式操作的时候，说插入符和提取符，说插入操作或提取操作其实更准确，要比输出操作、输入操作更准确。**

**常用输入输出流函数**

```c++
判断流是否已结束
- cin.eof()
读取单个字符
- cin.get( istream::char_type & c )
读取字符串
- cin.get( istream::char_type * s, streamsize n, istream::char_type
delimiter = '\n' )
读取单行文本
- cin.getline( istream::char_type * s, streamsize n, istream::char_type
delimiter = '\n' )
输出单个字符
- cout.put( ostream::char_type c )
```

在流操作中提供的函数远不止这5个，很多函数你都可以使用。

**流格式：**

流式操作的时候，为了控制这些量的输入和输出，它事实上是有一系列格式的标志。这些格式标志都定义在一个特殊的类，我们称为ios_base，这一个输入输出流的一个基类里面，它定义的这些格式的标志，它使用了一个匿名的枚举型，基本上都是按位格式来定义的，一位一个，一位一个，按照这个模式。为什么呢？因为C和C++支持我们的位操作。这样的话，按照位标志的模式来去处理的话，它处理的效率是非常高的。

正常情况下，它应该是一个int型，但它实际上，是为了表明这个流格式的一个属性，专门定义了一个型，叫fmtflags，把一个整数型定义成了格式标志。就是fmtflags，用这个型来指代我们流的格式标志。当你使用的时候，就使用它就行了。

这些流的格式标志中，有一个非常重要的地方就是它们的设计都是按位来做的。

**位掩码**

​	-使用32位整数的位代表流格式标志：ios_base::fmtflags

​	每个标志位可单独设置与清除

设置预定义标志位

​	cout.setf( ios_base::showbase ); // 输出整数前缀，十六进制	前添加“0x”

清除预定义标志位

​	cout.unsetf( ios_base::showbase ); // 清除上述标志

位组：**特定标志位集合，位组中的标志位互相排斥**

​	ios_base::adjustfield、ios_base::basefield与 

​	ios_base::floatfield       

​	cout.setf( ios_base::hex, ios_base::basefield );

​	// 传上参数后传上它指定的位组，必须按照这个格式来

​	// 设置十六进制输出格式，如果你不传位组信息，使用单参数版本无效果

还有一些设定格式的时候需要用户传递一些附加的信息，这个附加信息我们需要作为用户自定义参数传进去才行。这种模式是相当必要的。

```c++
设置用户自定义参数：单参数版本
- 设置时传递用户指定值 - std::cout.width( 8 ); // 将最小输出宽度定为8个字符
- std::cout.precision( 8 ); // 将输出精度定为8位 
- std::cout.fill( '?' ); // 使用‘?’填充空白字符位置
获取用户自定义参数：无参数版本
- // 获得当前的输出精度值
- std::streamsize precision = std::cout.precision();
```

注意：对一个复杂数据格式的复杂输出，流式操作是极其不方便的，效率（指编程效率）实际上是非常低的，不如printf函数调用，输出一个复杂信息的时候，建议用printf这样的函数里面去输出。只有简单的输出，使用cout其实更方便一些。但是cout确实有一个好处就是它支持重载，一旦我们重载了这个流操作符，那么大对象的输出输入它不就方便了嘛。

> \>> 是输入流符号
> << 是输出流符号

```c++
class ios_base
{
public:
 typedef int fmtflags;
 enum
 {
 left = 0x0001, right = 0x0002, internal = 0x0004,
 dec = 0x0008, hex = 0x0010, oct = 0x0020,
 fixed = 0x0040, scientific = 0x0080, boolalpha = 0x0100,
 showbase = 0x0200, showpoint = 0x0400, showpos = 0x0800,
 skipws = 0x1000, unitbuf = 0x2000, uppercase = 0x4000,
 adjustfield = left | right | internal,
 basefield = dec | oct | hex,
 floatfield = scientific | fixed
 };
};
```

操纵符：

为了控制这个流的输出的过程，不仅仅以前面那个模式来去写，它要提供一系列的操纵符来控制整个流的输入输出的格式，前面我们把它设成16进制，设置它的精度啊，那种东西都叫它的操纵符。

流最主要的目的就是想实现连续的操纵嘛，所以流式操作必须保证这个连续性。那么所有对流的格式进行控制的那些操作必须是以输出对象或输入对象一样的方式进行处理，也就是说，控制流格式的那个东西本身应该可以作为流的那个参数。

```c++
操纵符的目的：控制流的输入输出格式
- 无参数操纵符：函数指针
- 单参数操纵符：函子，即带有函数指针功能的操纵符类的对象，实现上为重载了函数调用操作符的操纵符类（然后你构造这个操纵符类的一个对象，然后在那个对象上面调用它重载的函数调用操作符，然后它表现行为就像一个函数一样，这就叫一个函子，有时候我们称它为函数对象，叫function object，有时候直接称为functor，就叫函子）
操纵符示例
- 头文件：“iomanip” 
- std::cout << "Hello World!" << std::endl; 
// 这就是一个操纵符，表示一个换行的动作，无参数
- int n = 1024; 
std::cout << std::dec << n << '\n' << std::hex 
<< n << std::endl;
// dec表示是一个十进制操纵符，hex为16进制操纵符，endl操纵符为换行符
```

文件流：

文件特性
- 文件一般保存在外部存储设备上 

- 文件生命周期可能远远超过创建它的程序本身

  程序运行完后得到一个结果，我把这个结果写道这个文件里，程序就结束了，那个文件还在，我下一次运行这个程序，就从那个文件中把那个数据读出来，这个动作叫**数据的持久化**。

文件操作：读、写

- 一般使用文件指针，该指针代表文件的当前访问位置（你的数据读取或写入将从当前文件的什么地方开始，就这个意思） 

- 老式的C语言使用文件句柄（handle）或文件描述符（file descriptor）表示某个打开的文件数据对象

文件流的使用

- 头文件：“fstream”
- 按照特定格式重载类的流操作符（这样的话才能把这个指定的对象按照一个特定的方式流出去，否则的话，你就得一个成员、一个成员地自己手工去写操作，那就麻烦了，因为好多成员都是私有的，在这种情况下你必须提供对应的Get/Set函数你才能操作嘛，而且那个格式就很费劲，你要一个一个地去写，对于这个类的使用者来讲，输出一次类的信息确实很麻烦，如果对象很多，那代码写起来就很长，会崩溃，那么对于库的设计者来讲，你为了让它不崩溃，你就得重载类的流操作符）
- （一旦我们重载了流操作符）那么只需要创建文件流对象，然后进行输入输出，完事了。

```c++
文件打开模式
- std::ios_base::app：每次插入都定位到文件流的尾部
  // 追加模式打开
- std::ios_base::binary：使用二进制而不是文本格式打开文件流 
  // 二进制模式打开
- std::ios_base::in：流用于输入目的，允许提取，此为std::ifstream 流缺省设置
  // 输入模式打开
- std::ios_base::out：流用于输出目的，允许插入，此为std::ofstream 流缺省设置
  // 输出模式打开
- std::ios_base::trunc：若文件存在，清除文件内容，此为
std::ofstream流缺省设置
- std::ios_base::ate：若文件存在，定位到文件尾部，文件一般保存在外部存储设备上
```

流状态：

每一个流打开以后，它都有一个特定的流状态，流状态就表示我们在流进行操纵过程中，它成功或失败的一个状态信息。

```c++
流状态：表示操作成功或失败的状态信息
- std::ios_base::goodbit：// 好位状态，是指当这个操作做完以后流是完好无损的，操作成功了，就这个意思。
- std::ios_base::badbit：// 流已出现致命错误，一般无法恢复
- std::ios_base::eofbit：// 流结束位，流结束时设置
- std::ios_base::failbit：// 流操作失败时设置，可能恢复；比如我想打开一个文件，但是那个文件被别人锁定了，这个时候就返回failbit。
流操作本身都可能影响我们的流状态，而流状态当然对流操作行为其实也能够造成影响。
流状态对流操作行为的影响
- 一旦流状态存在错误，所有I/O操作都失效
- 在出现std::ios_base::failbit与std::ios_base::badbit状态时，输出操作立即停止
- 在非std::ios_base::goodbit状态时，输入操作立即停止
```

可以通过一系列的成员函数来测试我们的流处于什么样的状态。

```c++
流状态测试
- bool std::ios_base::good() const：没有出现任何错误时返回真 
- bool std::ios_base::eof() const：设置std::ios_base::eofbit状态时返回真 
- bool std::ios_base::fail() const：设置std::ios_base::failbit状态时返回真 
- bool std::ios_base::bad() const：设置std::ios_base::badbit状态时返回真 
- bool std::ios_base::operator !() const：与std::ios_base::fail() 效果相同
- std::ios_base::operator void*() const：std::ios_base::fail() 为真时返回空指针，否则非空
```

流定位：

流读取的位置，它有一个文件指针指向它嘛，就会时刻发生变化，我想知道这个位置指针到底指向了哪里，或者我想把它设到一个特定的地方，那么我就需要对这个流进行定位。

**流位置指针**

- 位置指针指向下一次读写操作时的数据对象在流中的位置，该指针会随着输入输出操作而不断变化 

- 单向流：一个位置指针；双向流：两个位置指针

流位置指针的获取

- 成员函数tellp()：获取当前的流位置指针（写指针）

- 成员函数tellg()：获取当前的流位置指针（读指针）

流位置指针的定位

- 成员函数seekp()：将文件位置指针定位到某个特定位置，用于插入（输出）目的，写的。

- 成员函数seekg()：将文件位置指针定位到某个特定位置，用于提取（输入）目的的定位，读取的。

当你用seekp和seekg进行流指针定位的时候，要注意可以提供一个单参数的版本。

流定位函数seekp()与seekg()
- 单参数版本：可以使用获取的位置指针（就是可以使用获取的位置指针来去做它）

- 双参数版本：第一个参数为偏移量；第二个参数为定位基准

定位基准

- std::ios_base::beg：从流的开始位置开始计算偏移量 
- std::ios_base::cur：从当前位置开始计算偏移量 
- std::ios_base::end：从流的结束位置开始计算偏移量

#### 文件输入输出

```c++
将点对象输出到文件中
#include <fstream>
#include "point.h"
using namespace std;
int main()
{
 ofstream ofs( "~/CPP/filestream/data.txt" );// 定义一个ofstream类的一个对象，然后把它跟一个文件挂在一块，然后就像标准的流操作一样，就可以访问那个文件了，多方便。输入其实也一样，看下例。
 // ofs.open( "~/CPP/filestream/data.txt" );
 Point2D pt2d( 1, 2 ); 
 Point3D pt3d( 3, 4, 5 );
 ofs << pt2d;
 ofs << pt3d;
 // 把这两个点对象流到文件里
 ofs.close();
 // 关闭这个文件，这个输出文件流就和那个文件它的关系就被打断了。
 return 0;
};
// 第一件事情，我们要构造一个输出文件流对象，这个输出文件流对象从属于类ofstream，我们就输出流对象叫ofs。然后我用一个单参数的构造函数构造它，这个参数就是那个输出文件的文件名。如果你缺省构造，没有传文件名，那么在这个ofs输出流构造完毕之后，可以调用它的成员函数open，传文件名参数进去，打开那个对应的文件也可以。
```

```c++
将Point2D、Point3D对象从文件中读取出来
#include <fstream>
#include "point.h"
using namespace std;
int main()
{
 ifstream ifs( "~/CPP/filestream/data.txt" );
 Point2D pt2d; 
 Point3D pt3d;
 ifs >> pt2d >> pt3d;
 ifs.close();
 return 0;
};
```

看看Point2D和Point3D的具体实现

```c++
class Point2D : public Point
{
public: 
 friend ostream & operator<<( ostream & os, const Point2D & pt );
 friend istream & operator>>( istream & is, Point2D & pt );
};
 
class Point3D : public Point2D
{
public:
 friend ostream & operator<<( ostream & os, const Point3D & pt );
 friend istream & operator>>( istream & is, Point3D & pt );
};
```

```c++
ostream & operator<<( ostream & os, const Point2D & pt ) {
 os << '(' << pt._x << ',' << pt._y << ')';
 return os; }
// 逐字符分析，确保文件非致命改动不影响数据读取
istream & operator>>( istream & is, Point2D & pt ) 
{
 char _c; 
 int _a[2] = {0, 0}, _i = 0; 
 bool _started = false;
 _c = is.get();
 while( _c != '\n' ){
 	if( _c == '(' ){ _started = true; }
 	else if( isdigit(_c) ){ if( _started ) _a[_i] = 		_a[_i] * 10 + _c - 48; }
         // _a[0]开始等于0，比如23先读取2，然后遇到3，                 2*10+3，48为0的ASCII码值。
 	else if( _c == ',' ){ _i++; }
    // 遇到逗号就开始读取下一个数
 	else if( _c == ')' ){ _started = false; break; }
 	_c = is.get();
    // istream的get()成员函数来读取一个字符
 }
 pt._x = _a[0], pt._y = _a[1]; 
 return is;
}
```

**数据持久化**

持久化：将数据保存在外部磁盘文件中，在程序运行时装入内存，
在程序结束时重新写回文件（保证我们的数据在整个程序存续之外，它仍然能够存在，那这个数据不久持久化了嘛，就长时间存在的意思）

思考题

- 考虑下述编程任务。存在一个数据结构，需要将其数据流入流出。为提升程序效率，只在必要时进行数据持久化，即仅当内存中的数据发生变化时才写入文件。如何实现？提示：（1）需要考虑内存数据的来源和目的地对数据持久化的影响。（2）使用下一章将要讨论的动态型式转换技术，实现效果更佳。

问题是我们在重载我们的流操作的时候，我们是以ostream类的一个引用来传递这个参数的，它是ostream，它是输出流类，它不是文件流类，就是说我重载这个流不仅仅适应于我们的文件流，它还适应于一般的流，包括字符串流，**那么这个数据到底是从文件流进来的还是从其它的一个普通流对象中流进来的，对这个数据是否更新，也就是它和磁盘文件中的那个数据是不是完全一致，它们的影响（对数据是否需要持久化的影响）是不一样的**，当你重载这两个流操作符的时候，在内部必须能够处理这个问题，而处理这个问题最好的方案就是需要运行期的型式信息。

### 6.操作符重载总结

哪些操作符可以重载？
- 不可重载操作符：“::”、“?:”、“.”、“.*”、“sizeof”、“#”、“##”、 “typeid” 

- 其他操作符都可重载（这是指C++11以前的，C++11后来又添加了很多操作符，那些就不在我们目前的考虑范围之内）

操作符重载原则

- 只能使用已有的操作符，不能创建新的操作符
- 操作符也是函数，重载遵循函数重载原则
- 重载的操作符不能改变优先级与结合性，也不能改变操作数个数及语法结构
- 重载的操作符不能改变其用于内部类型对象的含义，它只能和用户自定义类型的对象一起使用，或者用于用户自定义类型的对象和内部类型的对象混合使用
- 重载的操作符在功能上应与原有功能一致，即保持一致的语义

操作符重载的类型：成员函数或友元函数

​	（大部分操作符都是既可以当成员函数来重载也可以当友元函数来		重载的）

- 重载为类的成员函数：少一个参数（隐含this，表示二元表达式的左参数或一元表达式的参数）  

- 重载为类的友元函数：没有隐含this参数（单参数的话，不重载为类的友元函数）

成员函数与友元函数

- 一般全局常用操作符（关系操作符、逻辑操作符、流操作符）重载为友元函数，**涉及对象特殊运算的操作符重载为成员函数**
- 一般单目操作符重载为成员函数（就不把这个函数的名字公开在外部形成全局的嘛，你重载为友元函数的话那个函数往往就是全局的），双目操作符重载为友元函数（这样的话左操作数和右操作数可以相当灵活地去设置，使用其实更加方便）
- 部分双目操作符不能重载为友元函数：“=”、“()”、“[]”、“->” （必须隐式地提供它的this指针）
- 类型转换操作符只能重载为类的成员函数

PS：所谓几目，就是说它约束几个对象。比如[]，重载的时候，左边是数组名，右边是数组下标或者另一个中括号。 有两个运算对象。

```c++
重载的操作符参数：一般采用引用形式，主要与数学运算协调
- 示例：
Couple a(1,2), b(3,4), c; 
c = a + b; 
- 若有定义：Couple Couple::operator+(Couple*, Couple*) { …… }
- 则需调用：
Couple a(1,2), b(3,4), c; 
c = &a + &b; // 参数为传指针，必须写上&操作符
// 当然你可以写Couple *a、Couple *b，然后我new它们嘛，这样就可以写c=a+b，但是那就限定了你所有的对象必须是个指针，必须动态构造。这样就很麻烦，引用传递的目的就在这里，就是为了处理这个问题的，以与数学运算相协调，所以参数传递必须用引用形式，不管是左值引用还是右值引用。
```

最后简单的罗列一下C++操作符重载的函数原型。这是我们推荐的函数原型，平时操作符重载的时候，应该按照这样的一个模式进行操作。换作其它模式，有的时候不是不可以，但是它并不是特别恰当的方案。

```c++
操作符重载的函数原型列表（推荐） 
普通四则运算
- friend A operator + ( const A & lhs, const A & rhs );
- friend A operator - ( const A & lhs, const A & rhs );
- friend A operator * ( const A & lhs, const A & rhs );
- friend A operator / ( const A & lhs, const A & rhs );
- friend A operator % ( const A & lhs, const A & rhs );
- friend A operator * ( const A & lhs, const int & rhs ); // 标量运算，如果存在
- friend A operator * ( const int & lhs, const A & rhs ); // 标量运算，如果存在

关系操作符
- friend bool operator == ( const A & lhs, const A & rhs ); 
- friend bool operator != ( const A & lhs, const A & rhs );
- friend bool operator < ( const A & lhs, const A & rhs );
- friend bool operator <= ( const A & lhs, const A & rhs );
- friend bool operator > ( const A & lhs, const A & rhs );
- friend bool operator >= ( const A & lhs, const A & rhs );
```

```c++
操作符重载的函数原型列表（推荐） 
逻辑操作符
- friend bool operator || ( const A & lhs, const A & rhs );
- friend bool operator && ( const A & lhs, const A & rhs );
- bool A::operator ! ( );

正负操作符
- A A::operator + (); // 取正 
- A A::operator - ( ); // 取负 

递增递减操作符
- A & A::operator ++ (); // 前缀递增
- A A::operator ++ ( int ); // 后缀递增
- A & A::operator --(); // 前缀递减
- A A::operator -- ( int ); // 后缀递减
```

位操作符平时我们不建议重载

```c++
 位操作符
- friend A operator | ( const A & lhs, const A & rhs ); // 位与 
- friend A operator & ( const A & lhs, const A & rhs ); // 位或 
- friend A operator ^ ( const A & lhs, const A & rhs ); // 位异或 
- A A::operator << ( int n ); // 左移
- A A::operator >> ( int n ); // 右移
- A A::operator ~ (); // 位反
```

```c++
动态存储管理操作符：全局或成员函数均可 
- void * operator new( std::size_t size ) throw( bad_alloc );
- void * operator new( std::size_t size, const std::nothrow_t & ) throw( );
- void * operator new( std::size_t size, void * base ) throw( ); 
// 带哑型指针参数，作为一个基地址的参数，意味着它的内存分配将在一个固定的内存区域，而这个内存区域是已经分配好的，不管是动态分配还是静态分配，反正已经分配好了。然后我们新创建一个对象，就不再真正分配内存，而只是在已经分配好的就是base指针所指向的那段内存区域里为我们新的对象划定一个存储空间保存，这个我称它为定位创生。这个new操作符重载有的时候相当有意义，我们的应用程序我需要频繁地开辟一些小数组，很小但是很频繁，因为程序语义本身要求这么做，那么频繁从全局里面去new、delete、new、delete，很讨厌，要从全局堆里面进行分配，效率其实是低的，在这种时候我可以在程序运行一开始，就划定一个非常大的存储空间，上来就从操作系统中把这个存储空间给分配过来，要过来。然后我应用程序内部每次需要分配小数据对象，想返回的时候就在我这个分配空间里面一个接着一个地去分配和管理它，固定在同样的小片区域里，这个内存区域里，这个内存区域我们称它为缓冲池，你就可以重载这个new操作符来处理你应用程序的特定对象的存储管理问题。你可以在这个过程中提升整个程序的效率，你甚至可以为你的应用程序提供垃圾回收机制处理这个指针问题，相当重要的一个设计细节。
// new和delete既可以重载为全局的也可以重载为类的成员函数，大部分情况下，重载为类的成员函数要更安全一些，重载为全局的有的时候一旦覆盖了全局的new版本，可能会导致我们的程序出现难以预料的结果，所以重载的时候需要特别小心。
- void * operator new[]( std::size_t size ) throw( bad_alloc );
- void operator delete( void * p );
- void operator delete []( void * p );
```

```c++
操作符重载的函数原型列表（推荐） - 赋值操作符
- A & operator = ( A & rhs );
- A & operator = ( const A & rhs );
- A & operator = ( A && rhs );
- A & operator += ( const A & rhs );
- A & operator -= ( const A & rhs ); 
- A & operator *= ( const A & rhs );
- A & operator /= ( const A & rhs );
- A & operator %= ( const A & rhs );
- A & operator &= ( const A & rhs );
- A & operator |= ( const A & rhs );
- A & operator ^= ( const A & rhs );
// 位运算的赋值
- A & operator <<= ( int n );
- A & operator >>= ( int n );
```

```c++
下标操作符
- T & A::operator [] ( int i );
- const T & A::operator [] ( int i ) const; 

函数调用操作符
- T A::operator () ( … ); // 参数可选
// 这样的话，这个函数就有一个operator()这样的一个函数，就让这个对象可以像函数一样去运行一下。函数调用操作符有时候会很神奇，它会给我们带来很重要的一个结果，就像前面讲流对象那样，它的操纵符带参数的，那它其实就是一个函子，就意味着它事实上在实现上就是重载了函数调用操作符的一个函数对象，它就是一个对象。

类型转换操作符（只能重载为类的成员函数）
- A::operator char * () const; 
- A::operator int () const; - A::operator double () const; 
- 逗号操作符
- T2 operator , ( T1 t1, T2 t2 ); // 不建议重载，因为它的优先级真的很低，而且真的没有必要
```

```c++
指针与选员操作符
- A * A::operator & ( ); // 取址操作符
- A & A::operator * ( ); // 引领操作符
- const A & A::operator * ( ) const; // 引领操作符
- C * A::operator -> ( ); // 选员操作符
- const C * A::operator -> ( ) const; // 选员操作符
- C & A::operator ->* ( … ); // 选员操作符，指向类成员的指针(这个技术细节很偏，需要的时候再去认识它)

流操作符
- friend ostream & operator << ( ostream & os, const A & a );
- friend istream & operator >> ( istream & is, A & a );
```



## 十一.泛型编程

### 1.泛型编程概览

1）什么是泛型编程

---泛型就是通用型式

---编写不依赖数据对象型式的代码就是泛型编程（你写的程序代码和你想要操纵的那个数据对象的具体型式相对无关，那么你写的这段代码就称为泛型的代码，你处理的型，当然也就是所谓的泛型）。

2）为什么需要泛型编程

前面讨论的C++的语言规范里，我们使用面向对象的技术，有继承，有多态，可以解决很多现实世界中的问题，但是，在纯粹的面向对象编程里，涉及到几个问题，这几个问题不太好解决。

一个是函数重载的问题，第二个是相似类的定义问题，第三个是型号式兼容性。在这里，需要补充两个知识，一个是异常处理机制，一个是运行期的型式信息。

3）怎样进行泛型编程

泛型编程最主要的技术手段就是：模板与型式参数化。

1.**函数重载问题**

设计函数，求两个数据对象的较小者

**注意**：并没有说数据对象具体是什么型

所以，如果你编写这样一段程序代码，那么事实上你将提供很多个函数，因为重载机制，所以处理不同型的这样的函数可以命名成一样的。

如果你有一个类A，那么你要为A类提供一个Min()版本，如果你还有一个类B，还要为B类提供一个Min()版本。

```c++
//为明确规定参数型式，因C/C++的强型式检查特性，必须为不同型式的参数分别实现，没完没了。。。
//函数重载数目巨大，并且永不完备。。。
class A;
const A & Min(const A & a, const A & b);
class B;
const B & Min(const B & a, const B & b);
```

**解决方案：使用C的含参宏**

在引入C++以前，我们怎么解决函数重载问题呢？在C++以前，C是怎么解决函数重载问题的呢？因为C不支持函数重载，所以它提供了含参宏，这是一种很巧妙的方案。

宏，尤其是含参宏，它是型式无关的。所以它在某种程度上起到了函数重载的类似效果。

> 带参数的宏定义
> 　　带参数的宏定义的一般形式如下：
> 　　#define <宏名>（<参数表>） <宏体>
> 　　其中， <宏名>是一个标识符，<参数表>中的参数可以是一个，也可以是多个，视具体情况而定，当有多个参数的时候，每个参数之间用逗号分隔。<宏体>是被替换用的字符串，宏体中的字符串是由参数表中的各个参数组成的表达式。例如：
>
> ```c++
> #define SUB(a,b) a-b
> 　　如果在程序中出现如下语句：
> 　　result=SUB(2, 3)
> 　　则被替换为：
> 　　result=2-3；
> 　　如果程序中出现如下语句：
> 　　result= SUB（x+1, y+2）;
> 　　则被替换为：
> 　　result=x+1-y+2;
> ```
>
> 　　在这样的宏替换过程中，其实只是将参数表中的参数代入到宏体的表达式中去，上述例子中，即是将表达式中的a和b分别用2和3代入。
> 　　我们可以发现：带参的宏定义与函数类似。如果我们把宏定义时出现的参数视为形参，而在程序中引用宏定义时出现的参数视为实参。那么上例中的a和b就是形参，而2和3以及x+1和y+2都为实参。在宏替换时，就是用实参来替换<宏体>中的形参。

**缺点**：

---无型式检查，无法在编译期检查程序错误。

---宏文本替换时，要注意操作符优先级，错误的宏文本有可能导致问题

**结论**：

---（从函数重载角度上讲）需要一种机制，能够在语法层面解决宏的问题

2**.相似类定义问题**

动态数组类

---定义存储整数的动态数组类

---定义存储浮点数的动态数组类

---定义存储某类对象的动态数组类

---定义存储某类对象指针的动态数组类

......

结论：

---需要一种机制，能够在语法层面解决相似类的重复定义问题，降低编程工作量。

3.**型式兼容性问题**

C型式转换：(T)x

---不安全

---内建型式（int、double）对象转换安全性基本保证

---**类对象转换可能导致无法控制的严重后果**

C++型式转换：T(x)

看上去让这个型式转换变成像一个函数一样。事实上它就是一个函数。

对于一个特定的型，我们可能需要一个单参数的构造函数和重载的型式转换操作符，才能完成这样的一个型式转换。

**同样，C++的型式转换依然不安全**。

如果你未实现这样的型式转换，那么它的转换本身就不存在。**对于你自己定义的一个特定的类，如果你没有实现单参数构造函数，如果你没有重载型式转换操作符，这样的转换可能就是无法工作的**。所以它一样也是不太方便的。

**类库架构**

---（从类库架构的角度上来讲）类的继承和多态频繁要求能够通过基类的指针或引用访问派生类的对象。(这是类库层次的基本要求)

---（所以）需要沿着类的继承层次，频繁进行对象的型式转换。（这是必须的）

而前面两种转换，它在很多情况下效果不令人满意。

**存在的问题**

---（所以）C/C++已有型式转换为静态转换，不能适应指针或引用的多态性。

---**型式转换本身必须能够适应全部型式**，并能自如操作；然而很不幸，型式无穷尽，程序员无法编写完备的型式转换代码。

所以我们**需要一种很特殊的机制，能够来保持我们的型式兼容性**。

**保证型式兼容性的机制**

---（这样的一种机制）必须能确保型式转换操作本身是合法有效的，并且在失败的时候通知用户。

---（为了让这样一种机制能够工作，我们需要两个特别的技术手段），①：需要在运行期维持对象的型式信息（run-time-type information，RTTI，**运行期型式信息**），②：转换结果的确认，通过转换操作的返回值确认结果，或者在失败时触发特定信号（或者给出一个特定的返回值来标记它），后者需要使用异常处理机制。

如果是一个指向对象的指针，当它转换失败的时候，我们简单的传递一个空指针就OK了；但是如果是一个引用，当它转换失败的时候，我们没有办法返回一个空引用，所以这个时候就需要使用异常处理机制。

从实现策略角度来讲，完成这样的型式兼容性的一个最基本的技术，就是我们这一讲要讨论的**模板与型式参数化**。

### 2.异常处理机制（非常重要）

1）异常处理机制的基本概念

异常的定义：程序中可以检测的运行不正常的情况

示例：被0除、数组越界、存储空间不足（你想分配一块内存但是存储空间不足）等。

**一个健壮的程序这些问题都必须处理**，早期我们是怎么写程序呢，我们可以写一个if判断它，当它出错的时候我们就做特定的处理，我们还可以写什么呢，我们还可以使用断言来处理这个问题。到了C++里边，为了和面向对象类库的架构相兼容，它提供了异常处理机制。允许你定义异常类，给了你一个更灵活的处理异常的技术手段。

#### 异常处理的基本流程

首先某段程序代码在执行操作时发生特殊情况，引发一个特定的异常；接着另一段程序代码捕获该异常并处理它。这个是异常处理机制的最基本的流程。

```c++
class JuStack
{
public:
 JuStack( int cap ) : _stk(new int[cap+1]), _cap(cap), _cnt(0), _top(0) { }
 virtual ~JuStack() { if( _stk ) delete _stk, _stk = NULL; }
public:
 int Pop();
 void Push( int value );
 bool IsFull() const { return _cap == _cnt; }
 bool IsEmpty() const { return _cnt == 0; }
 int GetCapacity() const { return _cap; }
 int GetCount() const { return _cnt; }
private:
 int * _stk;
 int _cap, _cnt, _top;
 // _cap 表示这个栈的容量，_cnt 表达的是这个栈当前的元素个数，_top 表示我们的栈顶指针位于第几个元素下标处，_stk 就是指向那个数组的0号元的指针。
};
// 我们构造这个栈的时候，要new一段存储空间出来然后让_stk 指向那个存储空间。一开始容量是传进来的，而栈的元素个数和栈顶指针都是0号元，
```

存在的问题
- 调用成员函数JuStack::Pop()时，栈是空的 

- 调用成员函数JuStack::Push()时，栈是满的

解决方案

- 定义异常类 
- 修改成员函数，在出现异常情况时引发之 
- 在需要的位置处理该异常

异常的引发

```c++
// 异常类：空栈异常类与满栈异常类
class EStackEmpty { };
class EStackFull { };
int JuStack::Pop()
{
 if( IsEmpty() ) // 引发空栈异常，构造该异常类的一个对象并抛出
 	throw EStackEmpty();
 // EStackEmpty()就表示我要构造这个类的一个匿名对象
 // 然后把那个匿名对象抛出来，这就叫引发这个异常
 --_top, --_cnt;
 return _stk[_top];
}
void JuStack::Push( int value )
{
 if( IsFull() ) // 引发满栈异常，构造该异常类的一个对象并抛出
 	throw EStackFull();
 _stk[_top] = value;
 _top++, _cnt++;
}
```

异常的捕获

```c++
const int err_stack_full = 1;
int main()
{
 JuStack stack( 17 );
 try
 {
 for( int i = 0; i < 32; i++ )
 	stack.Push( i ); // 可能引发异常的函数调用
}
 catch( const EStackFull & ) 
 // 负责捕获抛出的异常，执行相应处理
 // 捕获的是对这个常对象的一个引用，后面没有参数，因为我们不关心它那个参数具体是什么，内容是什么
 {
 std::cerr << "Error: Stack full" << std::endl;
 return err_stack_full;
 }
 return 0;
}
// 使用try ... catch 这样的结构来处理有可能导致异常的程序代码；也就是说，我们将有可能导致栈异常的代码封装在try这个块里。
```

#### 异常类与异常对象

前面的例子，我们定义的是两个空异常类，它所能够提供的信息是有限的。我们可以为这样的两个异常类提供更丰富的信息。在实际的编程中，所有的这些异常我们都应该精心的设计对应的异常类，能够提供足够的完整的信息，这样在异常处理的时候它的处理方案和处理的方法才能够更加灵活。

```c++
// 精心设计异常类，提供必要的异常信息
class EStackFull
{
public:
 EStackFull( int i ) : _value( i ) { }
 int GetValue() { return _value; }
 // 提供值的信息，就是说当时你在把哪一个数据压栈的时候出了异常，那么我们这个 _value 就保存那个数据，这样就可以提供更详尽的信息。
private:
 int _value;
};
void JuStack::Push( int value )
{
 if( IsFull() )
 	throw EStackFull( value ); // 使用value构造异常类对象并抛出
 _stk[_top] = value;
 _top++, _cnt++;
}
```

主程序当然也需要做一些修改

```c++
const int err_stack_full = 1;
int main()
{
 JuStack stack( 17 );
 try
 {
 for( int i = 0; i < 32; i++ )
 stack.push( i );
 }
 catch( const EStackFull & e ) 
 // 使用异常对象获取详细信息
 // Push()所构造的那个异常对象在catch这个子句里将通过e这个引用来访问。
 {
 std::cerr << "Stack full when trying to push " << e.GetValue() << std::endl;
 return err_stack_full;
 }
 return 0;
}
```

#### 异常处理策略

异常类可以派生和继承，形成类库架构（我们可以为所有的异常类构造一个完整的类的继承层次；正常情况下，我们的程序逻辑应该是有一个顶层的抽象的异常类，然后后续的所有的异常类都应该从这个异常类继承下来，事实上，C++标准库已经提供了这样的一个异常类）

（在catch那个子句里边）可捕获的异常对象的型式

- 任何一个普通型式（包括类）：当你以普通型式的形式来捕获的时候，异常对象需要拷贝

  整型可以、浮点型可以、字符串可以、类也可以。

- 对某型式对象的引用：没有额外的拷贝动作

- 指向某型式对象的指针：要求对象动态构造或者在catch子
句中可访问（这样的对象在大部分情况下都应该是动态构造的）

catch子句(可以封装对这个特定异常的一些必要的处理代码)
- 可以有多个catch子句，每个负责捕获一种、一类或全
部异常
- 捕获一种：catch( int )、catch( const char * ) 
- 捕获一类（**该类或其派生类异常**）：catch( const
EStackFull & ) 
- 捕获全部：catch(…)
- 所有catch子句按照定义顺序执行，因此派生异常类处
理必须定义在基类之前，否则不会被执行（因为基类写在前面，不管它是那个类本身还是那个类的引用还是指向那个类的指针，这个参数的型式它都能够捕获那个类和它所有的派生类异常）

```c++
异常再引发
- 可以在基本任务完成后重新引发所处理的异常
- 主要用于在程序终止前写入日志和实施特殊清除任务
try
{
 throw AnException();
}
catch(...)
{
 // ...
 throw;
}
// 你在处理异常的过程中，完成一个基本的任务，然后为了保证后续的代码依然还能够处理这样的异常，或者你认为在这个程序处理完之后这个异常有必要重新地被再次处理
// 这个地方还有点不太懂！！！！！！！
```

#### 栈展开

在异常处理过程中，我们的编译器会完成一个栈的展开，这一点在编程的时候实际上就已经写在了我们的可执行代码里。

- 异常引发代码和异常处理代码可能属于不同函数

- 当异常发生时，沿着异常处理块的嵌套顺序逆向查找能够处
  理该异常的catch子句

- 如找到对应catch子句，处理该异常

- **异常处理完毕后，程序保持catch子句所在的函数栈框架，不**
  **会返回引发异常的函数栈框架**

  为什么我们说在进行异常处理的时候，要进行栈展开呢，因为异常的引发代码和异常处理代码不在一个函数里，当它向后回溯的时候，来找你对应的catch子句来处理这个异常的时候，它不得不把引发那个异常的栈框架给去掉，如果它没找到的话，向上回溯一级函数调用，看主调函数里有没有对应的catch子句，如果没有，它还要继续向上回溯，再取消一次函数栈框架，一直到找到这个catch子句为止，然后完成这个异常处理的流程，这个流程一做完，它还能回到引发这个异常的那个函数调用栈框架里么？它恢复不过去了，所以整个流程这个时候就会停留在这个catch子句栈框架里，并且继续往下去做。

- 函数栈框架消失时，编译器本身能够替我们自动地将局部对象析构，局部对象被析构，但如果未执行delete操作，动态分配的目标对象未析构

未处理异常
- 所有未处理的异常由预定义的std::terminate()函数处理
- 可以使用std::set_terminate()函数设置std::terminate()函
数的处理例程

```c++
void term_func() { exit( -1 ); }
int main()
{
 try
{
 set_terminate( term_func );
 // 将term_func传给它，也就是说terminate()这个函数在异常没有处理情况下调用我们的term_func()这个函数去做特定的处理，处理完了，你也可以继续引发一个异常
 // set_terminate()将会把我们的异常处理例程设置为我们的term_func，
 throw "Out of memory!"; // 引发异常
 }
 catch( int ){ /* … */ }
 // 只捕获整数异常，它并不处理我们的字符串异常，所以异常未处理，terminate()这个函数就会处理这个异常，调用term_func() 这个函数对它进行处理。如果你没设置，那么所有未处理的异常都将交给操作系统来处理了。
 return 0;
}
```

描述函数是否引发异常

C++11之前的逻辑

- 否：throw()，表示这样的一个函数是不引发异常

- 是，引发任意型式的异常：throw(…) 

- 是，**引发某类异常**：throw( T )，部分编译器将其作为throw(…) 

C++11规范

- 否：noexcept，等价于noexcept(true) 
- 是：noexcept(false）
- 可能：noexcept(noexcept(expr))，expr为可转换为true或false的常数表达式（第一个noexcept是关键字，第二个是一个操作符，把表达式的结果变为true或false，所以两个noexcept都不能省略）

C++11下，建议使用noexcept代替throw

异常描述规范：

不管你是用throw还是用noexcept**来描述一个函数**是否引发异常，这个东西就叫异常描述规范。

```c++
class JuStack
{
public:
 JuStack( int cap ) : _stk(new int[cap+1]), _cap(cap), _cnt(0), _top(0) { }
 virtual ~JuStack() { if( _stk ) delete _stk, _stk = NULL; }
public:
 int Pop() throw( EStackEmpty );
 // 应该写在这个函数的声明处
 // C++11下写noexcept(false)
 void Push( int value ) throw( EStackFull );
 bool IsFull() const { return _cap == _cnt; }
 bool IsEmpty() const { return _cnt == 0; }
 int GetCapacity() const { return _cap; }
 int GetCount() const { return _cnt; }
private:
 int * _stk;
 int _cap, _cnt, _top;
};
```

**总结：**

1、若有异常则通过throw操作创建一个异常对象并抛掷；

2、将可能抛出异常的程序段嵌入try块之中。控制通过正常的顺序执行到try语句，然后执行try块内的保护段；

3、如果在保护段执行期间没有引起异常，那么跟在try块后面的catch子句就不执行，程序从try块后跟随的最后一个catch子句后面的语句继续执行下去；

4、catch子句按其在try块后出现的顺序被检查，匹配的catch子句将捕获并处理异常或继续抛掷异常；**也就是说这个匹配到异常的catch可以不去处理异常，而是把异常再抛出来**；

5、如果抛出异常，但没有合适的接收异常的处理catch，就会激发terminate函数，该函数调用引起运行终止的abort函数，就会引起程序中断；

6、如果抛出异常，**直接返回到catch捕获异常代码处，中间不管几层调用函数都会直接跨越**。

**异常补充内容**

（一）构造函数没有返回类型，无法通过返回值来报告运行状态，所以只能通过一种非函数机制的途径，即异常机制来解决构造函数的出错问题。

（二）异常机制与函数机制互不干涉，但捕获的方式是基于类型匹配。捕捉相当于函数返回类型的匹配，而不是函数参数的匹配，所以捕捉不用考虑一个抛掷中的多种数据类型匹配问题。

（三）catch代码块必须出现在try后，并且try块后可以出现多个catch代码块，以捕捉各种不同类型的抛掷。

（四）异常机制是基于这样的原理：程序运行实际上是数据实体在做一些操作，因此发生异常现象的地方，一定是某个实体出了差错，该实体所对应的数据类型便作为抛掷和捕捉的依据。

（五）异常捕捉的类型匹配之苛刻程度可以和模板的类型匹配媲美，它不允许相容类型的隐式转换，比如，抛掷char类型用int类型就捕捉不到。

**异常处理的基本思想**

![img](https://pics5.baidu.com/feed/aec379310a55b31954dc6e215b6ec923cefc178d.png?token=d243403d1f548ba97760d23612312262&s=2FAC7C2251CEE4E81A71D1DB0000C0B1)

调用者调用f函数，f函数调用f1函数...层层调用，最后g函数调用h函数，h函数引发异常，h函数只专注于业务的实现，不专注与异常的处理。

1、C++的异常处理机制使得异常的引发和异常的处理不必再同一个函数中，这样底层的函数可以着重解决具体的问题，而不必过多的考虑异常的处理。上层调用者可以在适当的位置设计针对不同类型异常的处理。

这样就达到了在逻辑控制上层异常处理的是一波函数，底层实现业务的是一波函数，可以让我们的软件设计更加合理。

2、异常是专门针对抽象编程中的一系列错误处理的，C++中不能借助函数机制，因为栈结构的本质是先进后出，依次访问，无法进行跳跃，但**错误处理的特征**是遇到错误信息就转到若干级之上进行重新尝试。发生错误时一层一层往上传递，发生异常时直接跳到异常处理处。

3、异常超脱于函数机制，决定了其对函数的跨越式回跳。

### 3.运行期型式信息

在面向对象的架构里，我们频繁地需要将一个对象或者一个对象的引用或者一个指向对象的指针沿着类库的继承层次进行转型，这个转型必须能够在程序运行期间确保它的有效性，而这个有效性的保证没有运行期的型式信息它是不可能完成的，运行期的型式信息就意味着**在程序运行期间我们要保存这些对象的所从属的型式的信息**，这个就是RTTI。

在C++标准库里提供了一个type_info这样的一个型式信息类。用来记录这些类的型式信息。当然你并不能直接使用type_info类，你只能使用**typeid操作符**，来获取一个特定的表达式的型式信息，在实现的过程中，进行对象或对象的引用或指向对象的指针的转型的时候，C++为我们提供了新的更安全的关键字，这四个关键字中最重要的就是dynamic_cast。

RTTI
- 运行期标识对象的型式信息
- 优势：允许使用指向基类的指针或引用自如地操纵派生类对象
- typeid：获取表达式的型式；type_info：型式信息类 
- 头文件：“typeinfo”

对象转型模板

- dynamic_cast：动态转型
- static_cast：静态转型
- reinterpret_cast：复诠转型
- const_cast：常量转型

这四个转型操作符都使用了模板，我们这一章要讨论的模板。

type_info 类 

- 编译器实现的动态型式信息都在这个类里边（它保存的是什么东西呢，事实上，它保存的是我们的动态型式信息，它本身是一个类型，所以它是动态型式信息型式） 
- 用于在程序运行时**保存数据对象的型式信息**

- 不能直接使用该类，只能通过typeid操作符

- 调用成员函数name()可以获得类的名称

  ```c++
  typeid 操作符
   #include <typeinfo>
   Programmer p;
   Employee & e = p;
   // 输出p实际类名的字符串“Programmer”
   cout << typeid(e).name() << endl;
  // 当然这里有个假设，Programmer是Employee的一个派生类
  ```

#### dynamic_cast

动态转型的三种方式

- 向上转型：沿着类继承层次向基类转型
- 向下转型：沿着类继承层次向派生类转型
- 交叉转型：沿着类多重继承层次横向转型

指针的动态转型

- 正确执行时，结果为指向目标类对象的指针
- 错误执行时，结果为0/NULL（C++11：nullptr）

引用的动态转型

- 正确执行时，结果为目标类对象的引用
- 错误执行时，引发bad_cast异常（我们必须对这个异常进行处理）

**假设软件公司包括程序员和经理两类职员，需要按照不同规**

**则支付薪水和奖金。如何实现？**

```c++
class Employee
{
public:
 virtual void PaySalary();
 virtual void PayBonus();
};

class Manager: public Employee
{
public:
 virtual void PaySalary();
 virtual void PayBonus();
};

class Programmer: public Employee
{
public:
 virtual void PaySalary();
 virtual void PayBonus();
};

// Company和它们并没有继承关系
class Company
{
public:
 virtual void PayRoll( Employee * e );
 virtual void PayRoll( Employee & e );
 // 这两个函数一般情况下我们只需要实现一个，这里只是为了示例。
private:
 vector<Employee*> _employees;
 // 一个公司有很多个雇员，所以我们使用一个向量来保存这些雇员
};
```

```c++
void Company::PayRoll( Employee * e ) // 版本一
{ // 调用哪个成员函数？如何区分程序员和经理？
 e->PaySalary();
 e->PayBonus();
};
void Company::PayRoll( Employee * e ) // 版本二
{
 Programmer * p = dynamic_cast<Programmer*>( e );
 // 初始化，把e这个指向Employee的指针动态转型成指向Programmer的一个指针，当它转型成功的时候p将指向那个目标类的对象。如果不成功，p值将是NULL。
 if( p ) // p确实指向程序员对象
 {
 p->PaySalary();
 p->PayBonus();
 }
 else // p不指向程序员，不发奖金
 e->PaySalary();
};
// dynamic_cast是一个模板，后面要用“<>”带着一个目标型的一个描述，目标型必须写在<>里，这是模板的基本架构，必须按照这个方式来，小括号对后面才是要待转型的那个对象。
```

如果传的是引用呢？

```c++
void Company::PayRoll( Employee & e ) // 版本三
{
 try
 {
 Programmer & p = dynamic_cast<Programmer&>( e );
 p.PaySalary();
 p.PayBonus();
 }
 catch( std::bad_cast )
 {
 e.PaySalary();
 // 这里有点特殊，catch子句里处理的不是错误，而是一个非正常的情况，意思是这个程序代码中优先处理的对象是程序员，这是我们程序流程处理过程中比较正常的情况，当他不算程序员的时候就出现了一个不那么正常的情况，那么我就把这段代码放到catch子句里，它并不是错误处理，而是为了完成特定的程序功能而编写的代码，这样同样是合法且有效的。
 }
};
```



疑问：为啥会转型失败？

#### static_cast

静态转型的用途
- 与dynamic_cast不同，static_cast不仅可用于指针和引
  用，还可用于其他型式

- 一般用于**非类型式的普通数据对象转型**(比如int 、double)

  当然它也是可以用于类对象的转型动作的

- 可以在类继承层次上进行向上或向下转型（交叉转型不是不可以，但是出错的概率非常非常高，一般就不用）

静态转型的问题

- 不进行运行期型式检查，不安全（不管用于类对象的转型还是非类型式的对象转型）
- 若转型失败，结果无定义

#### const_cast

常量转型的目的
- 唯一一个目的是用于取消或设置量的const状态（有的量以前是const，我想临时修改一下它的内容，那么这个时候就需要一次const_cast，如果有的量一开始不是const，我又想把它变成const，那么也可以做这样的一个转型）

  有时候如果一个量一开始不是const的量，但是我又需要把它传给一个const量，理论上可以直接传，但是某些特殊的场合，还是应该把它先转换成const量之后再传，语义上更恰当。

常量转型的问题

- 如果原始数据对象不能写入，则取消常量修饰可能会导致
未知结果（所以说const_cast它的最常用的一个场合，就是参数传递的时候，它那个实际参数和形式参数，const状态的一次变化）

```c++
#include <iostream>
class ConstCastTest
{
public:
 void SetNum( int num ){ _num = num; }
 void PrintNum() const;
 // _num本身是可以修改的，但是PrintNum()是不能修改它的，
private:
 int _num;
};
void ConstCastTest::PrintNum() const
{
 // 临时取消常量约束，修改目标对象的内容
 const_cast<ConstCastTest*>( this )->num--;
 // 这是一个const函数所以传过来的那个this指针它不是指向ConstCastTest而是指向const ConstCastTest，是指向常对象的指针，而不是指向这个对象的指针。这是最重要的一个地方。这个时候必须做一次常量转换，否则是没有办法操作的。
 std::cout << _num; }
```

#### reinterpret_cast

interpret是“解释、阐释”，我们这里就是“诠释”，re就是再，所以我把它翻译成复诠转型。

复诠转型的目的
- **将任意型式的数据对象转型为目标型式**，即重新解释其位序
  列的意义

- **尤其用于整型与指针型的互转** 

复诠转型的问题

- 由程序员保证重新解释的数据对象是否有意义，**编译器只是简单按照目标型式理解（解释）该存储区的内容，它并不管这个解释是对的还是错的**（转型是不是成功，是不是合法的，需要由程序员来保证，你必须保证它是有意义的）

- 注意：在64位操作系统中，指针型可能为64位，而整型可
  能为32位，复诠转型有可能丢失数据或得到错误结果 

```c++
#include <iostream>
using namespace std;
int f( void* p )
{
 unsigned int n = reinterpret_cast<unsigned int>( p );
 // p是一个对象的地址，那么我们就把那个对象的地址值转换成一个整数，然后输出那个整数就完事了，不仅仅可以输出，你都可以在那个整数上做运算。
 return n;
}
int main()
{
 int a[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
 int n = f( a );
 cout << n << endl; 
}
```

### 4.模板与型式参数化

转型操作
- 接受目标型式作为模板参数
- Programmer * p = dynamic_cast<Programmer*>( e )

模板工作原理

- 使用template<typename T>定义函数模板或类模板（你用模板定义函数就叫函数模板，定义类就叫类模板，这就意味着这样的函数或这样的类它就有一个型式参数T） 

  (typename 可以使用class关键字，在这个地方两者的性质是一样的，class写在这里不再指我们面向对象的那个类，虽说这里主要是类，但它可以不是类，它只是表示一个特定的型，为了防止混淆，我们这里只使用typename）

- 体化（instantiation）：使用特定的模板实际参数，生成真正的模板函数和模板类 （它会产生活生生的一个函数和一个类，然后你就可以调用这样的模板函数使用这样的模板类来定义对象） 

- 编译模板函数和模板类，生成最终程序代码

模板代码

**一般放在头文件中**：编译器需要看到模板源代码（编译器需要在生成我们的代码的时候要能够看到那个模板的内容，它得替你生成真正的那个函数和类啊，生成了以后才能编译啊）

模板特点
- 抽象性：模板代码高度抽象，是函数和类的模范（就是它是“模子”，是我们的“范本”、“范例”）
- 安全性：天然具有型式检查的功能，型式检查能够发现大多数型式失配问题，使用模板要比含参宏好的多，就是因为它能做型式检查
- 通用性：函数和类模板定义一次，按需生成函数和类的实体
- 易用性：接口相对直观且高度一致
- 效 率：减少冗余代码，提升编程效率；通过编译优化，提升程序执行效率

模板用途

- 函数模板：构造函数集，实现不依赖特定数据型的抽象算法（因为一个模板定义出来后，它实际上可以传递不同的型式，同时来构造不同的函数，这些函数就构成一个函数集合）
- 类模板：构造类集，**实现抽象数据结构（比前面讲的面向对象设计所提供的代码还要抽象**）
- 元编程：**构造在编译期执行的运算，提升程序执行效率**（并且可以得到很多有趣的结果）

### 5.题外话（术语翻译）

讲面向对象的时候有些概念用起来确确实实地听上去不太那么让人舒服，不顺溜，最主要就是不顺溜。所以就说一说计算机领域里有一些术语翻译的问题。

我最不满意的就是dereference。

dereference：引领，好于“解引用”

- reference：引用；英语本义：something such as a number or a name that tells you where you can obtain the information you want  

  （在面向对象技术出现之前，在C语言代码里边就频繁地使用reference和dereference，那个时候我们就把reference翻译成引用，dereference翻译成了解引用，名字有点怪，用了三个汉字来表达这个概念，不爽利，听着不像那么一回事，后来我就把它翻译为“引领”。）

- 引领：伸颈远望，带领

  （有了C++后，reference，因为产生了一个引用传递，reference就有了一个特别的意义，就和只使用指针的情况不太一样了，所以如果我们频繁地在指针上面说“引用”，那会搞糊涂的，到了C++11以后，那不仅有左值引用还有右值引用了，那会更让人糊涂的，所以在这里，这个词再翻译成“解引用”实际上就更加不妥当了）

type：型式，好于“类型”

- int：整数型式，简称整型 

- class：类型式，简称类型

  (到了面向对象里，用“类型”总觉得怪，比如int，它是一个整数类型，简称“整型”，一个class呢，它是一个类，所以称它为“类类型”，听着很累)

constructor：建构函数或构造函数

- 与destructor协调，建构函数更佳

destructor：析构函数或解构函数

最重要的是我们这一讲要用到的那个词，叫instance。

instance：定体，好于“实例”
- 英语本义： a particular example or occurrence of something （表示一个东西的一个特定例子或者一次发生；我们在面向对象的程序设计中，根据类的型构造一个对象，就表示构造它的一个instance，我们通过模板构造一个函数、构造一个类，那也是构造一个instance，这个instance不是example，是occurrence，这是非常重要的一个地方，我们用的那个“例”只是前面那个example，没有精确的表达occurrence这个概念）
- 例：可以做依据的事物；调查或统计时指合于某种条件的具有代表性的事情，如事例、案例。**根据类型生成的具体对象，根据模板生成的具体函数或根据类型生成的对象算什么“例”？需要调查和统计吗？它们需要代表什么吗？** （其实严格讲起来不是，那个类才是，那个模板才是可以依据的事物，我们构造的那个东西反而不是，所以这个地方用“例”来表达它是不对的，至少是不精确的，那我们实际上构造的是个什么东西呢，**是一个体**，是一个真正存在的活生生的东西）
- 体：事物本身或全部；物质存在的状态或形状；文章或书法的样式或风格；事物的格局与规矩
- 定体：固定不变的形态、性质、体例或体式；尽量不用“实体”，构造出来的函数或类虽然是一个实体，但实体不仅仅值那些，以区分entity（翻译成定体，表示一经构造完毕，那个东西就固定不变了，它的格式是固定不变的，并不意味那个对象的值不变，而是它的型式就固定不变了）
- 象体：按照类型构造的对象定体或对象实体的简称，好于“对象实例”
- 函体：根据函数模板生成的函数定体或函数实体的简称
- 类体：根据类模板生成的类型定体或类型实体的简称；不使用“型体”，因为型并不仅仅只有类
- instantiation：定体化，简称体化，好于“实例化”
- specialization：特体化，简称特化

---老师的观点

### 6.标准模板库

标准模板库的内容
- 标准模板类：复数、序偶

- 迭代器

- 标准容器：向量、表、栈、队列、集合、映射等 
- 标准算法：查找、排序等

标准模板库型式的使用方法

- “<>”：模板名称<**数据对象基型式**> 数据对象名称; 

- 示例一：complex<double> a(1.0, 2.0);

  表示double类型的复数

- 示例二：pair<string, string> name( "Zhang", "San" );

  对于序偶来讲，这两个型并不要求一样

- 示例三：vector<int> v(8);

  表示定义8个元素的整型向量

#### 复数

一般说明
- 头文件：“complex” 
- 模板名：complex<> 

- 基型式：float、double、long double

- 首选double，float精度太低，long double已废弃

实部与虚部

- 成员函数real()与imag()

复数操作

- 复数有一系列的数学操作，这些操作都已经重载了，全部操作均可以按照数学格式进行
- cout、cin均已重载：格式为(real,imag)

#### 序偶

一般说明

为什么叫序偶呢？因为这两个成员的前后关系是非常重要的，第一个就是第一个，第二个就是第二个，这两个是不颠倒的。

- 头文件：“utility” 
- 模板名：pair<>

- 用于表示总是成对出现的两个对象

- 示例一：pair<int, double> a( 1, 1.0 );

- 示例二：pair<string, string> name( "Zhang", "San" );

使用规则

- 公开的数据成员：first、second（如果你看标准模板库的定义的话，序偶本身是用struct定义的）

- 示例：cout << name.first << ", " << name.second; 

  序偶的两个成员每一个都可以直接访问然后直接输出，如果它们的型是已经预定义好了的，或者已经重载了流操作符那么就可以直接输入输出。

- 序偶比较：先比较first大小，相同时比较second大小（first优先决定）

- make_pair：构造序偶的辅助函数

- 示例：pair<int, double> a; a = make_pair( 1, 1.0 );

#### 向量

向量的目的：

\- **替代数组，可以像数组一样使用向量**

（因为C/C++那个数组的分配，它是静态的，它没有办法在程序运行期间自动地适应这个数组的元素个数变化，所以我们才声明了一个动态数组的数据结构，也实现了一个动态数组类）

那么在C++标准库里，它提供了一个更灵活、更强大的机制，这个机制就是向量，它的相当多的运算都已经重载了，使用起来是非常方便的。

**向量的使用**

```c++
- 定义格式：vector<int> v(8); // 包含8个整数元素
  // 注意v(8)是一个vector<int>这个类的对象，这个类的名字就叫vector<int>，少了<int>那不叫类的名字，那是类模板的名字，要给它模板的实际参数才能构造这个实际的类。
- operator[]：已重载，使用格式v[i]访问第i个元素
- 向量可以整体赋值
- size()：返回向量中元素数目
- capacity()：返回向量当前可存储的最多元素数目
  // 与size()求出来的元素个数可能不相同，比如说它比容量少，这是有可能的
- clear()：删除向量所有元素，但不释放向量本身
- resize(int newsize)：重新设置向量容量
```

<font color='00aaee'>接下来，就是最重要的一个概念---迭代器</font>

#### 迭代器

迭代器在C++标准模板库里边起到了一个核心的作用。**迭代器其实就是访问容器中的数据对象的一个技术手段**。

迭代器的性质
- 通过迭代器访问容器中的数据对象
- 类似指针、数组索引的功能：通过指针加减与数组下标运算
获得下一数据对象
- 迭代器可以是指针，但并不必须是指针，也不必总是使用数
据对象的地址（只要能够访问到那个对象，能够访问它的下一个对象，就可以了，不管是哪种技术手段，只要能够访问到它就能够起到迭代器的作用，这是非常重要的一个地方）

迭代器的典型使用方法
- 首先，你必须声明一个迭代器变量

  特别需要强调，对于标准模板库的容器来讲，模板库中的每一个容器都有与它相适应的迭代器，不同的容器，它的迭代器是不一样的，是不可以混用的。

- 第二，使用引领操作符访问迭代器指向的当前目标对象

  在实现上，迭代器类似于一个指针，但是它并不一定是指针，但不管怎样，在迭代器上它重载了引领操作符，重载了引领操作符以后，对于使用者而言，迭代器的表现形式就和指针是一样了。迭代器本身是指向那个容器中的目标数据对象的，所以你引领就得到了容器中的目标数据对象。

- 第三，使用递增操作符获得下一对象的访问权（它重载了递增操作符，那么你就可以在迭代器上利用重载的递增操作符获取下一个对象的访问权）

- 若迭代器新值超出容器的元素范围，类似指针值变成
NULL，目标对象不可引用

迭代器的分类
- 输入迭代器：提供对象的只读访问
- 输出迭代器：提供对象的只写访问
- 前向迭代器：提供对象的正向（递增）读写访问（从前到后，对一个数组来讲，就是从0号元一直到...)
- 双向迭代器：提供对象的正向与反向（递增递减）读
写访问
- 随机访问迭代器：提供对象的随机读写访问

##### 指针作为迭代器

```c++
调用标准模板库的find()函数查找数组元素
#include <iostream>
#include <algorithm>
using namespace std;
const int size = 16;
int main()
{
 int a[size];
 for( int i = 0; i < size; ++i ) a[i] = i;
 int key = 7;
 int * ip = find( a, a + size, key );
 // find()函数的三个参数：第一个，数组首元素的基地址，第二个参数是这个数组的最后一个元素的下一个存储位置的基地址，第三个就是你要查找的那个数据。当然，严格讲起来，find()这个函数它的前两个参数其实传的当然不算数组元素的基地址，而是两个迭代器，我们这里就使用这个指针作为迭代器。第二个参数传的是a+size，这叫过尾元，在使用标准库的时候，要特别注意这一条，它的所有的这样的迭代器这样的容器元素的存储都是使用过尾元的机制，这样的话，它的整个循环架构它是一个半开半闭区间，左边是封闭的右边是开的。
// 过尾元专门用来判定这个数据的集，也就是我们容器中的元素是不是结束了，就用尾元素结尾也可以，但是有的时候有点小麻烦，更重要的，有的时候，我们可能想存储一个指针，我们没有办法用空指针来作为这个容器的结尾标志，因为有的时候空指针也会作为元素存进去，它本身是有意义的，所以这种时候要想判断这个容器是不是结尾，那么使用过尾元其实是更方便的。除此之外，你就得定义一个无定义指针，来表示它的结尾标志，或者结尾指针，那还不如使用过尾元呢。
 if( ip == a + size ) // 不要使用NULL做指针测试，直接使用过尾值
 cout << key << " not found." << endl;
 else
 cout << key << " found." << endl;
 return 0;
}
// find()如果找到了，find()就会返回它所对应的那个元素的基地址，所以你注意，find()这个函数返回值其实也是一个迭代器，它的返回值就是你要查找的那个元素的基地址
```

##### 向量迭代器

```c++
使用迭代器操作向量
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main()
{
 int key = 7;
 vector<int> iv( 10 ); 
 for( int i = 0; i < 10; i++ ) iv[i] = i;
 vector<int>::iterator it, head = iv.begin(), tail = iv.end();
 // vector<int>::iterator这就是完整的迭代器类型，在这个类型上，我定义变量；在向量这个类上，它提供了begin()和end()两个成员函数，end()获得这个向量的过尾元的迭代器，这两个函数返回值都是迭代器。
 it = find( head, tail, key );
 // 找到了返回那个元素的迭代器，没找到返回过尾元对应的迭代器 
 if( it != tail )
 cout << "Vector contains the value " << key << endl;
 else
 cout << "Vector does NOT contain the value " << key << endl;
 return 0;
};

标准模板库最强大的功能，它能够让你与指针一样的方式，来使用标准模板库里面的标准容器。
```

##### 常迭代器

\- **若不想通过迭代器修改目标对象值，定义迭代器常量**（目标数据对象是个const）

```c++
示 例** 
    
-const vector<int>::iterator it;

- 非法操作：*it = 10; // 不能修改常迭代器指向的对象
// 可以引领，但是不能被赋值，可以赋值给别人
```

##### 流迭代器

使用迭代器访问流
- 将输入输出流作为容器(输入输出流本身确实可以作为容器，因为它能够容纳数据，凡是能容纳数据的，我们都可以称为容器)

使用方式：定义流迭代器对象

- 示例一：ostream_iterator<int> oit( cout, " " );

  构造一个输出流迭代器，**并且把这个输出流迭代器和cout挂接在一起，也就是说把cout作为我们的输出流**，每输出一个数据中间都要用" "来分隔

- 示例二（从cin获取数据）：istream_iterator<int> 
  iit( cin );

- 示例三（使用空指针创建流结束迭代器）：

  （就是你可以构造一个不带参数的输入流的对象和输出流的对象，用它来作为流结束的标志）

  istream_iterator<int> iit; （后面没有（），它就没有使用带参数的构造函数版本，使用无参数的构造函数版本来构造一个空对象。它实际上就类似于空指针。相当于向量迭代器的过尾元。

- 凡是可以出现迭代器参数的标准算法都可以使用我们的流迭代器，所以标准算法可以和我们输入输出流直接挂接的。

```c++
#include <iostream>
#include <iterator>
#include <algorithm>
#include <vector>
#include "random.h"
using namespace std;
const int size = 8;
const int lower_bound = 10;
const int upper_bound = 99;
void Display( vector<int> & v, const char * s )
{
 cout << endl << s << endl;
 vector<int>::iterator head = v.begin(), tail = v.end();
 ostream_iterator<int> oit( cout, ";" );
 copy( head, tail, oit );
 // 调用标准算法copy()讲向量里的元素一个接着一个地拷贝到我们的输出流程里，每拷贝一个，插入一个分号。
 // 第三个参数是指想把元素拷贝到哪里去，指向它的原始位置oit，因为是向输出流里拷贝的，所以一拷贝结果就是把这个数据输出到屏幕上了。
 cout << endl; 
}
// 随机生成一系列的整数然后把它保存到向量里，然后对它进行输入输出
```

```c++
int main()
{
 vector<int> a( size );
 for( int i = 0; i < size; ++i )
 a[i] = GenerateRandomNumber( 10, 99 );
 Display( a, "Array generated:" );
 vector<int>::iterator head = a.begin(), tail = a.end();
 sort( head, tail );
 // 调用标准算法库里的sort()，它不是标注库里的那个qsort()，虽说它也是快速排序，它是标准模板库里的sort(),它是一个抽象的排序算法，传的就是head和tail这两个迭代器。它不仅可以对向量进行排序，只要支持迭代器sort()都可以排序，不管它是向量还是我们后面要谈到的表啊，其它什么东西，都可以进行排序。
 // 缺省排序方式是从小到大的
 Display( a, "Array sorted:" );
 reverse( head, tail );
 Display( a, "Array reversed:" );
 return 0;
}
```

##### 输入流迭代器

```c++
#include <iostream>
#include <iterator>
#include <algorithm>
#include <vector>
using namespace std;
int main()
{
 vector<int> v( 4 );
 vector<int>::iterator it = v.begin();
 cout << "Enter 4 ints separated by spaces & a char:\n";
 istream_iterator<int> head( cin ), tail;
 // 定义一个输入流迭代器head，把它和cin挂接在一起；定义一个空的迭代器tail，表示它的结束。head和tail都是输入流的迭代器，head表示输入流的开头，tail表示输入流的结尾
 copy( head, tail, it );
 // 通过键盘输入一系列的整数，中间用空格分开，最后再输入一个字符的时候它就读一个整数把它放到it所指代的那个整型向量里，然后再读一个整数再放进去，一个接着一个地将元素拷贝到我们的整型向量里，数据来源是你通过键盘输入的。
 cin.clear();
 // 输入完后清楚输入流
 cout << "vector = ";
 for( it = v.begin(); it != v.end(); it++ )
 cout << *it << " ";
 cout << endl;
 return 0;
}
```

##### 表

**表：标准模板库中的为双向链表**

```c++
表的使用(和向量类似，但是它的功能要比向量要多，要复杂，在实现上和向量也有很大的不同)
- 定义包含Point对象的容器：list<Point> pts(8);
- 插入：pts.insert( pts.begin(), Point(1,2) );
- 表头插入：pts.push_front( Point(1,2) );
- 插入：pts.insert( pts.end(), Point(1,2) );
- 表尾插入：pts.push_back( Point(1,2) );
- 定义包含Point指针的容器：list<Point*> ppts(8);
- 插入：ppts.insert( ppts.begin(), new Point(1,2) );
  // 插入的是这个对象的地址而不是对象本身
- 插入：ppts.insert( ppts.end(), new Point(1,2) );
- 删除：delete ppts.front(); ppts.remove( ppts.front() );
- 判断表是否为空：if( pts.empty() ) cout << "Empty!";
```

对于一个表的操作来讲，对一个复杂数据结构，我们往往保存的是它的指针，而不是那个对象本身，如果是那个对象本身，它可能会涉及到频繁地数据的拷贝动作，实际上程序效率是不会高的。

表与迭代器：

表的迭代器和向量的迭代器类似，但是它们毕竟是不同的东西。容器和迭代器本身是紧密相关的，因为不同的容器存储那些数据和管理那些数据的方式是不一样的。所以每一个容器都有与它相适应的迭代器。

```c++
- 迭代器可以和表协同工作，方式与向量相同
 list<int> a(8);
 list<int>::iterator it;
 for( it = a.begin(); it != a.end(); it++ )
 	*it = GenerateRandomNumber( 10, 99 );
```

**表排序**

- 直接使用表的成员函数：a.sort(); // 默认升序

- 降序排序之一：升序排序后调用成员函数reverse()

- 降序排序之二（传入函子greater_equal<int>()，标准模板库里为我们提供的标准函子，它是大于等于函子，**用int对这个模板进行体化，在这个模板类上它重载了函数调用操作符**，所以它的很多功能就像函数指针一样）：
 a.sort( greater_equal<int>() );

 传一个通过这个类构造的一个匿名对象作为函数参数传给sort(),sort()就能够按照你指定的方式对这个表进行排序

- 对于自定义对象，需要重载operator<以进行比较（自定义的对象编译器本身是不知道怎么对它进行排序的，所以你必须重载这个操作符）

##### 标准算法

```
查找算法
排序算法
删除和替换算法
排列组合算法
算术算法
关系算法
集合算法
生成和变异算法
堆算法
...
```

所有的这些算法都是抽象的，它完成的是一个抽象的数据的操作。基本上都带迭代器参数；标准模板库里提供的标准算法很多，这些算法的使用相当类似，因为这些算法都有迭代器，按照标准模板库里的说明调用就可以了。

```c++
adjacent_find：查找两个相等或满足特定条件的相邻元素
all_of：当给定区间内全部元素均满足条件时返回true
any_of：当给定区间内至少一个元素满足条件时返回true
binary_search：折半查找，原始数据集已序
copy：复制给定区间内全部元素
copy_backward：反向复制给定区间内全部元素
copy_if：复制给定区间内满足特定条件的元素
copy_n：复制特定位置处开始的指定数目的元素
count：返回给定区间内匹配特定值的元素个数
count_if：返回给定区间内匹配特定条件的元素个数
...
// 84个
```

极大的降低了我们的编程工作量，会用标准模板库是非常非常重要的。

##### 标准函子

```c++
算术函子
- plus<T>、minus<T>、multiplies<T>、divides<T>、
modulus<T>、negate<T>(取负)
关系函子
- equal_to<T>、not_equal_to<T>、greater<T>、
greater_equal<T>、less<T>、less_equal<T>
逻辑函子
- logical_and<T>、logical_or<T>、logical_not<T>
```

### 7.函数模板

接下来讨论怎么设计自己的模板

#### 函数模板

函数模板的目的

- 设计通用的函数，以适应广泛的数据型式

```c++
函数模板的定义格式
- template<模板型式参数列表> 返回值型式 函数名称(参数列表);
- 原型： template<class T> void Swap( T& a, T& b )； 
- 实现： template<class T> void Swap( T& a, T& b ) { ... }

```

函数模板的体化与特化
- 针对特定型参数，在声明或第一次调用该函数模板时体化 
- 每次体化都形成针对特定型参数的重载函数版本(对于一个型T1，它会生成一个体化的函数，对于一个型T2，它会生成一个体化的函数，这两个函数显然是不一样的，因为它们的型不一样，这是两个重载的函数)
- 文件最终只保留特定型参数的一份体化后的函体（ 如果对于同一个型，实际上你生成了好多个体化版本的函数，那么最终它保留其中的一份就够了）
- 显式体化主要用于库设计；显式特化覆盖体化的同型函体（如果它先看到了特化甚至连体化那个版本都不会去做了，就是直接调用你特化那个版本去执行就完了）

```c++
// 函数模板
template< class T > void f( T t ) { /*……*/ }
// 显式体化：使用显式的长整型模板参数(前面加了template，没有<>)
template void f<long> ( long n );
// 显式体化：使用d的型式推导模板参数型式
template void f( double d );

// 显式特化：使用显式的整型参数(template<>显示特化的标志)
template<> void f<int> ( int n );
// 显式特化：使用c的型式推导模板参数型式
template<> void f( char c );
```

交换函数

```c++
template< class T > void Swap( T & a, T & b )
// 这两个数据对象的型被我们参数化，写在模板参数里
{
 // 两个参数的型就是T&、T&，都是对那个T型的引用，函数里就可以使用那个模板参数的型，就相当于那个型已知一样。
 T t; t = a, a = b, b = t;
}
int main()
{
 int m = 11, n = 7; 
 char a = 'A', b = 'B'; 
 double c = 1.0, d = 2.0;
 // 正确调用，体化Swap( int &, int & )
 // 传的是m和n，它发现可以把T替换成int完成这个调用，那么它就会体化这个Swap(int &, int &),体化这个，把这个T全部换成int形成一个函数，然后调用形成后的这个函数
 Swap( m, n );
 // 正确调用，体化Swap( char &, char & )
 Swap<char>( m, n );// 指明让它体化char版本，即用char来替代这个函数模板中的T，生成一个Swap()函数
 // 正确调用，体化Swap( double &, double & )
 Swap<double>( c, d );
 // 不写double可以吗？
 return 0;
}
```

接下来一个重要的概念就是函子

#### 函子

**编写函数，求某个数据集的最小元，元素型式为T**(也就是什么类型都有可能) 

\- **实现策略：使用函数指针作为回调函数参数**，用它来完成具体的数据的操作，这样的话，我们写的原来那个函数才是一个抽象的算法、抽象的函数。

\- **实现策略：使用函子（function object，functor）作为回调函数参数**

```c++
函数指针实现
template< typename T >
// const T * a，a指向这个数据集的基地址；int n表示元素的个数，还有一个比较函数
const T & Min( const T * a, int n, bool (*comparer)(const T&, const T&) )
{
 int index = 0;
 for( int i = 1; i < n; i++)
 {
 if( comparer( a[i], a[index] ) )
     // 调用comparer那个函数指针所指向的比较函数进行两个元素的比较，这里采用的是函数指针的第二种调用形式。
 	index = i;
 }
 return a[index];
}
```

函子有时候也称为函数对象，或者functor。

函子的目的
- 功能上：类似函数指针
- 实现上：它是重载了函数调用操作符的一个类，必要时重载小于比较操作符（当你想用它比较两个对象大小关系的时候，你必须确保你要比较的那两个对象它们所从属的类上具有小于操作符，缺省比较从小到大，需要一个<操作符，如果没有，你必须重载它）

函子的优点
- 函数指针不能内联，而函子可以，效率更高（因为有的时候函子的比较实际上非常非常简单，使用内联程序运行效率能够提升）

- 函子可以拥有任意数量、任意型式的的额外数据，可以保存结果和状态（中间结果、最后结果都可以），提高代码灵活性、代码的质量控制性

- 编译时可对函子进行型式检查

  （函子比函数指针所能做的多的多，也灵活的多）

函子实现

```c++
// 使用方法
int a[8] = { 9, 2, 3, 4, 5, 6, 7, 8 };
int min = Min( a, 8, Comparer<int>() ); 
// 构造匿名函子作为函数参数
// 第三个传一个函子对象，因为这个函子对象仅仅用于Min()函数的这次调用，所以构造一个匿名的函子对象就够了，不需要再给它起一个专门的名字了，在这个函子类上直接调用它的缺省构造函数，构造一个就可以了；这个函子类名字叫什么呢？叫Comparer<int>，后面跟着一个()就构造一个函子类的匿名对象。
```

接下来看Comparer<int>怎么实现

```c++
template< typename T > class Comparer
{
public:
 // 确保型式T已存在或重载operator<
 bool operator()( const T & a, const T & b ) { return a < b; }
 // 重载了一个函数调用的操作符
 // 如果a和b所从属的类是自己定义的，那么想要使用小于操作符必须保证这个类上重载了小于操作符
};
template< typename T, typename Comparer >
// Comparer这个时候它是一个型的名字了
const T & Min( const T * a, int n, Comparer comparer ) {
 // 在内部像函数一样使用这个Comaparer对象，传进来的是一个对象，我们在对象上重载了函数调用操作符
 int index = 0;
 for( int i = 1; i < n; i++)
 {
 if( comparer( a[i], a[index] ) ) index = i;
 }
 return a[index];
}
```

#### 完美转发

完美转发的意义
- 库的设计者需要设计一个通用函数，将接收到的参数转发
给其他函数
- 转发过程中，所有参数保持原先语义不变（原来是啥转发以后就还是啥）

没有右值引用，这个转发是做不到完美的，也就是说，这些属性不可能全部保存下来。所以才有了右值转发，有了右值转发以后因为能够完美地保存原始参数的型式特征，所以我们的构造函数事实上都不需要写那么多

完美转发的实现策略
- 当需要同时提供移动语义与拷贝语义时，要求重载大量建
构函数，编程工作量巨大，易出错
- 右值引用与函数模板相互配合，可以实现完美转发，极大
降低代码编写量

```c++
class A
{
public:
 A( const string & s, const string & t ) : _s(s), _t(t) { }
 A( const string & s, string && t ) : _s(s), _t(move(t)) { }
 A( string && s, const string & t ) : _s(move(s)), _t(t) { }
 A( string && s, string && t ) : _s(move(s)), _t(move(t)) { }
private:
 string _s, _t;
};
```

```c++
int main()
{
 string s1("Hello"); 
 const string s2("World");
 A a1( s1, s2 ); 
 A a2( s1, string("Bingo") );
 A a3( string("Good"), s2 );
 A a4( string("Good"), string("Bingo") );
 return 0;
}
```

有了完美转发和模板完美地配合在一起，我们只需要写一个函数模板

```c++
class A
{
public:
 // 根据实际参数型式生成不同的左值或右值引用的建构函数版本
 // T1或T2可以为不同型，此处相同仅为示例
 // 实参推演时，使用引用折叠机制（这个机制讲起来很复杂，记住如下：当形式参数是右值引用的时候，也就是T&&这种型的时候，当且仅当实际参数为右值或右值引用时，传递的实际参数型式才为右值引用，否则传的据说左值
 // 
 // 引用折叠机制与const/volatile无关，保持其参数性质不变
 // std::forward<T>(t)转发参数的右值引用T&&
 // std::forward 同样是标准库替我们实现的一个转发函数，它的性质和前面那个move()函数非常类似，它转发的就是T的一个右值引用，不管t这个型是什么，它转发出来的结果就会把它转换成T&&，函数内部呢，接收到一个右值引用然后它才能决定它到底用的是右值还是左值。
 // 如果你想实现移动语义，传递一个右值引用，想实现拷贝语义，就传递它的一个左值引用
 template<typename T1, typename T2> A( T1 && s, T2 && t )
 : _s(std::forward<T1>(s)), _t(std::forward<T2>(t)) { }
 // 构造函数一个就够了
 // 它会把它接受过来的s或t，这两个形式参数根据它的特性（它到底是一个左值还是一个右值呢，是个左值引用还是个右值引用呢；根据这个特性自动地转发给_s 和 _t,）
private:
 std::string _s, _t;
};
```

### 8.类模板

类模板的目的

- **设计通用的类型式，以适应广泛的成员数据型式**

```c++
类模板的定义格式
- template<模板形式参数列表> class 类名称{ ... };
- 原型：template<typename T> class A;
```

类模板的成员
- 像普通类的成员一样定义

- 定义在类中或类外均可，后者需要在类名后列些模板参数，
  以区别非模板类的成员函数(需要在类名后面使用模板参数去固定那个类的名字)

- template<typename T> T A<T>::f( T & u ) { }

  返回值类型是T

**类成员函数的模板**

类成员函数本身还可以是模板，甚至可以是和我们这个类模板完全无关的另外一个模板。

\- **成员函数可以使用其他模板**

```c++
template< typename T > class A
{
public:
 template<typename U> T f( const U & u );
};
// 类外定义的时候按这个顺序写
template<typename T> template<typename U>
T A<T>::f( const U & u )
{}
```

类模板的体化
- 与函数模板不同，**类模板体化时必须给定模板实际参数**，不能缺省，它很难去推演，必须给出它的型，以区分它是不同的类。

  如：A<T> a; 

- 类模板体化时，编译器生成模板类或成员函数的代码；**成员**
**函数在调用时体化，虚函数在类构造时体化**

类模板的显式体化
- template class A<int>;（显式的体化了一个类，构造了一个整型的A类）
- 主要目的是为了解决模板库的创建问题，**库的使用者可能没有体化的机会**，而未体化的模板它的定义不会出现在目标文件中 
- 显式体化类模板后，显式体化其构造函数
- 其他成员函数可显式体化，也可不显式体化（需要用就体化）

类模板的显式特化
- 使用特定的型或值显式特化类模板，以定制类模板代码，如：
template<> class A<char> { … };
- 显式特化版本覆盖体化版本
- **显式特化并不要求与原始模板相同，特化版本可以具有不同**
**的数据成员或成员函数**
- 类模板可以部分特化，结果仍是类模板，以支持类模板的部
分定制（如果你在定义这个类模板的时候，它是一个模板套着一个模板，是嵌套模板定义，这同样是合法的，你可以指特化其中的一个部分，剩余部分仍然是模板，所以部分特化的类模板依然是类模板）

定义类模板的时候可以提供缺省的模板参数（后面跟着一个初始化符合，跟着一个缺省的类型的名字或者缺省的值）

\- **与函数模板相同，类模板可以具有缺省模板参数**

来看一个例子：队列

```c++
#include <iostream>
#include <cstdlib>
// 空队列异常类
class EQueueEmpty { };
// 队列项类前置声明
template< typename T > class JuQueueItem;
// 队列类
template< typename T > class JuQueue
{
public:
 JuQueue(): _head(NULLL), _tail(NULL) { }
 virtual ~JuQueue();
 virtual void Enter( const T & item );
 // 一个是入队
 virtual T Leave();
 // 一个是出列
 bool IsEmpty() const { return _head == 0; }
private:
 JuQueueItem<T> *_head, *_tail;
}
```

补充知识：

> C++为我们提供了前置声明。前置声明是什么？举个形象点的例子，就是我要盖一个屋子（CHOuse），光有屋子还不行啊，我还得有床（CBed）。但是屋子还没盖好，总不能先买床吧，床的大小我定了，改天买。先得把房子盖好，盖房子的时候我先给床留个位置，等房子盖好了，我再决定买什么样的床。前置声明就是我在声明一个类（CHouse）的时候，用到了另外一个类的定义（CBed），但是CBed还没有定义呢，而且我还先不需要CBed的定义，只要知道CBed是一个类就够了。那好，我就先声明类CBed，告诉编译器CBed是一个类（不用包含CBed的头文件）

```c++
// 队列项类，单向链表结构
template< typename T > class JuQueueItem
{
 friend class JuQueue<T>;
 // 友元类JuQueue<T>，就把刚才定义的那个队列类模板体化一个<T>，决定它的友元类，JuQueue<T>就是JuQueueItem<T>的友元。
 // 你存了这种型的数据，那么那个队列本身就是它的友元，以方便它访问这里边节点中的数据
public:
 JuQueueItem( const T & item ) : _item(item), _next(0) { }
// _next是指向下一个节点的指针
private:
 T _item;
 JuQueueItem<T> * _next;
};
// 队列类析构函数
template< typename T > JuQueue<T>::~JuQueue()
{
 while( !IsEmpty() )
 	Leave();
}
```

```c++
// 入队
template< typename T > void JuQueue<T>::Enter( const T & item )
{
 JuQueueItem<T> * p = new JuQueueItem<T>( item );
 // 用item初始化它
 if( IsEmpty() ) _head = _tail = p;
 else _tail->_next = p, _tail = p;
}
// 出列
template< typename T > T JuQueue<T>::Leave()
{
 if( IsEmpty() ) throw EQueueEmpty();
 JuQueueItem<T> * p = _head;
 T _retval = p->_item;
 _head = _head->_next;
 delete p;
 return _retval; // 返回出队的项的值
}
```

```c++
int main()
{
 JuQueue<int> * p = new JuQueue<int>;
 for( int i =0; i < 10; i++ )
 	p->Enter( i );
 std::cout << p->Leave() << std::endl;
    
 int * r = new int(10), * q = new int(20);
 JuQueue<int*> * t = new JuQueue<int*>;
 // 存指向那个整数的指针
 t->Enter( r );
 t->Enter( q );
 int * s = t->Leave();
 std::cout << *s << std::endl;
 return 0;
}
```

### 9.元编程

什么是元编程（metaprogramming）？
- 利用模板可以进行编译期计算（数值计算、型式计算和代码
计算）的特点进行程序设计

为什么可以进行元编程？
- C++是两层语言：执行编译期计算的代码称为静态代码，执
  行运行期计算的代码称为动态代码

  上面一层下面一层，下面一层就是我们标准的语言实现逻辑，就是在执行期间运行我们的程序代码，程序运行了，我就执行你的代码，然后得到结果；**还有一层就是它顶层，它执行的是静态代码，这些代码，编译你的程序的时候替你算**，算完以后得到这个结果，就是执行编译期计算的代码。

- 模板可用于函数式编程（functional programming）：
  强调抽象计算，重视模块化，使用递归控制流程

- 已经证明模板是图灵完备的：就是说理论上，你可以使用模板执行任何计算任务，所有的程序代码都可以用模板来实现它，函数式语言能够解决所有的问题。强大功能就体现在这个地方。

补充：

对于程序设计而言，程序员的思维方式实际上是两种，一种是结构化的，一种就是函数式的，结构化的负责完成我们的底层代码，我们的任务的最底层的划分，它的底层代码的构建，每条指令该做什么，第一条指令做什么，第二条指令做什么，第三条指令做什么，怎么组装它们，这个构造就是结构化的，可是顶层的实现逻辑呢，我必须完成我的应用程序的模块化，完成库的架构，而这个架构，理论上我们所有的思考问题的出发点和归宿都是一个又一个的函数，所以这个思维模式本身是函数式的，它的实现策略，函数之间的调用关系，它的那个处理的方式和结构化的那个方式是不一样的，当我们只有C语言的时候，我们只支持结构化的程序设计，那么连我们写函数写库的思维模式都是结构化的。

当我们有了面向对象架构以后，为了完成数据封装与信息隐藏，我们有了类，有了继承，有了多态，这样的架构依然是结构化的，面向对象的代码实现也依然是结构化的，这一点一定要清楚！！！

而只有模板的实现它不是结构化的，它是函数式的。来了一个问题，你解决这个问题，解决这个问题的思考的出发点它是一个归结为一个函数接着一个函数调用的那个动作，普遍使用递归来控制程序的流程，而不是使用循环，这个思维模式是有一个巨大的变化的，我们很少关注细节，而关注一个整体的模块结构，这个就叫函数式程序设计。这是一个相当重要的一个策略，在C++11里，不是提供了 $\lambda$ 表达式嘛，那个东西其实也是函数式设计，虽然它强大，但是和C/C++代码的实际编写的那个流程、底层的结构化的思维模式是格格不入的，把它添进去是四不像，它所带来的好处没有它带来的问题多，让程序员做思维转换在这个上面会吃大苦头，**程序员很难在编程级别完成这个思维转换，除非使用的是一个完全不同的模板架构，强烈支持模板的函数式程序设计，但是强烈地反对在程序代码中提供函数式的功能**，如果我真的需要函数式编程，有的是函数式编程语言可供你选择，而不是使用C++的$\lambda$表达式。

为什么需要元编程？

\- **编译期计算可以使代码更通用，更易用，提升程序执行性能**

但是元编程确实有它自己独有的缺点，因为C++本身并不是为元编程所设计的，它只是提供模板以后产生的一个附加的功能，甚至在C++引入模板的时候，都没有想过C++可以完成元编程，所以它没有为元编程做特定的设计和优化。

元编程的缺点

\- **相对结构化编程，编译效率极低，编译效率超低，因为编译耗费的时间太长了** 

\- **代码丑陋不堪，阅读难、调试难、维护难，易导致代码膨胀**（出了问题你还调试不出来，经常会出现这种情况）

元编程可以做什么？

\- **数值序列计算、素性判定、控制结构、循环展开、型式判定、**

**表达式、编译期多态、特性、策略、标签、元容器、……**

\- **注：对操作系统编程而言，元编程意义不大，一般用到的场合是非常非常受限的**

#### 1）Fibonacci数列

如果想算Fibonacci<3>，它就用3作为i的值，传给这个类模板去体化它，体化出来的结果就是要获取这个value的值，编译的时候它还要去算这个事情，想算Fibonacci<3>的值，那么它必须去算Fibonacci<2>的value值，Fibonacci<1>的value值，把两者之和算出来，一旦它发现这里面有一个Fibonacci<2>，这也是一个类模板的一个体化啊，它会继续体化它，同样的方式把2传进去去体化它，它不就递归的体化这个类模板嘛，一直到它能够得到明确的结论。当然不同的编译器对这个体化的深度，也就是所谓的模板体化深度，它的嵌套的深度有特定的要求。一般像500、800、1000次这个意思，因为太深的话编译时间受不了。就像写递归函数一样，你必须提供递归终止条件，那我们怎么做呢这里，我们就做**类模板的特化**，通过特化给出它的终止条件。

2的版本直接有特化版本，它就不再体化了。

```c++
#include <iostream>
// 类模板，计算Fibonacci数列的第i项
template< int i = 1 > class Fibonacci
// 这个模板有点特殊，它的模板参数不是Typename T,而是固定成整型的i，也就是一个值参数而不是型式参数，缺省值是1。
{
public: enum { value = Fibonacci<i-1>::value + Fibonacci<i-2>::value };
// 这个类里只有一个公有的枚举值value，连这个枚举型的名字都没写，也就是只有一个枚举值value。
// 公开的一个枚举值，这样一个文字，外界就可以访问value
};
// 类模板特化，递归终止条件
template<> class Fibonacci<2> { public: enum { value = 1 }; };
template<> class Fibonacci<1> { public: enum { value = 1 }; };
int main()
{
 std::cout << "Fib(" << 1 << ") = " << Fibonacci<1>::value << std::endl;
 std::cout << "Fib(" << 2 << ") = " << Fibonacci<2>::value << std::endl;
 std::cout << "Fib(" << 3 << ") = " << Fibonacci<3>::value << std::endl;
 std::cout << "Fib(" << 4 << ") = " << Fibonacci<4>::value << std::endl;
 return 0;
}
```

#### 2）素数枚举

这个例子也有点小怪，当然也很有趣

```c++
#include <iostream>
#include <iomanip>
// 素数魔方
// 递归计算p是否为素数；若是，素性判定结论answer为1，否则为0（因为它是个枚举文字值，所以true为1，false为0）
template< int p, int i > struct PrimeMagicCube {
 enum { answer = p % i && PrimeMagicCube<p,i-1>::answer };
};
// 看p能否被所有不大于i的值整除
// p % i只要不是0，它就相当于true，逻辑运算最后得到结果为true或false，最后又会转型成1和0，然后传给answer。
// 这里使用的是struct关键字，没使用class，所以这个东西自动就是public，少写了一行代码。

// 我们可以对这个素数魔方类进行部分特化，以提供它递归终止版本，模板里是双参数，只特化它的一个参数，那不就是部分特化嘛。

// 素数魔方类模板部分特化，递归终止条件，一直递减到1，都没有找到它的因子，都不能整除answer，显然是true。
template< int p > struct PrimeMagicCube<p,1> { enum { answer = 1 }; };
// 数值类模板，输出不大于i的全部素数
template< int i > struct Number {
 Number<i-1> a; // 递归定义数值对象
 // 你想定义数值n，那么在数值n里边就有一个成员，是数值n-1的一个对象，在数值n-1的那个里边，就有一个数值n-2的一个对象。
 enum { answer = PrimeMagicCube<i,i-1>::answer };
 // 你问我i是不是素数，那我们就从i-1开始除起，一直除到1（注：不好含1本身）都不能，编译器就能算出来，answer就是1，在任意一个时刻能够整除，那么这个结论就会变成0，那个0和任何量&&结果不都是0嘛。
 void IsPrime()
 { // 先降序输出全部素数，后升序输出全部数值素性序列
 if( answer ) std::cout << std::setw(4) << std::right << i;
 a.IsPrime(); // 递归调用，计算下一数值的素性
 std::cout << std::setw(2) << answer;
 // 输出素性值，0、1序列
 }
};
// 这些都是在编译器做到的
```

我们的Number这个数值类同样需要提供一个特化的版本

```c++
// 数值类模板特化，终止于2
template<> struct Number<2>
{
 enum { answer = 1 };
 void IsPrime()
 {
 std::cout << std::setw(4) << std::right << 2 << std::endl;
 std::cout << std::setw(2) << answer;
 }
};
int main()
{
 Number<100> a;
 a.IsPrime();
 std::cout << std::endl; 
}
```

### 10.工程实践例子

#### 事件机制

事件基本概念

\- **操作系统或应用程序内部发生某件事，程序的某个组件需要响应该事件，并进行特定处理**，这个处理的方案和方式就叫事件机制

**面向对象架构中，事件响应函数最可能为成员函数**

​	（没有面向对象技术之前，我们只有一个方案，使用函数指针）

- 问题：指向类成员函数的指针不能转换为哑型指针void *，这一点是和普通的函数指针是不一样的，因为它不仅仅包括了那个成员函数的特性还包括了那个类的特性（首先，它有一个指向那个类的对象的指针标记，其次它有那个成员函数在那个对象中的那个属性的描述，它实际上在实现上都不一定是指针，尺寸都有可能是变化的，实现策略和哑型指针是完全不一样的两回事），所以两者不能自如地互相转化，不能转型那就有问题。因为我们响应这个事件的将会是某一个对象的成员函数，而这个对象从属于哪个类不同的时候是不一样的，成员函数名字也有可能不一样，只要那个对象不一样这个事情就大条了。不仅不能转型成哑型指针，也不能随意转换为指向另一个类的成员函数的指针

- 解决方案：当你用对象无法实现的时候，那么你就使用指向对象的指针来实现它，当你用指向对象的指针无法实现的时候，那么你就用指向对象的指针的指针，所以使用指向指向类成员函数的指针的指针，用一个二级指针，**这是非常重要的技巧**

所以在C++里实现事件机制的时候，那么我们在工程实践的场合，需要借助于模板的概念，形成事件委托模型。

实现策略：事件委托模型
- Event类模板：管理事件响应者对象，实现事件多播 
- EventResponsor类模板：响应者对象与响应者行为配对（也就是事件响应者是谁，它的响应行为是哪一个）
- Empty类：委托模型和指针转换

```c++
#include <iostream>
#include <vector>
using namespace std;
// 空类，用于指代响应者对象
class Empty { };
// 事件响应者类模板，保存特定事件的响应者与响应行为
template< typename EventAction > class EventResponsor
{
 // 每一个事件响应者模板，它都保存着特定事件的响应者和它对应的响应行为，所以它包括两个字段，这两个字段为了处理的方便，把它公开了。
public:
 EventResponsor() : actor(NULL), action(NULL) { }
 EventResponsor( Empty * actor, EventAction * action ) : actor(actor), action(action) { }
  // EventResponsor并不负责这两个指针的动态分配与释放的问题
  // 如果是actor只要比较两者是否相等，因为他们都是指向那个对象的指针；而后面那个action存的是二级指针，是指向指向类成员函数的指针的指针，所以我们要比较的时候必须先引领然后再比较，才能看它们是否是同样的一个类的成员函数  
 friend bool operator==( const EventResponsor & lhs, const EventResponsor & rhs )
 { return lhs.actor == rhs.actor && *lhs.action == *rhs.action; }
public: // 公开的数据成员，以方便使用者
 Empty * actor; // 行动者，记录的就是那个对象
 EventAction * action; // 响应行为
 // 当我们最终响应这个行为的时候，我们将在actor这个对象上做这个action，就用这两个属性完成最终的事件响应机制的响应者行为和响应者对象的配对和拼接
}; // template<typename EventAction> class EventResponsor
```

接下来是事件类模板

```c++
// 事件类模板，用于管理特定事件的所有响应者
template< typename EventAction > class Event
{
 // typename 里还是事件活动
public:
 typedef vector<EventResponsor<EventAction> > EventResponsors;
  // 早期的编译器认为>>是一个输入操作符，它会混淆，所以必须加空格，C++11以后的编译器都能处理这个问题，不加空格也行
 typedef typename vector<EventResponsor<EventAction> >::iterator EventIterator;
 // 有的时候，在模板中，我们很难决定一个特定的名字它到底是一个型还是一个量，所以如果你想明确的告诉编译器这是一个型而不是一个量，可以在这个型的名字前面加上type那么
 // 定义两个型，使用向量来构造所有响应同样的事件的响应者，一个事件响应者有很多个的，所以我用一个向量来保存它。<> 里就是那个事件响应者的类型，它是一个模板，每次写那一长串很烦人，所以用typedef给它定义出来EventResponsors，表示一个事件响应者集合
public:
 virtual ~Event()
 {
 for( EventIterator it = this->_ers.begin(); it != this->_ers.end(); ++it )
 {
 delete it->action, it->action = NULL;
 // 一个接着一个的删除它的事件响应者
 // 因为事实上我们只动态构造一个东西，就是action的那个指针，所以我们只要销毁它就行了，它析构的时候，剩下的向量本身由这个事件这个类自动地替我们析构，
 }
 }
 EventResponsors & GetResponsors() { return this->_ers; }
```

最重要的两个函数来了：

```c++
// 事件绑定，将实际响应者和响应行为挂接到事件响应者对象上
// 传两个模板的形式参数，一个是Responsor响应者，一个是响应者的活动Action；它们的类型注意和我们前面那个并不完全匹配，它也并不需要完全匹配，这只是模板的形式参数
 template< typename Responsor, typename Action >
 void Bind( Responsor * actor, Action action )
 {
  // 那个活动本身就是一个指针了，它是指向类成员函数的指针，所以不需要再用指针来了，我们传进来不需要，我们内部会new它的
 Action * act = new Action( action );
 // 构造一个指向指向类成员函数的指针的指针
     
 EventResponsor<EventAction> er( (Empty*)actor, (EventAction*)act );
 bool unbound = true;
 for( EventIterator it = this->_ers.begin(); it != this->_ers.end(); ++it )
 {
 // 相等就表示这个事件响应者对象已经被我们在向量列表中绑定进去了，已经有了actor是一样的，它对应的action也是一样的
 if( *it == er ) // 发现重复的事件响应者，说明已绑定
 {
 unbound = false; 
 break;
 }
 }
 if( unbound )
 	this->_ers.push_back( er );
 else
 	delete er.action, er.action = NULL;
     // 销毁我们新构造的这个act内存区域
 }
```

```c++
 // 解除事件绑定，删除事件响应者对象
 template< typename Responsor, typename Action >
 void Unbind( Responsor * actor, Action action )
 {
 Action * act = new Action( action );
 EventResponsor<EventAction> er( (Empty*)actor, (EventAction*)act );
 for( EventIterator it = this->_ers.begin(); it != this->_ers.end(); ++it )
 {
 if( *it == er ) // 找到待删除的事件响应者对象
 {
 delete it->action, this->_ers.erase( it ); 
 // 把这个迭代器所指向的这个对象从向量中给擦掉
 break;
 }
 }
 delete er.action, er.action = NULL;
 // 不管怎样，要删除新构造出来的这个act那个对象
 }
private:
 EventResponsors _ers;
// 某一个特定的事件，它有一个对应的事件响应向量，这里面包括了很多个事件响应者，每一个事件响应者都会对这个事件作出响应，只要你把那个事件响应者绑定到这个事件里来，就是插入到这个事件这个类的那个对象 EventResponsors _ers 里去
}; // template<typename EventAction> class Event
```

现在来看怎么用它

```c++
// 定义事件委托模型
typedef Empty EventDelegator;
// 定义指向类成员函数的指针型ValueChanged，所以要在前面给它定义好它的类，这个类呢就是我们的事件委托者类EventDelegator
typedef void ( EventDelegator::*ValueChanged )( int value, void * tag );
// value就是那个值发生变化以后它的新值，tag就是一个附加的参数

// 触发者
class Trigger
{
public:
 Trigger() : _value(0) { }
 void SetValue( int value, void * tag );
 int GetValue() { return _value; }
public:
 // 值变化事件，公开属性，方便在类外设定
 Event<ValueChanged> value_changed;
 // 当值发生变化的时候，这个value_changed这样的一个值发生变化的属性里所有的事件响应者都必须做出行动，所以这个属性我们要用Event <ValueChanged> 这样的一个事件型对它进行定义
// 理论上这是一个属性定义为公开的不是不好嘛，但实际上为了方便我们应用，如果要严格地保持它的数据封装与信息隐藏的话，那么事实上我们最好的方案就是把它定义成protected
private:
 int _value;
 // 用它来保存这个对象的一个特定的值，这个值如果发生变化它就会产生一个值发生变化的事件，也就是所谓的值变更事件
};
```

现在来实现它最重要的一个函数SetValue()

```c++
// 每设定一个新值，它就会遍历特定事件的响应对象列表，逐一触发值变更事件（一个接着一个地调用里边事件响应者的成员函数）
void Trigger::SetValue( int value, void * tag )
{
 if( _value == value )
 	return;
 _value = value;
 Event<ValueChanged>::EventResponsors ers;
 ers = this->value_changed.GetResponsors();
 // 如果这个向量非空，那么我们就定义一个迭代器
 if( !ers.empty() )
 {
 Event<ValueChanged>::EventIterator it;
 for( it = ers.begin(); it != ers.end(); ++it )
 {
 // 每找到一个事件响应者，我们就调用它的事件响应函数，响应我们这个值变更事件，循环做的就是这个事
 // 问题是怎么调用，这是事件机制里最难的一个位置
 ( ( it->actor )->*( *( it->action ) ) )( value, tag ); // 响应事件
 // 现在我们得到的就是那个actor对象的指向类的成员函数的指针，我们要在这个基础上调用它的成员函数，怎么调用呢？在外面封装一个括号，这样你就可以把它当做一个普通的函数一样用了，然后我们后边传两个参数value、tag;最外面的括不能省略，里面都可以省略
 }
 } }

// it相当于指向那个事件响应者的指针，那个事件响应者是什么，是EventResponsor，我们在这个向量里存的是EventResponsor，当然它依然是一个类模板，所以实际上存的是EventResponsor<ValueChanged>，响应这个值变更事件的事件响应者们，每一个事件响应者里有两个成员，一个actor，一个action，一个是指向响应这个行动的那个对象的指针，一个是指向指向响应行动函数的指针的指针
// ( it->actor )->*( *( it->action ) )这才得到指向actor这个对象的那个类的成员函数的指针，严格讲起来实际上是在actor这个对象上调用指向它的类的成员函数的指针；其实这几个括号都可以不写，因为优先级很碰巧，->优先级最高，其次是“*”，再次是“->*”，
```

trigger，这是一个触发值变更事件的一个对象，当它设定它的_value值的时候，它就会产生一个值变更事件，所以SetValue负责所有事件响应者的响应行动的那个调用。

接下来是actor行动者的定义

```c++
// 行动者
class Actor
{
public:
 // 侦听事件,绑定本对象的事件响应函数到侦听的事件
 // 我们要侦听这个事件，那么这个事件由谁导致的呢，当然是触发器，我们就侦听这个trigger对象的事件，所以我们要在trigger上调用它的value_changed这个属性的Bind()成员函数，将Actor这个行动者绑定到它的那个值变更事件上，所以它需要传两个参数，一个是它自己this，第二个就是响应这个值变更事件的那个事件响应函数的入口地址
// 把自己和响应那个事件的自己的那个成员函数绑定到触发器对象上，这样的话就把这个事件响应函数写到了那个触发器对象的事件响应列表里
 void Listen( Trigger * trigger )
 { trigger->value_changed.Bind( this, &Actor::OnValueChanged ); }
 // 停止侦听，从侦听的事件中取消绑定本对象的事件响应活动
 void Unlisten( Trigger * trigger )
 { trigger->value_changed.Unbind( this, &Actor::OnValueChanged ); }
 // 值变更事件的响应函数
 void OnValueChanged( int value, void * tag )
 { cout << reinterpret_cast<char*>(tag) << value << "." << endl; 
  // 附加参数void * tag传的是什么呢，传的就是额外的字符串信息，所以我们这里要把它转换成char *
 }
};
```

接下来主函数：

```c++
int main()
{
 const char * s = "Now the value is ";
 Trigger t;
 Actor a1, a2;
 a1.Listen( &t );
 a2.Listen( &t );
 cout << "Listening..." << endl;
 t.SetValue( 10, reinterpret_cast<void*>( const_cast<char*>(s) ) );
 // s字符串先做一次常量转型然后再做一次复诠转型，把它转成哑型指针作为附加参数传进去，虽然很麻烦，但是这是最科学最安全的方法，
 a2.Unlisten( &t );
 // a2这个对象将从t这个对象的事件响应者列表中被删除
 cout << "Listening again..." << endl;
 t.SetValue( 20, reinterpret_cast<void*>( const_cast<char*>(s) ) );
 return 0;
}

```

事件机制一定要掌握，尤其是指向类的成员函数的指针的用法，在一些复杂的程序架构里，没有它是很难实现的。

## 十二.Linux系统编程基础

### 1.程序执行环境

#### 参数列表

Linux命令行规范

\- **短参数：以单横开头，后跟单一字符，例：ls -h**

\- **长参数：以双横开头，后跟字符串，例：ls --help**

补充：

> ## 短参数（一个字母）[#](https://www.cnblogs.com/liuawen/p/12854043.html#857190276)
>
> 最常用的参数形式就是一个短横线后接一个字母。格式例如：
>
> ```bash
> command -a
> ```
>
> 如果我们要一次加好几个短参数，可以用空格隔开，例如：
>
> ```bash
> command -a -b -C -c
> ```
>
> 多个短参数也可以合并在一起，例如上面的命令等价于：
>
> ```bash
> command -abCc
> ```
>
> 请注意：参数的字母的大小写是有区别的，大写的 C 和小写的 c 通常表示不同意思。
>
> `ls`命令没有返回任何信息，不一定就说明当前目录下什么也没有，有可能当前目录只包含隐藏文件。
>
> ## 长参数（多个字母）[#](https://www.cnblogs.com/liuawen/p/12854043.html#3234783514)
>
> 短参数是以一个短横线`-`开始，而长参数是以两个短横线`--`开始的。格式例如：
>
> ```zsh
> command --parameter
> ```
>
> 如果有多个长参数`-- --`，是不能像多个短参数那样合并写的。我们只能以空格隔开写，格式例如：
>
> ```zsh
> command --parameter1 --parameter2
> ```
>
> 我们也可以组合使用短参数和长参数，格式例如：
>
> ```zsh
> command -paTc --parameter1 --parameter2
> ```
>
> 有时候，同一个意义的参数有短参数和长参数两种形式，效果是一样的，可以任选哪一种。比如`ls -a` 和 `ls --all`是一个作用的，都是列出当前目录下的所有文件，包括隐藏文件什么`.` `..`的。
>
> 要`ls --all`哦 ，`ls -al`是列出当前目录下的所有文件的详细信息包括隐藏文件，也可写作  ls -a  -l     或ls --all -l。
>
> ```bash
> ls-all 
> linux没有这个命令，估计是自己写的脚本或者别名，
> 例如 alias ls-all='ls --all'
> ll 是个别名，通过which ll，可以看出：alias ll='ls -l --color=auto'
> ```
>
> 不是所有的Linux命令都遵循以上的规则，例如：
>
> ```bash
> find -type d -mindepth 2
> find命令的参数：
> -type    b/d/c/p/l/f      
> #查是块设备、目录、字符设备、管道、符号链接、普通文件
> -depth                       
> #使查找在进入子目录前先行查找完本目录
> -mindepth 2，个人理解是最少查找到2级子目录
> ```
>
> 

**程序访问参数列表的方法**

首先，main()函数的那个参数，它其实是可以带两个参数的。

\- 主函数的参数argc和argv（这两个参数其实就表达了Linux命令行里后面带的那些附加的参数）

\- 程序接受命令行的输入参数，并解释之（我们在程序中就可以通过分析argc、argv这两个参数来获取命令行里提供的那些参数的列表）

```c++
编写程序，输出命令行参数
#include <iostream>
using namespace std;
int main( int argc, char* argv[] )
{
 // argc 表达main函数的参数有几个，这个参数包含命令本身，所以命令本身是它的第0个参数
 // 这些参数存在argv里，argv是一个字符串数组，每一个字符串都是以“\0”结尾的；在所有的这些字符串都结尾以后，再用一个“\0”来结尾，表达它的全部字符串的结束
 // argc = 1，说明只有命令本身，它后面没有其它参数了
 cout << "The program name is " << argv[0] << "." << endl;
 if( argc > 1 )
 {
 cout << "With " << argc - 1 << " args as follows:" << endl;
 for( int i = 1; i < argc; ++i )
 cout << argv[i] << endl;
 }
 else
 cout << "With " << argc - 1 << " arguments." << endl;
 return 0;
}
```

那么我们怎么在程序中分析我们的参数列表呢？**Linux操作系统为我们定义了一个结构体，这个结构体的名字叫option。使用它就可以分析Linux命令在程序执行过程中所提供的那些参数**。这个结构体定义在“getopt.h”这个头文件里。

**选项数组的定义**

- 结构体类型option：系统已定义，直接使用即可

```c++
// 头文件：“getopt.h”
// option包括了四个字段
struct option
{
 // 选项长名称
 const char * name;
 // 该选项是否具有附加参数；0：无；1：有；2：可选（也许有也许没有）
 int has_arg;
 // 指向整数，用于保存val值，有时候需要用它，有时候不需要，设为0
 int * flag;
 // 选项短名称
 int val;
};
```

分析Linux命令行参数列表的那个函数，名字叫getopt_long()。

函数getopt_long()
- 函数原型：int getopt_long( int argc, char * 
  const * argv, const char * short_options, const
  struct option * long_options, int * long_index );

  长选项它是一个指向option结构体的指针

  **最后那个参数用来表达的就是它那个长选项在那个选项数组里边的对应的索引**

- 调用时**每一次它会分析出Linux命令行里边的一个参数**，如果参数是合法有效的，它就会返回那个参数所对应的短选项那个字符，**不存在时返回 -1** 
- 如果在参数列表中提供的是长选项，那么它的第五个参数就会输出那个长选项在长选项数组中的索引，这样的话，你就能够查找到它对应的**短（应该是长**，老师讲错了感觉）选项的名称和其它附加信息。

**参数处理方法**

- 使用循环处理所有参数

- 如果遇到错误选项，输出错误消息并终止程序执行
- 处理附加参数时，**用全局变量optarg来获取它那个附加参数的基地址**
- 完成所有处理后，全局变量optind存储首个**非可选参数的索引**

**编写程序，接受如下三个选项并执行正确操作**

```bash
 -h / --help：显示程序的帮助信息并退出
 -o filename / --output filename：指定文件名
 -v / --verbose：输出复杂信息，缺省情况下这些复杂信息我们是不输出的，如果你设定了这个开关，那么在程序运行过程中就会输出复杂信息，这样就能帮助你调试你的程序代码
```

```c++
#include <iostream>
#include <cstdlib>
// 在C++中也可以使用#include <stdlib.h>，因为C++兼容了C语言中的操作。不过一般更推荐使用C++风格的头文件，即#include <cstdlib>。cstdlib实现了stdlib.h中的所有功能，不过是按照C++的方式写的，所以与C++语言可以更好的配合。
#include <getopt.h>
using namespace std;
const char * program_name; // 存储这个程序的实际名字

// 输出程序用法
void OutputInfo( ostream & os, int exit_code ) {
 os << "Usage: " << program_name << " options [filename]" << endl;
 os << " -h --help: Display this usage information." << endl;
 os << " -o --output filename: Write output to file." << endl;
 os << " -v --verbose: Print verbose messages." << endl;
 exit( exit_code );
}
```

```c++
int main( int argc, char* argv[] )
{
 // 全部短选项的合并字符串，“:”表示带有附加参数
 const char * const short_opts = "ho:v";
 const struct option long_opts[] =
 {
 // 0表示没有附加参数，1表示有附加参数
 { "help", 0, NULL, 'h' },
 { "output", 1, NULL, 'o' },
 { "verbose", 0, NULL, 'v' },
 { NULL, 0, NULL, 0 }
 // 用来表达这个长选项数组结束了
 };
 // 参数指定的输出文件名
 const char * output_filename = NULL;
 // 是否显示复杂信息
 int verbose = 0;
 // 保存程序名
 program_name = argv[0];
 // 如果为长选项，第五个参数输出该选项在长选项数组中的索引
 int opt = getopt_long( argc, argv, short_opts, long_opts, NULL );
 // 一次只能处理一个，返回的就是对应那个option那个选项，那个选项处理的是第一个，然后根据它的选项的返回值看它是不是-1，如果是 -1 就说明处理完了，如果不是我们就要一个接着一个地去处理
while( opt != -1 ) {
 	switch( opt ) {
 	case 'h': // “-h”或“--help”
 		OutputInfo( cout, 0 );
 	case 'o': // “-o”或“--output”，附加参数由optarg提供
 		output_filename = optarg; break;
 	case 'v': // “-v”或“--verbose”
 		verbose = 1; 
         break;
 	case '?': // 用户输入了无效参数
 		OutputInfo( cerr, 1 );
 	case -1: // 处理完毕
 		break;
 	default: // 未知错误
 		abort();
 }
 opt = getopt_long( argc, argv, short_opts, long_opts, NULL );
 }
 return 0;
}

```

#### 环境变量

典型Linux环境变量
- USER：你的用户名
- HOME：你的主目录
- PATH：分号分隔的Linux查找命令的目录列表

shell处理
- shell编程时查看环境变量：echo $USER
- 设置新的环境变量：EDITOR=emacs; export 
EDITOR或export EDITOR=emacs

**环境变量内部定义格式：VARIABLE=value**

​		使用getenv()函数返回**环境变量的值**

事实上，linux全部的环境变量都是使用全局变量environ保存起来的，可以直接使用。

```c++
#include <iostream>
using namespace std;
// 在实际访问和操作环境变量的时候，你就应该导入这个变量
extern char ** environ;
// 和argv性质是一样的
int main()
{
 char ** var;
 // 一个字符串，一个字符串地区处理它
 for( var = environ; *var != NULL; ++var )
 	cout << *var << endl;
 return 0;
}
```

**编写客户端程序，在用户未指定服务器名时使用缺省服务器名称**

```c++
#include <iostream>
#include <cstdlib>
int main ()
{
 // 理论上，当这个服务器运行的时候，它会提供一个环境变量SERVER_NAME，getenv这个函数区查询这个服务器的名字，查询到的结果就传给server_name，如果server_name被赋值了，说明它定义了，它定义了的话我们直接就用，如果没查到就使用缺省的名字
// getenv()这个函数用变量的名字作为一个字符串传进去查询，它得到的结果就是它那个值所对应的字符串
 char * server_name = getenv( "SERVER_NAME" );
 if( !server_name )
 // SERVER_NAME环境变量未设置，使用缺省值
 	server_name = "server.yours.com";
 cout << "accessing server" << server_name << endl;
 // ……
 return 0;
}
```

#### 程序退出码

 每一个程序在运行结束的时候它都有一个退出码，对于程序来讲，退出码就是它结束时传递给操作系统的那个整型数据。

**程序：结束时传递给操作系统的整型数据**

- 实际上是main()函数的返回值 
- 其他函数也可以调用exit()函数返回特定退出码 （但有的时候因为我们程序main()函数没结束而是提前终止的，所以调用exit()的时候它也会将退出码传给我们的操作系统，就在main函数之外，其它函数都可以调用exit()，在程序流程出现异常的时候，返回一个退出码给操作系统）
- 退出码的变量名称经常为exit_code（不用这个也可以，用最好了）
- **应仔细设计程序退出码，确保它们能够区分不同错误**（0表示有错误，非0表示有错误，正确的路只有一条，错误的路有很多，要分清它到底是因为什么样的错误才退出的，所以不同的错误理论上应该给出不同的错误码并且写成一个帮助手册）

操作系统：响应程序退出码，如果必要，执行后续处理，有时就是简单地传给下一个程序，让下一个程序能够查询到就可以了（大部分时候操作系统是不关心你程序的退出码的）

- shell编程时查看上一次退出码的命令：echo $?

#### 系统调用错误处理

在进行系统编程的时候，你可能需要频繁地进行系统调用，系统调用就有可能导致问题，因为涉及到操作系统的核心概念，所以它产生的问题是非常非常复杂的，所有的这些系统调用，它产生的错误都应该被处理，因为它们大部分的时候都涉及到了资源的访问，**系统调用本身就是访问系统资源的主要手段**。

**实现逻辑**

\- C程序使用断言，C++程序使用断言或异常处理机制（使用后者比前者更高级一些，**尤其涉及到类库的架构的时候，使用异常处理机制其实是更自然的选择**）

两个主要问题
- 系统调用：访问系统资源的手段
- 系统调用失败原因：资源不足；因权限不足而被阻塞；调
用参数无效，如无效内存地址或文件描述符；被外部事件
中断；不可预计的外部原因（所以为了保持你的程序健壮性，显然你必须处理这些错误）
- 资源管理：已分配资源必须在任何情况下都能正确释放

**Linux使用整数表示系统调用错误**

- 标准错误码为以“E”开头的全大写宏 
- 宏errno（使用方法类似全局变量）：表示错误码，位于
头文件“errno.h”中 （专门用来表达最后一次发生的那个错误的错误码）
- 每次错误都重写该值，处理错误时必须保留其副本
- 函数strerror()：返回宏errno**对应的错误说明字符串**，
位于头文件“string.h”中（包含的时候应该写cstring，因为在C++里还有一个“string.h”头文件）

在进行系统错误处理的时候，实际上是相当复杂的。

```c++
// 将指定文件的拥有者改为指定的用户或组；第一个参数为文件名，
// 第二和第三个参数分别为用户id和组id，如果参数owner或group中的任意一个是-1,则对应的ID不变
rval = chown( path, user_id, -1 );
// 一旦成功，返回0，一旦错误，会返回-1，
if( rval ) {
 // 必须存储errno，因为下一次系统调用会修改该值
 int error_code = errno;
 // 操作不成功，chown将返回-1
 assert( rval == -1 );
 // assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。如果表达式不为0，则继续执行后面的语句
 // 检查errno，进行对应处理
 switch( error_code )
 {
 case EPERM: // 操作被否决
 case EROFS: // PATH位于只读文件系统中
 case ENAMETOOLONG: // 文件名太长
 case ENOENT: // 文件不存在
 case ENOTDIR: // path的某个成分不是目录
 case EACCES: // path的某个成分不可访问
 	cerr << "error when trying to change the ownership of " << path;
 	cerr << ":“ << strerror( error_code ) << endl;
 	break;
 case EFAULT: // path包含无效内存地址，有可能为bug
 	abort ();
 case ENOMEM: // 核心内存不足
 	cerr << strerror( error_code ) << endl;
 	exit( 1 );
 default: // 不可预见错误，最可能为程序bug
 	abort ();
 };
}
```

#### 资源管理

**在系统调用过程中必须明确管理的资源类型**

\- 内存、文件描述符、文件指针、临时文件、同步对象等等

资源管理流程
- 步骤1：分配资源
- 步骤2：正常处理流程
- 步骤3：如果流程失败，释放资源并退出，否则执行正常
处理流程
- 步骤4：释放资源
- 步骤5：函数返回

```c++
char * ReadFromFile( const char * filename, size_t length )
{
 char * buffer = new char[length];
 // 内存分配给缓冲区，这是资源
 if( !buffer )
 	return NULL;
 int fd = open( filename, O_RDONLY ); // 以只读模式打开文件，这是资源
 if( fd == -1 ) {
 	delete[] buffer, buffer = NULL;
 	return NULL;
 }
 size_t bytes_read = read( fd, buffer, length );
 if( bytes_read != length ) {
 	delete[] buffer, buffer = NULL;
 	close( fd );
 	return NULL;
 }
 close( fd );
 return buffer;
}
```

#### 系统日志

**日志：系统或程序运行的记录**

系统日志进程：syslogd/rsyslogd
- 两者均为守护（daemon）进程，即在后台运行的进程，没
有控制终端，也不会接收用户输入，父进程通常为init进程（即0号进程）
- 日志文件一般为“/dev/log”，实质上是一个设备，日志信息一般保存在“/var/log/”目录下 ，目录下你可以设置日志文件的名字叫什么。
- rsyslogd既能接收用户进程输出的日志，也能接收内核日志；
在接收到日志信息后，会输出到特定的日志文件中；日志信
息的分发用户可自己配置

日志生成函数：syslog()
- 头文件：“syslog.h” 

- 原型：void syslog( int priority, const char * msg, … );

  msg是它的日志的信息的构造，它是一个结构化的输出，就像printf()一样

- 可变参数列表，用于结构化输出

- priority：日志优先级，往往是一个特定的设施值（一般默认为LOG_USER）与它的日志级别的**位或** 

- 日志级别：LOG_EMERG（0，系统不可用）、LOG_ALERT
（1，报警，需立即采取行动）、LOG_CRIT（2，严重情况）、LOG_ERR（3，错误）、LOG_WARNING（4，警告）、LOG_NOTICE（5，通知）、LOG_INFO（6，信息）、LOG_DEBUG（7，调试）

0级是最重要的

日志打开函数：openlog()
- 原型：void openlog( const char * ident, int logopt, int
facility );
- **改变syslog()函数的默认输出方式**，以进一步结构化日志内容
- ident：标志项，指定添加到日志消息的日期和时间后的字符串
- logopt：日志选项，用于配置syslog()函数的行为，取值为
LOG_PID（在日志消息中包含程序PID）、LOG_CONS（如果日志不能记录至日志文件，则打印到终端）、LOG_ODELAY（延迟打开日志功能，直到第一次调用syslog()函数）、LOG_NDELAY
（不延迟打开日志功能）的位或 
- facility：用于修改syslog()函数的默认设施值，一般维持
LOG_USER不变

日志过滤函数：setlogmask()
- 原型：int setlogmask( int maskpri );
- 设置日志掩码，大于maskpri的日志级别信息被过滤
- 返回值：设置日志掩码前的日志掩码旧值

日志关闭函数：closelog()

\- 原型：void closelog();

#### 用户信息

UID、EUID、GID和EGID
- 每个进程拥有两个用户ID：UID（真实用户ID）和EUID
（有效用户ID） 
- EUID的目的：方便资源访问，**运行程序的用户拥有该程序**
**有效用户的权限**（站在操作系统的角度上看，用于给操作系统判断某个进程是否拥有操作某个文件的权限）
- 组与用户类似(有一个组id，还有一个有效组id)

用户信息处理函数
- 获取真实用户ID：uid_t getuid();
- 获取有效用户ID：uid_t geteuid();
- 获取真实组ID：gid_t getgid();
- 获取有效组ID：gid_t getegid();
- 设置真实用户ID：int setuid( uid_t uid );
- 设置有效用户ID：int seteuid( uid_t uid );
- 设置真实组ID：int setgid( gid_t gid );
- 设置有效组ID：int setegid( gid_t gid );

```c++
程序示例
#include <unistd.h>
#include <stdio.h>
int main()
{
 uid_t uid = getuid(), euid = geteuid();
 printf("uid: %d; euid: %d\n", uid, euid );
 return 0;
}
```

```bash
gcc main.c
sudo chown root:root ./a.out
# 命令格式：
# chown [选项]... [所有者][:[组]] 文件...
sudo chmod +s ./a.out
# “为了方便普通用户执行一些特权命令，SUID/SGID程序允许普通用户以root身份暂时执行该程序，并在执行结束后再恢复身份。”
# chmod u+s 就是给某个程序的所有者以suid权限，可以像root用户一样操作,g＋s设置组ID位

# 这样只改变它的euid，uid不改变。
注意：SUID只能用于可执行文件，其作用是修改EUID（有效用户id）
```

### 2.输入输出

#### 标准输入输出流

标准输入流：stdin/cin

标准输出流：stdout/cout

- 数据有缓冲，在缓冲区满、程序正常退出、流被关闭或强
制刷新（fflush()函数）时输出
- 等到缓冲区满后同时打印多个句号：while(1) 
{ printf( "." ); sleep(1); }

标准错误流：stderr/cerr
- 数据无缓冲，直接输出
- 每秒打印一个句号：while(1) { fprintf( stderr, "." ); 
sleep(1); }

理论上，标准输出流是有缓冲的，而标准错误流是无缓冲的。

#### 文件描述符

文件描述符的意义与目的：在程序中代表文件（用文件描述符来表达底层的资源概念）
- 内核为每个进程维护一个文件打开记录表，文件描述符为
该文件在文件记录表中的索引值

文件描述符为非负整数，范围从0至OPEN_MAX
- 不同操作系统可能具有不同范围，可以同时打开的文件数
  目不同

  (在linux系统中所有的东西都是文件，都可以使用文件描述符来描述它)

文件描述符的缺点
- 非UNIX/Linux操作系统可能没有文件描述符概念，**跨平**
**台编程时**建议使用C/C++标准库函数和文件流类（写程序时**尽量不用文件描述符**）

预定义的标准输入输出流的文件描述符

- 标准输入流stdin：STDIN_FILENO（0） 
- 标准输出流stdout：STDOUT_FILENO（1） 
- 标准错误流stderr：STDERR_FILENO（2）

文件描述符的创建
- Linux中凡物皆文件，操作系统使用统一方式管理和维护系统资源
- （打开一个系统资源，它就会为它创建一个文件描述符）所以很多函数它的系统调用都会打开一个文件描述符，通过打开文件或设备的方式创建文件描述符（很多这样的函数都会做这个事情，它都会返回一个文件描述符，一旦你打开一个文件或设备，它就会创建一个文件描述符给你，然后你就可以用这个文件描述符来操纵那个文件或设备了，所以文件描述符在Linux底层设计的时候是非常非常重要的）

#### I/O函数

基本与高级I/O函数
- 打开关闭函数open()和close()：前者头文件“fcntl.h”，
  后者头文件“unistd.h” 

- 读写函数read()和write()：头文件“unistd.h” 

- 读写函数readv()和writev()：头文件“sys/uio.h” 

  （分散读、集中写函数）

- 文件发送函数sendfile()：头文件“sys/sendfile.h” 

- 数据移动函数splice()：头文件“fcntl.h” 

- 数据移动函数tee()：头文件“fcntl.h” 

- 文件控制函数fcntl()：头文件“fcntl.h”

打开文件函数open()
- 原型：int open( const char * filename, int oflag, … );
- 目的：打开filename指定的文件，返回其文件描述符，oflag
为文件打开标志
- 若文件支持定位，读取时从当前文件偏移量处开始
- 文件打开标志：O_RDONLY（只读）、 O_WRONLY（只
写）、 O_RDWR（读写）等

关闭文件函数close()
- 原型：int close( int fd );
- 目的：关闭文件描述符fd所代表的文件

读函数read()
- 原型：ssize_t read( int fd, void * buf, size_t count );
- 目的：将count个字节的数据**从文件描述符fd所代表的文件中读入buf所指向的缓冲区**
- 若文件支持定位，读取时从当前文件偏移量处开始
- 返回值：读取的字节数，0表示文件结尾，失败时返回-1并设置errno

写函数write()
- 原型：ssize_t write( int fd, const void * buf, size_t count );
- 目的：将count个字节的数据**从buf所指向的缓冲区写入**文件描述符fd所代表的文件中 
- 参数与返回值的意义与read()相同或类似

要想提升效率，可以用分散的读函数readv()和集中写函数writev()；因为从文件中一读就读好多块，一写呢就集中地把好多块数据就全写出去了。

分散读函数readv()
- 原型：ssize_t readv( int fd, const struct iovec * iov, int iovcnt );

  不仅带有参数文件描述符，它还带着这个数据的读写的来源或者目的；分散读时把数据读进来以后分散地写到iov所代表的那个数据的数组里，iov是const struct 的这样一个数组，这个数组中的每一个成员都是struct iovec，输入输出向量，它会带两个字段

  > 结构体数组的每一个元素都是一个结构体类型的变量，都包含结构体中所有的成员项。
  >
  > ```c++
  > struct STUDENT stu[10];
  > ```
  >
  > 

- 目的：将数据从文件描述符所代表的文件中读到分散的内存块中 

- 参数：fd为文件描述符；**iov为写入的内存块结构体数组，每个数组元素只有内存基地址iov_base和内存块长度iov_len两个字段**，iovcnt为读取的元素个数

- 返回值：读取的内存块数，失败时返回-1并设置errno

集中写函数writev()
- 原型：ssize_t writev( int fd, const struct iovec * iov, int iovcnt );
- 目的：将数据从分散的内存块中写入文件描述符所代表的文件中 
- 参数与返回值的意义与readv()相同或类似

文件发送函数sendfile()
- 原型：ssize_t sendfile( int out_fd, int in_fd, off_t * offset, int
count );
- 目的：在两个文件描述符所代表的文件间直接传递数据，以避免内核缓冲区和用户缓冲区之间的数据拷贝，提升程序效率（相当于共享）；**为网络文件传输而专门设计的函数**
- 参数：out_fd为目的文件描述符；in_fd为源文件描述符；offset指定读取时的偏移量，**为NULL表示从默认位置开始读取**；count为传输的字节数 
- 返回值：传输的字节数，失败时返回-1并设置errno

注意事项
- in_fd必须为支持类似mmap()函数（像内存映射这样的函数）的文件描述符，即必须代表真实的文件，不能为套接字和管道；out_fd必须为套接字

数据移动函数splice()
- 原型：ssize_t splice( int fd_in, loff_t * off_in, int fd_out, loff_t * 
off_out, ssize_t len, unsigned int flags );
- 目的：在两个文件描述符所代表的文件间移动数据（它也仍然是零拷贝的动作）
- 参数：fd_in为源文件描述符；off_in为输入数据偏移量，若fd_in为管道，则off_in必须设置为NULL；fd_out与off_out的意义与之类似；len为传输的字节数；flags控制数据如何移动，其取值为SPLICE_F_MOVE（新内核无效果）、SPLICE_F_NONBLOCK（非阻塞）、SPLICE_F_MORE（还有后续数据）和SPLICE_F_GIFT（无效果）的位或 
- 返回值：传输的字节数，0表示无数据移动，失败时返回-1并设置errno

注意事项

- fd_in和fd_out必须至少有一个为管道文件描述符

数据移动函数tee()
- 原型：ssize_t tee( int fd_in, int fd_out, ssize_t len, 
unsigned int flags );
- 目的：在两个文件描述符所代表的管道间移动数据（性质与splice一样）
- 参数：含义与splice()相同
- 返回值：传输的字节数，0表示无数据移动，失败时返回-1并设
置errno

文件控制函数fcntl()
- 原型：int fcntl( int fd, int cmd, … );

  第二个参数是控制命令，后面跟着一系列的可选参数，也许有，也许没有；这个函数是需要特别注意的，Linux很多系统调用的函数都是以这样的模式来提供的

- 目的：对文件描述符所代表的文件或设备进行控制操作

- 参数： fd为文件描述符；cmd为控制命令

- 返回值：失败时返回-1并设置errno（返回值跟cmd这个命令有关，不同的cmd命令返回的数据是不一样的）

补充：no是number的缩写，比如No.1

常用操作
- 复制文件描述符：F_DUPFD/F_DUPFD_CLOEXEC，第三个参数
型式long，成功时返回新创建的文件描述符
- 获取或设置文件描述符的标志：F_GETFD/F_SETFD，第三个参
数前者无，后者型式long，成功时前者返回fd的标志，后者0
- ....
- 所有的这些命令查帮助手册看它的详尽介绍

#### 临时文件

可以创建临时文件，进行一些内部的输入输出；在程序运行过程中，创建一些临时文件进行一些特定的处理。

使用临时文件时的注意事项
- （可能有很多个进程使用同样的代码，当某个进程需要创建一个临时文件的时候，你得保证使用同样代码的进程所创建的临时文件它们不是同一个，也就是说，**同样的代码要创建临时文件，那么一旦你使用这个同样的代码启动了好几个进程，那你得保证这些进程所访问的临时文件名字是不一样的**）程序多个进程可能同时运行，它们可能应该使用不同的临时文件
- 必须小心设置文件属性，**未授权用户不应具有临时文件访问权限**
- 临时文件的生成（这个临时文件叫什么名字）应该外部不可预测，否则系统容易受到攻击（也就是说这个真正的名字应该是随机产生的）

Linux临时文件函数mkstemp()
- 创建名称唯一的临时文件，使用“XXXXXX”作为模板，**返回文件**
**描述符**（六个X，它内部在调用的时候自动会用一个全局唯一的、随机生成的一个6个字符来替换这里的“X”）
- 如果不希望外界看到临时文件，创建临时文件后应调用unlink()函
数将其从目录项中删除（就不在链接到我们的目录里），但文件本身仍存在
- 文件采用引用计数方式访问；本程序未结束，可用文件描述符访问
该文件；文件引用计数降为0，系统自动删除临时文件

```c++
#include <cstdlib>
#include <cstring>
#include <unistd.h>
// 向临时文件中写入数据
int WriteToTempFile( char * buffer, size_t length )
{
 // 创建临时文件，“XXXXXX”将在生成时被替换，以保证文件名唯一性
 char temp_filename[] = "/tmp/temp_file.XXXXXX";
 int fd = mkstemp( temp_filename );
 // 取消文件链接，不显示该临时文件；关闭文件描述符后，没有别的进程在用它了嘛，它的引用计数器就会降为0，然后临时文件自动就会被删除
 unlink( temp_filename );
 // 向临时文件中写入数据
 // 首先写入即将写入数据的长度，length为size_t类型的变量，&length取它的地址；类似于int b = 5；可使用&b取出b的地址一样
 write( fd, &length, sizeof(length) );
 // 写入数据本身
 write( fd, buffer, length );
 // 返回临时文件的文件描述符
 return fd; 
}
```

```c++
// 从临时文件中读取数据
char * ReadFromTempFile( int fd, size_t * length )
{
 // 定位到文件开头
 lseek( fd, 0, SEEK_SET );
 // 读取数据
 // 获得临时文件正文长度
 read( fd, length, sizeof(*length) );
 // 分配内存块，读取数据
 char * buffer = new char[*length];
 read( fd, buffer, *length );
 // 关闭文件描述符，临时文件将被删除
 close( fd );
 return buffer;
}
```

### 3.文件系统

Linux中使用的文件系统分为实际文件系统和虚拟文件系统两大类，实际文件系统就是实际存储我们文件的时候，它所使用到的文件系统

实际文件系统

- ext、ext2、ext3、ext4（经过多次改版，现在使用的是ext4）

虚拟文件系统VFS

特殊文件系统/proc（实际上是我们的内核映像）

- 从/proc文件系统中抽取信息

#### 实际文件系统：组成与功能描述

它事实上描述了整个Linux操作系统在保存我们文件的时候，尤其是外部真实文件的时候，它的组成和它的功能以及它的实现

- **引导块、超级块、索引结点区、数据区** 
- 引导块：在文件系统开头，通常为一个扇区，存放引导程序，
用于读入并启动操作系统
- 超级块：用于记录文件系统的管理信息，不同的文件系统拥有
不同的超级块 
- 索引结点区：一个文件或目录占据一个索引结点，**首索引结点**
**为该文件系统的根结点**（Linux整个文件系统都是挂接在统一的文件目录树下的，根节点一个文件系统有一个，那么这个文件系统的根节点就可以挂接到总目录下边的某个特定的非叶结点上，这样的话，就可以让我们整个目录树仍然构成一个单一的只有唯一的一个根的一个系统的架构），可以利用根结点将一个文件系统挂在另一个文件系统的非叶结点上
- 数据区：用于存放文件数据或者管理数据

#### 虚拟文件系统VFS

- VFS的特点：只存于内存中，充当实际文件系统与操作系统之
间的接口，**提供实际文件系统的挂载，并管理实际文件系统**
- VFS的构造：系统初始化时构造VFS目录树，建立其数据结构；
每个实际文件系统使用struct file_system_type结构存储为结
点，并形成链表
- VFS的意义与目的： 支持多种不同的文件系统，内核以一致的
方式处理这些文件系统，从而**对用户透明**（不管真实文件系统是什么格式，ext也好、ext4也好，CDFS也好，或者是FAT表，它都可以挂接到整个虚拟文件系统中的单一的某个特定的结点下，对于操作系统来讲，你把它挂上去以后，就可以以一个一致的方式来管理维护它了，用户不需要知道这个子文件系统它具体的真实的文件系统的格式是什么，**我们看到的就是一个总的文件系统的目录树**，在不同的挂载点它们可能挂载的是不同的真实文件系统）

#### 特殊文件系统/proc

- Linux内核的窗口，只存于内存中，并不占用磁盘空间

典型信息
- 进程信息：进程项、进程参数列表、进程环境、进程可执行文
件、进程文件描述符、进程内存统计信息等 
- 硬件信息：CPU信息、设备信息、PCI总线信息、串口信息等 
- 内核信息：版本信息、主机名与域名信息、内存使用等 
- 设备、挂载点与文件系统

**以上都可以通过“/proc”这个文件系统查询，查询这个文件系统里的文件来获得**

### 4.设备

#### 设备类型

设备文件的性质
- 设备文件**不是普通的磁盘文件**
- 读写设备的数据需要与相应的设备驱动器通信

设备文件的类型

- 字符设备：读写串行数据字节流，如串口、终端等（不管那个字节流是真正的ASCII码字符还是UNICODE码字符，还是一个整数分解成了一个字符接着一个字符方式传递的那个模式，反正它是一个字符设备、字节流，像串口、终端它实际上都是字节流，所以都是字符设备）
- 块设备：**随机读写固定尺寸数据块**，如磁盘设备（它实际上可以一个扇区、一个扇区地读，那不就是一个块嘛，一个扇区一个区块；平时我们一般不用它，操作系统内部用它，瞬间一次性地读取）

说 明 

- 磁盘挂载到文件系统后，就可以使用文件和目录模式操作，这样看上去就像和设备无关了，但其实依然是有固定的设备的，像硬盘、光盘、U盘，它们的文件系统、它们的设备驱动的模式，肯定是不一样的嘛，但是挂到文件系统以后，你看到的就没差别了，这就叫统一的一致的方式处理，同时对用户来讲是透明的。

- 程序一般不用块设备，内核实现文件系统时使用块设备操作文件

#### 设备号

大设备号（major device number） 

- 指定设备对应哪个设备驱动器

- 对应关系由内核确定

小设备号（ minor device number ） 

- 区分由设备驱动器控制的单个设备或设备的某个组件

示 例 

- 3号主设备为IDE控制器，IDE控制器可以连接多个设备（磁盘、磁
  带、CD-DVD驱动器等） 
- 主设备的小设备号为0，而从设备的小设备号为64

- 主设备单独分区的小设备号从0至63，从设备单独分区的小设备号
从64开始

#### 设备项

设备项：与文件类似（一旦挂接上去，设备项名字就跟普通的文件一样了）
- 可以使用mv、rm命令移动或删除
- 如果设备支持读写，cp命令可以从（向）设备读取（写入）数据

mknod系统调用：创建设备项（文件系统结点）
- 原型：int mknod( const char * pathname, mode_t mode, dev_t
dev );
- 参数：pathname为设备项包含路径的名称；mode为设备的使用权限与结点类型；当文件类型为S_IFCHR或S_IFBLK时，dev表示设备的大小设备号，否则忽略
- 创建一个设备项，仅仅是表示完成与这个设备通信的一个门户性的设置，在文件系统中创建设备项并不意味着设备可用
- 只有超级用户才可以创建设备项

#### 设备目录

所有的设备目录，已知的一般都放在“/dev”这个目录下边

```bash
示 例 
- 硬盘hda为块设备
- 硬盘有一个分区hda1
% ls –l /dev/hda /dev/hda1
brw-rw---- 1 root disk 3, 0 Jul 20 2011 /dev/hda
brw-rw---- 1 root disk 3, 1 Jul 20 2011 /dev/hda1
```

#### 硬件设备

具体哪些设备就不解释了，因为不同的操作系统是不一样的

#### 特殊设备

/dev/null：哑设备
- 任何写入哑设备的数据被抛弃
- 从哑设备读取不到任何数据，例如cp /dev/null empty-file
命令将创建一个长度为0的空文件

/dev/zero：零设备

- 行为类似文件，长度无限，但内容全部为0

/dev/full：满设备
- 行为类似文件，没有空闲空间存储任何数据
- 对满设备的写入总是失败，并将errno设为ENOSPC

随机数设备

/dev/random和/dev/urandom：随机数设备

- C语言的rand()函数生成伪随机数（C++没有专门的随机数生成函数，它就直接使用C的来生成伪随机数，这样的随机数在某些情况下是有规律可循的，那么在一个严格的程序里，这样的随机数显然没法用）

怎样生成真正的随机数呢？那就要求生成的随机数序列是不可预测的，什么东西不可预测呢，人的行为不可预测。

随机数设备原理
- 人的行为无法预测，因而是随机的

- Linux内核测量用户的输入活动（如键盘输入和鼠标操作）的
  时间延迟作为随机数

  (两个相邻的键盘输入，两个相邻的鼠标操作，它的时间的间隔别人是不知道的，你自己其实也不知道，所以它是个完全无法预计的一个行为，时间间隔到底有多大，它是完全无法预计的，那么操作系统就记录这个，然后用它作为随机数)

两者区别
- /dev/random：在用户没有输入操作时，阻塞随机数读取进
程（没有数据可读取） 
- /dev/urandom：永不阻塞；在用户没有输入操作时，生成
伪随机数代替（这样的话你就不用等用户去输入）

#### 设备控制与访问

设备访问
- 像文件一样操作设备
- 示例：向并口设备发送数据

```c++
int fd = open( "/dev/lp0", O_WRONLY );
// 打开这个并口，得到它的文件描述符
write( fd, buffer, buffer_length );
close( fd );
```

控制硬件设备的函数： ioctl()
- 第一个参数为文件描述符，指定想要控制的设备；第二个参数为控制命令码，指定想要实施的操作

```c++
#include <fcntl.h>
#include <linux/cdrom.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
int main (int argc, char* argv[])
{
 int fd = open( argv[1], O_RDONLY ); // 打开参数所表示的设备
 ioctl( fd, CDROMEJECT ); // 弹出CD-ROM
 close( fd );
 return 0;
}
```

### 5.库

我们在编写实际程序代码的时候，我们总是将我们的程序分解成一个又一个的模块的架构，这些模块就是所谓的库。库和我们的程序总是一并编译，但实际上，这些库本身可以被单独地编译，就像我们的标准库一样，在设计标准库的时候，那些C/C++的发明者，包括库的设计者，并不知道我们要使用这个库解决什么问题，所以那个库的编译它是单独的，编译出来的结果可以是静态库，也可以是动态库。

#### 静态库（Archives）

- 后缀一般为“*.a” 

  静态库里并没有主程序，单独地对它们进行编译，形成目标文件，就是一系列的“.o”，然后我们可以使用ar这个命令来构造一个单独的静态库，构造这个静态库的时候可以使用多个目标文件，

- 使用两个目标文件创建单一静态库的编译与链接命令：ar cr libtest.a test1.o test2.o（用这两个目标文件构造一个静态库，库的名字叫libtest.a）

- 链接器在编译我们的程序链接代码的时候，那么它搜索静态库，就会链接所有已经解析出来的我们引用了而未实现的函数，**就会从静态库里把那个代码抽出来，放到我们的可执行文件里**，静态库就会导致我们的可执行文件代码膨胀。所以它首先链接的是动态库。
- 将静态库的链接放置在链接命令行尾部，确保其引用被正确解析（当我们要编译我们的程序，要使用到别人已经实现好的这个静态库，我想链接它，那么这个静态库的链接就应该放在我们命令行的末尾；因为前面所有需要用到它的，都能够查到它，它知道要用，所以后面就会去把它抽出来了）

#### 动态库（Shared Object） 

- 严格讲起来应该叫共享目标库（类似Windows的动态链接库DLL，它实际上也是动态链接的），后缀一般为“*.so” 
- 编译命令：g++ -shared -fPIC -o libtest.so test1.o test2.o（**-shared选项表示要生成一个共享的动态库**）

- PIC：位置无关代码（Position-Independent Code） ，所有的共享目标库理论上都应该是位置无关的，因为我们需要确保这样的动态库能够在合适的时候被装载到内存的特定的位置，而我们事先无法为这样的动态库的装载位置指定确定的范围，因为每次装载的情况可能都不一样，每一个进程装载同样的库的时候它的位置可能也不一样。就是所有的引用都应该是相对于它这个库的起始地址，而不是它真实的物理内存的绝对的物理地址。
- 编译器首先链接动态库，其次才是静态库 
- 如果要强制链接静态库，编译使用-static选项

C标准库：libc
- 数学库是单独的：libm；需要调用数学函数时，必须显式链接数学库：g++ -o compute compute.c –lm（l，link；m是库的名字，lib可以省略）

C++标准库：libstdc++
- 编译C++11程序，使用g++-4.8 -std=c++11（表示使用c++11的库而不是使用C++标准库，注意是小写的c）；对于Code::Blocks等集成开发环境，在编译器设置对话框中选中相应的C++11选项，自动地替你链接C++11库，不打开就链接C++标准库。

#### 库的相关性

比如我们需要写一个图像处理的程序，这个程序需要处理我们的tiff图像，那么久需要连接libtiff这个库，而libtiff这个库它是和libjpeg这个库和libz这个库是相关的，所以连接的时候注意libtiff要放在前边。

- 链接时需要注意交叉引用被正确解析，例如：libtiff库需要libjpeg库 （jpeg图像处理）和libz库（压缩处理） 
- 独立库链接： g++ -static -o tifftest tifftest.c -ltiff -ljpeg –lz
- 相关库链接： g++ -o app app.o -la -lb -la（a库使用b库的代码，吧库又要使用a库的代码，交叉引用）

使用g++编译CPP文件，如果用gcc编译C++源文件时，加以下选项：-lstdc++，否则使用了C++操作的文件编译会出错。

> 误区三:编译只能用gcc，链接只能用g++
> 严格来说，这句话不算错误，但是它混淆了概念，应该这样说：**编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常使用g++来完成联接**。但在编译阶段，g++会自动调用gcc，二者等价。

**不知道对不对。反正编译c++用g++就对了！**

> 简单的GCC语法： 弄清gcc test.c 与 gcc -c test.c 的差别
>
> 如果你只有一个文件（或者只有几个文件），那么就可以不写Makefile文件（当然有Makefile更加方便），用gcc直接编译就行了。在这里我们只介绍几个我经常用的几个参数，第一是 “-o”，它后面的参数表示要输出的目标文件，再一个是 “-c”，表示仅编译（Compile），不连接（Make），如果没有”-c”参数，那么就表示连接，如下面的几个命令：
>
> ```bash
> gcc –c test.c，表示只编译test.c文件，成功时输出目标文件test.o
> gcc –c test.c –o test.o ，与上一条命令完全相同
> 
> gcc –o test test.o # 将test.o连接成可执行的二进制文件test
> gcc –o test test.c # 将test.c编译并连接成可执行的二进制文件test
> gcc test.c –o test，与上一条命令相同
> 
> gcc –c test1.c，只编译test1.c，成功时输出目标文件test1.o
> gcc –c test2.c，只编译test2.c，成功时输出目标文件test2.o
> gcc –o test test1.o test2.o，将test1.o和test2.o连接为可执行的二进制文件test
> gcc –o test test1.c test2.c，将test1.o和test2.o编译并连接为可执行的二进制文件test
> ```

进一步补充：

> 我们知道一个.c/.cpp源程序文件要最后变成我们的.exe（windows）或者.out(Linux)可执行文件，要经过我们的编译和链接。了解这个过程对程序员来说是最基本的素质（因为写了这么久的代码都不知道它最后为啥能执行，那不是搞笑吗?）。
>
> 编译与链接的区别：
>
> 在多道程序环境中，要想将一个用户源代码变成一个可以在内存中执行的程序，通常分为三个步骤：编译、链接、载入。
> （1）编译：由编译程序将用户的源代码编译成若干个目标模块。
> （2）链接：**由链接程序将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的载入模块。**
> （3）载入：由载入程序将载入模块载入内存。
>
> 编译和链接都是为将用户程序从硬盘上调入内存并将其转换为可执行程序服务的。用编译器时的compile就是在进行编译，link就是链接，运行程序时可以看到。
>
> 编译可以理解为高级语言翻译为**计算机可以理解的二进制代码，即机器语言**。
> 链接可以举例解释：一个程序编译后，在作业地址空间中所得到目标模块的起始地址通常是0，假设在1000处有一条指令load 1, 2500，即将2500单元处的数据取至寄存器1中。在多道程序环境下，将程序载入内存时并不可能预先知道所编译的模块应该放在内存的何处。假设程序被载入从10000开始的地址，此时的2500就应该变成了12500，这里就出现问题了，需要修改指令中的相对地址，但此时如果采用动态链接就可以不用修改地址，灵活地解决这个问题了。
> 链接分三种：静态链接、载入时动态链接、运行时动态链接，现在流行的是运行时动态链接，这种不仅可以回忆程序的载入过程，而且节省了大量的内存空间。
>
> 再来看C/C++的编译和链接：
>
> 无论是C/C++，首先要把源文件编译成中间代码文件，在Windows下面就是.obj文件，Unix、Linux下面就是.o文件，即Object File，这个动作叫编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。
>
> 编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（.o文件或是.obj文件）。
>
> 链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（.o文件或是.obj文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是.a文件。
> 总而言之，**链接就是那些目标文件之间相互链接自己所需要的函数和全局变量，而函数可能来源于其他目标文件或库文件**。
>
> 总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。**在编译时，编译器只检测程序语法，和函数、变量是否被声明**。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现，需要指定函数的Object File。

> Linux的.out是由gcc编译生成的二进制格式文件，但有可能是执行程序也可能是链接库文件，因为在linux中扩展名除了一些特殊的约定，一般情况下是无意义的。**.out文件就是扩展名为out的文件，它本身不代表任何信息。在Linux中判断文件是否是可执行文件，首先要看文件的属性是否是可执行的，它没有一个默认的扩展名表示此文件为可执行文件。为了方便，Linux中可执行文件一般都是没有扩展名的。**
>
> 在使用gcc编程时，没有指定输入可执行文件名，默认生成可执行文件a.out文件。执行时必须键入命令 ./a.out，即要带上扩展名，如果键入./a 则不正确，因为它寻找a这个文件，而不是a.out这个文件。
>
> 但在Linux一个文件是否能被执行，和后缀名没有太大的关系，主要看文件的属性有关。但我们了解一下Linux文件的后缀名还是有必要的，**特别是我们自己创建一些文件，最好还是加后缀名，这样做的目的是仅仅是为了我们的在应用时方便**。

#### 动态库的装载与卸载

当我们需要使用动态库的时候，可以调用dlopen()函数把这个动态库装载到内存里。

动态库装载函数dlopen()：头文件“dlfcn.h” - 原型：void * dlopen( const char * filename, int flag );
- 参数：filename为动态库名称；**flag为装载模式**，必须为
  RTLD_LAZY（动态库的装载是惰性装载，即需要的时候才会装载到内存里）或RTLD_NOW（立即装载，dlopen函数一执行完就把这个动态库装载到内存里）两者之一，并可与其他装载标识（如
  RTLD_GLOBAL、RTLD_LOCAL）组合

- 返回值：返回值就是装载完成以后这个动态库的句柄，相当于我们前面谈到的文件描述符，类型为void *，用以表示动态库句柄；调用失败返回NULL

- 示例：dlopen( "libtest.so", RTLD_LAZY );

  （用一个量来记录这个函数的返回值，每次使用这个动态库里的函数的时候，就可以使用这个动态库的句柄来去查询）

函数查找与装载函数dlsym()
- 原型：void * dlsym( void * handle, const char * symbol );
- 功能：根据动态链接库操作句柄与符号，**返回符号对应的地址**；
- 参数：handle为动态库句柄，是dlopen函数的返回值；symbol为函数名称字符串
- 函数描述：dlsym(dynamic library symbol) 根据 动态链接库 操作句柄(handle)与符号(symbol)，返回符号对应的地址。使用这个函数不但可以获取函数地址，也可以获取变量地址。 handle：由dlopen打开动态链接库后返回的指针； symbol：要求获取的函数或全局变量的名称。 **返回值： void* 指向函数的地址，供调用使用。**
- 返回值：**目标函数装载在内存中的基地址**（入口地址），所以你别看它返回值写的是void * ，它事实上是一个函数指针（感觉老师说错了，难道不是指针函数吗？没错，dlsym是指针函数，但是得到的是指向symbol函数的函数指针），这个地方需要注意。

> 柄，指的是器物的把儿，如“刀柄”，“|勺柄”；植物的花、叶或果实跟茎枝连着的部分也叫柄。
>
> C++之句柄
>
> 从广义上，能够从一个数值拎起一大堆数据的东西都可以叫做句柄。句柄的英文是"Handle"，本义就是"柄"，只是在计算机科学中，被特别地翻译成"句柄"，其实还是个"柄"。从一个小东西拎起一大堆东西，这难道不像是个"柄"吗？
>
> 然后，指针其实也是一种"句柄"，只是由于指针同时拥有更特殊的含义——实实在在地对应内存里地一个地址——所以，通常不把指针说成是"句柄"。但指针也有着能从一个32位的值引用到一大堆数据的作用，这不是句柄又是什么？
>
> Windows系统中有许多内核对象（这里的对象不完全等价于"面向对象程序设计"一词中的"对象"，虽然实质上还真差不多），比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个"对象"的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？**当然传递这些对象的首地址是一个办法，但这至少有两个缺点：**
>
> 1. 暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；
> 2. 操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？
>
> 所以，Windows操作系统就采用进一步的间接：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。
>
> 在Windows系统中，这个编号就叫做"句柄"。
>
> Handle在Windows中的含义很广泛，以下关于谈到的Handle除非特别说明，将仅限于进程、线程的上下文中。
>
> 1、先来谈谈Handle
>
> Handle本身是一个32位的无符号整数，它用来代表一个内核对象。它并不指向实际的内核对象，用户模式下的程序永远不可能获得一个内核对象的实际地址（一般情况下）。那么Handle的意义何在？它实际上是作为一个索引在一个表中查找对应的内核对象的实际地址。那么这个表在哪里呢？每个进程都有这样的一个表，叫句柄表。该表的第一项就是进程自己的句柄，这也是为什么你调用GetCurrentProcess()总是返回0x7FFFFFFF原因。
>
> 简单地说，Handle就是一种用来"间接"代表一个内核对象的整数值。你可以在程序中使用handle来代表你想要操作的内核对象。这里的内核对象包括：事件（Event）、线程、进程、Mutex等等。我们最常见的就是文件句柄（file handle）。
>
> 另外要注意的是，Handle仅在其所属的进程中才有意义。将一个进程拥有的handle传给另一个进程没有任何意义，如果非要这么做，则需要使用DuplicateHandle()，在多个进程间传递Handle是另外一个话题了，与这里要讨论的无关。
>
> 2、进程ID
>
> 首先，进程ID是一个32位无符号整数，每个进程都有这样的一个ID，并且该ID在系统范围内是唯一的。系统使用该ID来唯一确定一个进程。
>
> 深入些说，系统可能使用进程ID来计算代表该进程的内核对象的基地址（及EPROCESS结构的基地址），具体的计算公式你可以去问微软的OS开发人员。
>
> 3、HINSTANCE
>
> HINSTANCE也是一个32位无符号整数，它表示程序加载到内存中的基地址。

动态库卸载函数dlclose()
- 原型：int dlclose( void * handle );
- 参数：handle为动态库句柄
- 返回值：成功时为0，其他为错误

动态库错误处理函数dlerror()
- 原型：char * dlerror();
- 返回值：其他三个函数调用时最后一次产生的错误描述字符串

调用动态库中的函数，设函数名为g 

需要注意如下两点：

- 混合C/C++编码时，C函数应封装于extern "C" { … } 块
  中（把它的函数的原型、函数的实现都封装起来，表示它是一个C的格式，因为在C++代码下，C格式的函数和C++格式的函数，函数签名是不一样的，因为C不支持函数重载，支持重载的C++函数签名和不支持重载的C函数签名是不一样的，所以为了能够正确解析到C函数，那么就应该封装在这里面）；当然如果你大部分是C的代码，少量C++代码，也可以把C++代码封装在extern "C++" {}里。**动态库里相当多代码是C实现而非C++实现。**

- 使用链接选项：“-ldl”

```c++
void * handle = dlopen( "libtest.so", RTLD_LAZY );
// 声明函数指针指向动态库中的函数，按被调函数的名称查找
void ( *test )() = dlsym( handle, "g" );
// 得到指向g这个函数的函数指针，假设这个函数是左边那样的，没有参数（最后的那个括号里为空即没有参数）没有返回值，那么你就可以定义这样的一个函数指针变量test，然后把它初始化成dlsym()的返回值。
// 单独定义一个函数类型，然后根据函数类型定义我们的函数指针变量，再把那个函数指针变量赋值或初始化为dlsym()的结果也可以
( *test )(); // 使用函数指针调用动态库中的函数
dlclose( handle );
```

### 6.makefile

makefile是一个文件，它专门用来指导编译程序用的，过去，在Linux下边没有集成开发环境，我们写的C程序也好C++也好，都需要通过命令行的手段对它进行编译。当这个文件，当这个程序很大，文件很多的时候，那么手工地去编译它实际上是非常费劲的，所以为了方便程序员编译，就可以写一个makefile，然后用make这个命令去调用它。

make命令：负责C/C++程序编译与链接（它会去读取makefile文件里面的内容，根据它的内容去执行你的命令完成整个程序的编译和链接；makefile它就是给出make命令编译和链接我们程序时的规则，在linux下，makefile的文件有三个命名，如下，三个名字都可以，建议用后面两个，因为第一个是GNU专用的，如果你写的代码不是GNU的，那么它可能就不能用，）
- make根据指定命令进行建构
- 建构规则文件：GNUmakefile、makefile、Makefile

makefile有自己的固定的文件格式，也有自己的语法规则。

makefile语法

- 基本语法、变量、条件判断、能写循环、还能写函数

所以实质上它就是一个编程语言了，很复杂。makefile在早期写C/C++代码的时候，非常非常有用，但现在同学们有了集成开发环境，makefile的使用频率就不像过去那么多，但是对于一个Linux程序员来讲，了解makefile还是很有必要的。

makefile文件基本格式

```bash
target ... : prerequisites ...
[Tab键] commands
# 必须按照这个方式来
# ：前是它的目标，冒号后是建构这个目标所需要的先决条件，下面跟着一行或多行是它的建构命令
# 都是以行的形式来进行解析的，所以它的格式特别要求所有的命令前都要有Tab键
# 这样的一个描述构造一个规则，下面可能再构造另外一个规则，它会形成一个规则链
```

#### makefile文件规则

- makefile文件由一系列规则构成
- 规则的目的：建构目标的先决条件是什么以及如何建构目标（target就是我们的**建构目标**， prerequisites就是我们的建构先决条件，commands就是它的建构命令）
- 如果未指定目标（即make后什么都没有），缺省执行第一个目标（如果第一个目标还需要其它的目标才能够解决，那么它就会不断地回溯，所以它实际上是构造一系列的规则链）
- **若prerequisites中有一个以上的文件比target文件要新，执行**
**commands所定义的命令**（以确保我们的target目标是有效的，是最新的）

target：目标
- 通常为编译期的文件名，以指定要建构的对象，也可以是执行文
件，还可以是标签（操作名称，伪目标，不对应于真实的文件） 
- 可以为单一目标，也可以为空格分隔的多个目标（它后面的先决条件也可以是好多个，中间也是用空格来分隔开的）
- 每个目标或目标集（由空格隔开的）都定义了一组处理规则，它决定了那个目标或者那些目标如何被构造，当那个目标在这个规则下不能被构造的时候，就是还需要其它先决条件才能构造我们的先决条件的时候，那么它就会找那个先决条件的构成规则，如果那个构成规则还需要其它构成规则，它会继续去找其它的构成规则，这就意味着在查找makefile文件的时候它会形成一个规则链，和其相关规则构成规则链

prerequisites：先决条件
- 为生成该目标所需的先决文件或目标（前置条件） 
- 一般为空格分隔的文件名，指定目标是否重建的判断标准，即只
  要有一个先决文件不存在或有过更新，就重建目标
- 若目标先决条件本身需要重建，则匹配该先决条件的目标，执行其对应的命令

commands：命令
- 由一行或多行shell命令组成，命令前有Tab键（你用两个Tab也可以，一个Tab一个空格也可以，但是顶头字符必须是Tab键，不能是空格，**target前是不能有Tab的，为了美观你可以用空格去缩进**） 
- 指示如何建构目标，一般为生成目标文件所需要的命令序列（第一步做什么、第二步...)
- **每行命令都在单独的进程（单独的shell）中执行**，彼此没有继承关系，不能简单的在两条命令中间传递数据；解决办法：用分号将多条命令书写在单行（此时可用“\”折行，一行写不下的时候），或者（如果不想折行）为该条规则添加指示“.ONESHELL :”

伪目标（目标后不带先决条件）：操作名称，而不是文件名

- 删除编译后的二进制目标文件，例如：

```bash
# 想在编译完成后删除编译期生成的一些二进制的目标文件，就是中间结果我不想要了
clean :
	rm -f *.o # 把所有的“.o”的文件全部删掉，可执行文件都编译出来了还要“.o”干嘛呢
```

- 执行命令时须指定伪目标：$ make clean（执行这个目标，调用rm命令把所有的“.o”的文件全部删掉）

- 若当前目录下有clean文件，则此规则不会被执行；此时可
  用“.PHONY : clean”明确指示clean为伪目标；make将跳过文件检查，执行其对应的命令

  phony：伪造的，假的

- 执行清除任务的伪目标一般放置在makefile脚本的末尾，放在前面，尤其放在顶头，它会作为缺省目标的

伪目标惯例（正常情况下应该遵照这样的惯例，这样大家都能看的懂）
- all：所有目标的目标，一般为编译所有的目标，对同时编译多个程序极为有用（当你一个工程项目包括很多个文件想要同时编译的时候）
- clean：删除由make创建的文件（中间文件）
- install：安装已编译好的程序，主要任务是完成目标执行文
件的拷贝
- print：列出改变过的源文件
- tar：打包备份源程序，形成tar文件
- dist：不仅仅备份，还创建压缩文件，一般将tar文件压缩成Z文件或gz文件
- TAGS：更新所有的目标，以备完整地重编译使用
- check和test：一般用来测试makefile的流程

```bash
示例：假设程序主文件“main.c”，使用library库
# 注释行
prog : main.o library.o
	cc -o prog main.o library.o
# 调用cc编译器，输出的文件叫prog，使用后面的两个目标文件来链接它
main.o : main.c library.h
	cc -c main.c
# 编译main.c
library.o : library.c library.h
	cc -c library.c
.PHONY : clean
clean :
	rm main.o library.o
```

然后在命令行下就可以运行make，它就会执行缺省的第一条命令，替我们生成我们的prog文件，如果执行make clean，就会把所有“.o”删除

> 找个网上更通俗易懂的
>
> 1.语法规则
>
> ```makefile
> 目标...: 依赖...
>     命令1
>     命令2
>     ...
> ```
>
> 2.目标
>
> 目标即要生成的文件。如果目标文件的更新时间晚于依赖文件的更新时间，则说明依赖文件没有改动，目标文件不需要重新编译。否则重新编译并更新目标。
>
> 3.依赖
>
> **即目标文件由哪些文件生成**。如果依赖条件中存在不存在的依赖条件，则会寻找其它规则是否可以产生依赖条件。
>
> 例如：规则一是生成目标 hello.out 需要使用到依赖条件 hello.o，但是 hello.o 不存在。则 Makefile 会寻找到一个生成 hello.o 的规则二并执行。
>
> 4.命令
>
> 即通过执行该命令，由依赖文件生成目标文件。
>
> 注意每条命令前必须有且仅有一个 **tab** 保持缩进，这是语法要求。
>
> 5.ALL
>
> Makefile 文件默认只生成第一个目标文件即完成编译，但是我们可以通过 “ALL” 指定需要生成的目标文件。

#### makefile文件语法

和C不一样，很多时候它和shell那个编程规范非常相似

行解析：命令按行解析
- 命令行的行首字符为Tab键，其他行的行首字符不得为Tab键，但可以使用多个空格缩进（注释可以写空格）

换行：命令太长时，行尾用“\”换行

**注释：行首字符为“#”的文本行**

make在执行makefile的时候它会首先输出makefile里边的那行命令的全部内容，然后才会执行命令，当你不需要显示那行命令的内容的时候，就可以关闭命令的回显

关闭回显：在行首字符后和**命令前添加“@”** 

- 未关闭回显时，make会首先回显（打印）命令，然后执行该命令（一般不关闭命令回显）

- 通常仅在注释和纯显示的echo命令前使用此功能

makefile本身可以包含其它的文件。

include filename：包含其他文件

- 处理模式与C/C++类似
- 行首加“-”：忽略文件包含错误（-include，如果不加有错误make就会停）

通配符
- “ * ”（任意数目的任意字符），例如“*.c”表示所有C源文件
- “？”（任意一个字符），例如“?.c”表示所有单字符文件名的C源文件 
- “[abc]”（存在括号内的某个字符），例如“lib[abc].c”表示第四个字符为“a”、“b”或“c” 
- “[0-9]”（存在该集合中的某个字符），例如“lib[0-9].c”表示第四
个字符为0～9之间的数字（含数字0和9） 
- “ [  ^abc ] ”（存在非括号内的某个字符），例如“lib[ ^abc ].c”表示第四个字符不是“a”、“b”或“c”

变 量 

- 基本变量定义： var_name = value（有的shell里定义变量=前后不能加空格，这里是可以加空格的）

- $(变量名称)：引用变量（美元符号与小括号中间无多余空格）；

- shell变量用“ $$ ”，

  例如“@echo $$HOME” 

- 变量在使用时展开，**形式上类似宏替换**

- 变量的使用场合：目标、先决条件、命令、还可以用它定义新的变量

事实上，不管是变量的名字还是变量的值，make在解释这个makefile的时候，**都是把它当做字符串来处理的**。

内置变量

- $(CC)：当前使用的编译器；
- $(MAKE)：当前使用的make工具

自动变量
- $@：当前目标；
- $<：当前目标的首个先决条件；
- $?：比目标更新的所有先决条件；
- $^：所有先决条件；
- $(@D)和$(@F)：$@的目录名和文件名；
- $(<D)和$(<F)：$<的目录名和文件名

```bash
# makefile样本
objs = main.o library.o
prog : $(objs)
	$(CC) -o prog $(objs)
	@echo "Constructed…"
main.o : main.c library.h
	$(CC) -c main.c
library.o : library.c library.h
	$(CC) -c library.c
.PHONY : clean
clean :
	rm -f prog $(objs) *～
	# 以“~”结尾的备份文件也被删除了，只留下三个文件，main.c、library.c、library.h
```

变量定义格式
- var_name = value：在执行时扩展，允许递归，可以使用
后续代码中出现的值（这里变量的值会跟着value的值发生变化的）
- var_name := value：在定义时扩展，不允许递归，使用右
侧的现值，不能使用后续代码中出现的值 (在这个现值后来发生改变的时候，变量的内容不会变)
- var_name ?= value：只有在该变量为空时才设置值，否则
维持原值 
- var_name += value：将值追加到变量的尾部；若变量未
定义，则“+=”自动解释为“=”（如果你原来使用“：=”来对它进行赋值的，那么“+=”的话就意味着使用“：=”把它追加过去）；若变量已定义，则“+=”继承上次的操作符，并追加新值

**多行变量**

```bash
define var_name
# 变量值是底下这几行命令
	@echo "One"
	@echo "Two"
endef
# define和endef本身不是命令，所以前面不能用Tab键
```

- define和endef行首字符不能为Tab键，对齐时可使用空格
- 引用：$(var_name) 
- 多行变量主要用于定义命令包，平时很少用，使用多行变量要小心，展开时有可能导致脚本错误（因为这个东西它可能是在不同的shell下运行的，所以得到的结果互相之间可能没关系，展开以后脚本是非常有可能导致错误的）

目标变量：类似C/C++局部变量，仅对本目标规则链有效

- target … : var_name = value：定义目标变量

> cc 是 Unix系统的 C Compiler，一个是古老的 C 编译器。而 Linux 下 cc 一般是一个符号连接，指向 gcc；可以通过 $ ls -l /usr/bin/cc 来简单察看，该变量是 make 程序的内建变量，默认指向 gcc 。 cc 符号链接和变量存在的意义在于源码的移植性，可以方便的用 gcc 来编译老的用cc编译的Unix软件，甚至连 makefile 都不用改在，而且也便于 Linux 程序在 Unix下 编译。
>
> CC 则一般是 makefile 里面的一个名字标签，即宏定义，表示采用的是什么编译器（如：CC = gcc）。

在编写makefile的时候可以使用静态模式用百分号来进行通配

静态模式：以“%”通配
- 目的：用于处理模式相同的多目标，简化脚本代码

  ```bash
  target ... : target-pattern : prerequisites ...
  [Tab键]commands
  ```

- 示例：每个目标的文件以“.o”结尾，先决文件为对应的“.c”

```bash
objs = main.o library.o
$(objs) : %.o : %.c
	$(CC) -c $(CFLAGS) $< -o $@
main.o : main.c
	$(CC) -c $(CFLAGS) main.c -o main.o
library.o : library.c
	$(CC) -c $(CFLAGS) library.c -o library.o
# 生成两个目标文件都以“.o”结尾，对应的先决条件的文件名字都是“.c”结尾，所以我们就可以把它统一成一行
```

条件判断基本格式

```bash
conditional-directive conditional-directive
	text-if-true              text-if-true
endif 				 else
						text-if-false
					endif
# 左边或者右边
```

可用的条件判断
- 判断两个参数是否相等：ifeq (arg1,arg2)、 ifeq 'arg1' 'arg2'、 ifeq "arg1" "arg2"
- 判断两个参数是否不等：ifneq（具体格式与ifeq相同）
- 判断某个变量是否已定义：ifdef variable_name
- 判断某个变量是否未定义：ifndef variable_name

循环：可以在makefile中使用shell循环

```bash
rulefor :
	for filename in `echo $(objs)`; \
	do \
		rm -f $$filename; \
	done
```

注意事项
- 循环为shell循环，为保证多行命令在同一个进程下执行，必须合并成单条命令并在行尾添加分行标识
- 可以使用反引号（``)执行命令，所获得的结果集合可以作为循环的处理集合
- filename本身是shell变量，需使用“$$”引用

函数：像变量一样使用“$()”标识

- $(function arg1,arg2,…)：函数调用，函数名为function，后跟逗号分隔的参数列表，函数参数之间只有逗号没有空格
- $(subst from,to,text) ：make的字符串替换函数，将text中的from字符串替换为to，返回替换后的字符串

```bash
comma := , #定义一个逗号变量
# 定义空值，不是空格
empty :=
# 定义空格
space := $(empty) $(empty) # 两个空值变量包着的一个空白，$(empty)就什么东西也不生成，但中间那个空格会保留下来
foo := a b c
# 将“a b c”替换为“a,b,c”
bar := $(subst $(space),$(comma),$(foo))
```

## 十三.进程编程

### 1.进程基本概念

进程（process）的定义
- 进程是描述**程序执行过程和资源共享**的基本单位（你分配资源，你执行这个程序，那么你共享资源，所有的控制和管理这个程序运行的那些东西，都需要使用一个特殊的数据结构，来存储它、保存它、维护它、管理它，这个东西就叫进程）
- 主要目的：**控制和协调程序的执行**

进程相关函数
- 用户与组ID函数：参阅上一讲 
- 创建进程：system()、fork()、exec()
- 终止进程：kill()
- 等待进程终止：wait()、waitpid()

进程组
- 定义：由一个或多个相关联的进程组成，目的是为了进行作业控制
- 进程组的主要特征：信号可以发送给进程组中的所有进程，并使该进程组中的所有进程终止、停止或继续运行
- **每个进程都属于某个进程组**

也就是说你把这些相关的进程合并成一个组，然后就可以以一个组的模式对它进行控制和管理。在Linux中，对管理同类型的进程是非常方便的一个策略。

进程组函数
- 获取进程组ID：pid_t getpgid( pid_t pid );
  - 返回pid进程的进程组ID；若pid为0，则返回当前进程的进程组ID；出错时返回-1，并设errno值 
- 设置进程组ID：int setpgid( pid_t pid, pig_t pgid );
  - 若pid为0，则使用调用者PID；若pgid为0，则将pid进程的进程PID设为进程组ID；成功时返回0，出错时返回-1，并设errno值

会话（session） 

- 会话为一个或多个进程组的集合，包括登录用户的全部活动，并具有一个控制终端

- 登录进程为每个用户创建一个会话，用户登录shell进程成为会话首领，会话首领的那个进程PID就会变成这个会话的ID
- **非会话首领进程通过调用setsid()函数创建新会话，并成为首领**（注意这个函数只能是非会话首领才能创建；你原来就是组长，你还想创建一个新的组，再自认组长，这个模式在Linux系统下就不太妥当，不能身兼数职）

进程组函数
- 获取会话ID：pid_t getsid( pid_t pid );
  - 返回pid进程的会话ID；若pid为0，则返回当前进程的会话ID；成功时返回会话ID，出错时返回-1，并设errno值  
- 设置会话ID：pid_t setsid();
  - 成功时返回新创建的会话ID，出错时返回-1，并设errno值

### 2.信号

它是一种重要的进程间通讯机制。

- 信号是发送给进程的特殊异步消息
- 当进程接收到信息时**立即处理**，此时并不需要完成当前函数
调用甚至当前代码行 （不一定能做完就会被中断，特别注意这点，中断这些当前函数运行）
- Linux系统中有多种信号，各具有不同的意义；系统以数字
标识不同的信号，程序中使用的时候，一般使用它的名字对应的宏名字来标记它来使用它

系统信号
- 缺省处理逻辑：终止进程，生成内核转储文件
- 使用“kill –l”命令可查看操作系统支持的信号列表，不同
的系统可能有所不同

```
信 号 值 缺省动作 含 义
SIGHUP 1 终止进程 终端的挂断或进程死亡
SIGINT 2 终止进程 来自键盘的中断信号，通常为Ctrl+C
SIGQUIT 3 内核转储 来自键盘的离开信号
SIGILL 4 内核转储 非法指令
SIGTRAP 5 内核转储 断点或其他陷阱指令，用于调试器
SIGABRT 6 内核转储 来自abort的异常信号
SIGBUS 7 内核转储 总线错误（内存访问错误）
SIGFPE 8 内核转储 浮点异常
SIGKILL 9 终止进程 杀死进程
SIGUSR1 10 终止进程 用户自定义信号1
SIGSEGV 11 内核转储 段非法错误（内存访问无效）
SIGUSR2 12 终止进程 用户自定义信号2
SIGPIPE 13 终止进程 管道损坏：向一个没有读进程的管道写数据
SIGALRM 14 终止进程 计时器定时信号
SIGTERM 15 终止进程 进程终止信号
SIGSTKFLT 16 终止进程 协处理器堆栈错误（不使用）
SIGCHLD 17 忽略 子进程停止或终止
SIGCONT 18 忽略 如果停止，继续执行
SIGSTOP 19 停止进程 非来自终端的停止信号
SIGTSTP 20 停止进程 来自终端的停止信号，通常为Ctrl+Z
SIGTTIN 21 停止进程 后台进程读终端
SIGTTOU 22 停止进程 后台进程写终端
SIGURG 23 忽略 有紧急数据到达套接字信号
SIGXCPU 24 内核转储 超过CPU时限
SIGXFSZ 25 内核转储 超过文件长度限制
SIGVTALRM 26 终止进程 虚拟计时器定时信号（进程占用CPU时间）
SIGPROF 27 终止进程 计时器定时信号（程序占用CPU时间和系统调度时间）
SIGWINCH 28 忽略 窗口大小改变
SIGIO 29 终止进程 描述符上可以进行I/O操作
SIGPWR 30 终止进程 电力故障
SIGSYS 31 内核转储 非法系统调用
```

进程间发送的信号

- SIGTERM、SIGKILL：终止进程信号，前者是请求，请求你停下来吧（接收信号的进程可以忽略之），后者是强制
- SIGUSR1、SIGUSR2：用户自定义信号，可用于它们来做自己的处理，向进程发送命令

信号处理
- 进程接收到信号后，根据信号配置进行处理
- 缺省配置：在程序没有处理时，确定信号该如何处理（如果你定义了自己的信号处理例程，那么它就不会按照缺省的那个处理过程去对它进行处理）
- 程序处理信号的方式：按照信号处理例程里所提供的那个函数指针类型定义一个函数，然后调用

sigaction()函数：设置信号配置
- 原型：int sigaction( int signum, const struct 
sigaction * act, struct sigaction * oldact );
- signum为信号编号，act和oldact分别为指向信号结构体struct sigaction的指针，前者为新配置，后者为需要保存的老配置（因为每一个信号对应的处理例程它原先就有一个，有的是缺省的，有的可能是你原先设定的，现在你想为这个信号设定一个新的处理例程，那么你就把新的处理例程给它设置进去，但是原先那个你得保存起来，你可能把这个信号处理例程处理完以后，要恢复成原来那个缺省的处理模式或者原先你设置的那个处理模式）

sigaction其实又是函数又是结构体，为了区分它，所以在结构体前面我总是写struct，绝不省略哪怕我写的是C++代码，表示它是结构体，它不是函数，要能区分它，就这个意思。

这个给信号结构体特别重要，**我们处理信号的时候一定要操作的就是这个信号结构体**。要非常了解！

信号结构体struct sigaction
- **最重要的成员为sa_handler**，其取值为SIG_DFL（使用信
  号缺省配置）、SIG_IGN（忽略该信号）或指向信号处理
  例程的函数指针（以信号编号为参数，无返回值）

  sa_handler用来表达这个对应的信号它的处理例程---那个函数指针是什么，你定义了一个信号处理例程，那么你就把它的入口地址传给sa_handler就可以了。

注意：因为早期Linux在实现的时候，没有C++，它用的是C代码，所以这个信号处理例程这个函数是C函数，写C++代码时要特别小心传的是一个C函数的一个函数指针，不是C++的函数更不是类的成员函数。

> C＋＋的函数名在编译的时候会重新命名，把参数的类型，个数加到名字，以支持的重载，一般编译器，C语言写的函数，名字并不参加重载重命名
>
> 举个例子：
> 函数void fun(int a, int b);
> C＋＋的编译器会把函数大致编译成 _fun_int_int 的形式;
> 而C编译器则会编译成 _fun， 是不带参数的
>
> 但用户具体调用而言就没有太大的区别

处理信号时的注意事项
- 信号是异步操作，当处理信号时，主程序非常脆弱
- 信号处理例程应尽可能短小，太长的话非常容易导致整个程序错误，它甚至有可能会被新信号所中断，（那它就没被处理完，那肯定不行）
- 尽量不要在信号处理例程中实施I/O操作（因为I/O操作在很多情况下是长而复杂的），也不要频繁调用系统函数或库函数
- 在信号处理例程中进行复杂的赋值操作也是危险的，它可能不
是**原子操作**（就是说它本身可能会被中断的，进行复杂的赋值，就有可能导致我们赋值了一部分，然后它被中断了，然后剩下一部分数据就没有被赋值，没有意义，这个数据的一致性就没办法保证）
- 如果需要赋值，使用sig_atomic_t类型的全局变量，然后赋值这个全局量（在Linux中等价于int，亦即允许整数或指针赋值（32位64位都可以），更大尺寸数据不允许，你必须保证那个处理的过程中不会被中断，否则就是有问题的）

> 补充：原子操作
>
> 原子操作（atomic operation）指的是由多步操作组成的一个操作。如果该操作不能原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。
>
> 现代操作系统中，一般都提供了原子操作来实现一些同步操作，所谓原子操作，也就是一个独立而不可分割的操作。在单核环境中，一般的意义下原子操作中线程不会被切换，线程切换要么在原子操作之前，要么在原子操作完成之后。更广泛的意义下原子操作是指一系列必须整体完成的操作步骤，如果任何一步操作没有完成，那么所有完成的步骤都必须回滚，这样就可以保证要么所有操作步骤都未完成，要么所有操作步骤都被完成。
>
> 例如在单核系统里，单个的机器指令可以看成是原子操作（如果有编译器优化、乱序执行等情况除外）；在多核系统中，单个的机器指令就不是原子操作，因为多核系统里是多指令流并行运行的，一个核在执行一个指令时，其他核同时执行的指令有可能操作同一块内存区域，从而出现数据竞争现象。多核系统中的原子操作通常使用内存栅障（memory barrier）来实现，即一个CPU核在执行原子操作时，其他CPU核必须停止对内存操作或者不对指定的内存进行操作，这样才能避免数据竞争问题。
>
> 在C++11之前，C++标准中并没有对原子操作进行规定。vs和gcc编译器提供了原子操作的api。

```c++
#include <signal.h> // 处理信号的头文件
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <iostream>
sig_atomic_t sigusr1_count = 0;
extern "C" { void OnSigUsr1( int signal_number ) { ++sigusr1_count; } }
int main ()
{
 std::cout << "pid: " << (int)getpid() << std::endl;
 struct sigaction sa;
 memset( &sa, 0, sizeof(sa) ); // 把它的内存全部清零
 sa.sa_handler = &OnSigUsr1; // 处理例程的入口地址赋值给它，这个就设定了sigaction()的基本函数处理例程，它的信号处理例程就被你设定好了
 sigaction( SIGUSR1, &sa, NULL ); // 把sa挂到SIGUSR1这个信号上，只要完成sigaciton()这个函数调用，我们的信号处理例程OnSigUsr1()这个函数就会被挂接到SIGUSR1这个信号上
// 当你在程序运行过程中，触发了一个SIGUSR1信号之后，这个信号处理例程就会被调用
 sleep( 100 ); // 在终端中输入kill –s SIGUSR1 pid，信号计数器将递增
 std::cout << "SIGUSR1 counts: " << sigusr1_count << std::endl;
 return 0;
}
```

### 3.进程管理

#### 进程创建

system()函数：用于在程序中执行一条命令
- 原型：int system( const char * cmd );

- 在Bourne shell中，系统会创建一个子进程运行被调命令；返
  回值为shell的退出状态；如果shell不能运行，返回127；如
  果发生其他错误，返回-1 

- 示例：int ret_val = system( "ls -l /" );

  把根目录列一下目录，以一个列表的形式详细地列出来，把结果返回给ret_val，这个结果是shell做完了以后的结果，不是列的实际目录呈现的那个数据，

在创建进程的时候，最重要的是下面这个函数，fork()。

fork()函数：创建当前进程的副本作为子进程
- 原型： pid_t fork();
- 返回值是一个整数，为0（新创建的子进程），返回值非0的时候，尤其是大于0的时候，说明它是父进程（为啥呀，因为它返回的是子进程的ID，子进程又没有调用fork()创建孙子进程，对不对，它哪有子进程ID，子进程ID只有父进程才具有，所以在子进程内部它返回的那个值是0，在父进程的时候看到的那个返回值是子进程创建出来的那个PID）；返回值一个给子进程用的，一个父进程用的，通过fork的返回值就可以做到，下面的if-else，一段代码在父进程里执行，一段代码在子进程里执行。

这个函数特别特殊，因为它一次调用返回两个整数，它把当前进程拷贝一份形成一个子进程，像什么呢，它像细胞的分裂，一个是原先的进程，一个是新的进程。你在一个进程上调用一个fork()，就会创建一个子进程，**这个子进程所使用到的所有东西都和父进程是一模一样的**

```c++
使用fork()函数创建进程副本
#include <iostream>
#include <sys/types.h>
#include <unistd.h>
using namespace std;
int main ()
{
 cout << "the main program process ID is " << (int)getpid() << endl;
 pid_t child_pid = fork();
 // 一个新的进程就产生出来了
 if( child_pid != 0 )
 {
 cout << "this is the parent process, with id " << (int)getpid() << endl;
 cout << "the child’s process ID is " << (int)child_pid << endl;
 }
 else
 	cout << "this is the child process, with id " << (int)getpid() <<endl;
 return 0;
}
// 这个程序没有考虑到错误处理问题，是有问题的
```

这是一个非常精巧的资源消耗量非常少的创建子进程的模式，两个进程一模一样，但是fork以后就可以执行不同的代码了。这是早期Unix给出的实现策略，现在回过头来看，它虽然轻巧，但是很多时候它给我们创建进程的模式不够灵活，你只能创建当前进程的副本。

我们创建一个子进程干嘛呢？早期最重要的一个工作就是在创建的子进程里边，执行特定的命令，使用exec()函数来执行这个命令。

```c++
exec()函数簇原型
- int execl( const char * path, const char * arg, … );
- int execlp( const char * file, const char * arg, … );
- int execle( const char * path, const char * arg, …, char * const envp[] );
- int execv( const char * path, char * const argv[] );
- int execvp( const char * file, char * const argv[] );
- int execvpe( const char * file, char * const argv[], char * const envp[] );
```

exec()函数说明
- 函数名称中包含字母“p”（execvp、execlp）：**接受程序名作为参数**，在当前执行路径中按程序名查找；不包含字母“p”的，必须提供程序的完整路径
- 函数名称中包含字母“v”（execv、 execvp、execve）：
接受以NULL结尾的字符串数组格式的参数列表
- 函数名称中包含字母“l”（execl、 execlp、execle） ：接受C格式的可变参数列表
- 函数名称中包含字母“e”（execve、execle） ：接受一个附加的环境参数列表，参数格式为NULL结尾的字符串数组，且字符串的格式为“VARIABLE=value”

```c++
基本模式：在程序中调用fork()创建一个子进程，然后调用
exec()在子进程中执行命令
#include <iostream>
#include <cstdlib>
#include <sys/types.h>
#include <unistd.h>
int spawn( char * program, char ** args );
int main ()
{
 char * args[] = { "ls", "-l", "/", NULL };
 // 字符串数组，最后有一个NULL别忘了
 spawn( "ls", args );
 cout << "Done!\n";
 return 0;
}
```

```c++
// 创建一个子进程运行新程序
// program为程序名，arg_list为程序的参数列表；返回值为子进程id
int spawn( char * program, char ** args ) {
 pid_t child_pid = fork(); // 复制进程,创建子进程
 if( child_pid != 0 ) // 此为父进程
 	return child_pid;
 else // 此为子进程
 {
 execvp( program, args ); // 执行程序，按路径查找
 // 只有发生错误时，该函数才返回
 std::cerr << "Error occurred when executing execvp.\n";
 abort ();
 } }
```

#### 进程调度

进程调度策略：先进先出（先来的进程先被调度），时间片轮转，普通调度，批调度，高优先级抢先（把进程分为特定的优先级，优先级高的先做，低优先级在做，当一个高优先级的进程到达，那么就抢先，把低优先级的那个进程从CPU里给踢出来不让它做了）

- 子进程与父进程的调度没有固定顺序；不能假设子进程一定会在父进程之后执行，也不能假设子进程一定会在父进程之前结束（如果你没有设它的进程调度顺序，没有去做进程间的同步，那么你就没有办法对子进程和父进程的执行顺序做任何的假定，都有可能先做，都有可能先做完，注意，先做不一定先做完）

进程调度策略函数：头文件“sched.h” 

- 获取进程调度策略：int sched_getscheduler( pid_t pid );

- 设置进程调度策略：int sched_setscheduler( pid_t pid, int policy, 
const struct sched_param * sp );
- 获取进程调度参数：int sched_getparam( pid_t pid, struct 
sched_param * sp );
- 设置进程调度参数：int sched_setparam( pid_t pid, const struct 
sched_param * sp );

进程优先级调整：头文件“sys/time.h”和“sys/resource.h” 

- 改变进程优先级：int nice( int inc );（头文件“unistd.h”） 
- 获取进程优先级：int getpriority( int which, int who );

- 设置进程优先级：int setpriority( int which, int who, int prio );

处理器亲和性：头文件“sched.h” 

- 获取进程的处理器亲和性：int sched_getaffinity( pid_t pid, size_t
  cpusetsize, cpu_set_t * mask );

- 设置进程的处理器亲和性：int sched_setaffinity( pid_t pid, size_t
cpusetsize, cpu_set_t * mask );

处理器亲和性指的是这个进程它倾向于第几号CPU上面去做，你可以预先对它进行设定，比如你有4颗CPU，或者是1颗CPU里有4个核心，那么它标定的时候，就是CPU0、CPU1、CPU2、CPU3。那么你这个进程创建出来以后，你想运行，你说这个进程优先选择1号CPU去做，这个就叫处理器的亲和性。

#### 进程终止

终止进程函数：kill()
- 头文件“sys/types.h”和“signal.h” 
- 原型： int kill( pid_t pid, int sig );
- 函数参数：pid为子进程ID，sig应为进程终止信号SIGTERM

等待进程结束函数：wait()
- 原型：pid_t wait( int * status ); pid_t waitpid( pid_t pid, int * 
  status, int options );（第二个函数等待特定的pid号的那个进程结束）

- （当你调用wait的时候，因为这个函数的调用要等待另外一个进程结束，所以这个进程本身它就做不下去了，这个进程就会被阻塞，一直到你等待的那个进程结束了，它才会继续做下去）阻塞主调进程，直到一个子进程结束

  wait单参数版本主要是用来等待子进程结束，waitpid呢就等待一个特定的进程结束

- WEXITSTATUS宏：查看子进程的退出码 

- WIFEXITED宏：确定子进程的退出状态是正常退出，还是未处理信号导致的意外死亡

```c++
#include <iostream>
#include <cstdlib>
#include <sys/types.h>
#include <sys/wait.h> // 必须包含此头文件，否则与wait共用体冲突
#include <unistd.h>
int spawn( char * program, char ** arg_list );
int main ()
{
 char * arg_list[] = { "ls", "-l", "/", NULL };
 spawn( "ls", arg_list );
 int child_status;
 wait( &child_status ); // 等待子进程结束
 // wait这个参数不是传给wait的，是wait要传出来的，我们要用的
 if( WIFEXITED( child_status ) ) // 判断子进程是否正常退出
 	cout << "Exited normally with " << WEXITSTATUS(child_status) <<endl;
 else
 	cout << "Exited abnormally." << endl;
 	cout << "Done!\n";
 return 0;
}
```

#### 僵尸进程

子进程已结束，但父进程未调用wait()函数等待

- 子进程已终止，但父进程并没有等待它，这就意味着那个子进程本身没有被正确清除，成为僵尸进程，它有些特定的资源就没有被释放，包括子进程的状态就没有被处理，所以很多时候它实际上是对资源的一种浪费。

清除子进程的手段
- 父进程调用wait()函数可确保子进程被清除（等子进程做完，把它的状态取出来，它就死掉了，所有的东西都被我们清除了）
- 即使子进程在父进程调用wait()函数前已死亡（成为僵尸），
其退出状态也可以被抽取出来，然后被清除
- 未清除的子进程自动被init进程收养，会变成init进程的子进程，这不就增加了init的负担嘛

```c++
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
int main ()
{
 pid_t child_pid;
 child_pid = fork();
 if( child_pid > 0 ) // 父进程，速度睡眠六十秒
 	sleep( 60 );
 else // 子进程，立即退出
 	exit( 0 );
    // 一构造出来就退出，什么也不做
    // 结果子进程不就变成僵尸了嘛，父进程没处理它啊，你fork一个子进程出来，然后你啥也不管你睡觉去了，那子进程呢，它exit()退出了，你也没等它，结果不就是子进程变成僵尸了嘛
 return 0;
}
```

#### 子进程异步清除

如果你把wait()写在父进程里，那如果子进程没有结束父进程不就被阻塞了嘛，它自己的事情就做不了了，所以一个更好的策略是子进程结束的时候，触发一个终止信号，然后父进程收到这个信号处理这个子进程的清除工作，所以最合适的方案就是子进程的异步清除。

SIGCHLD信号：子进程终止时，向父进程自动发送这个信号，那么父进程就可以针对这个子进程写一个信号处理例程，完成子进程的异步清除工作。等待那叫同步了。

```c++
#include <signal.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
sig_atomic_t child_exit_status;
extern "C" {
void CleanUp( int sig_num ) // 信号那个值作为它的参数
{
 int status;
 wait( &status ); // 等待子进程结束，清除子进程，然后把子进程的状态返回出去
 child_exit_status = status; // 存储子进程的状态
}}
```

```c++
int main ()
{
 // 处理SIGCHLD信号
 struct sigaction sa;
 memset( &sa, 0, sizeof(sa) );
 sa.sa_handler = &CleanUp; // 就把子进程发送SIGCHLD这个信号之后，我们父进程要做的事，它的信号活动给它设置好
 sigaction( SIGCHLD, &sa, NULL );
 // 正常处理代码在此，例如调用fork()创建子进程
 return 0;
}
```

#### 守护进程

它是在后台默默的做事情，没有输入也没有输出。所以创建守护进程的方式是非常非常特殊的。

创建守护进程的步骤
- 创建新进程：新进程将成为未来的守护进程
- 守护进程的父进程要退出：这样能够保证祖父进程明确地确认到父进程已结束，且知道守护进程本身不是组长进程（只有非组长它才能创建新的会话啊）
- 守护进程创建新进程组和新会话（成为新进程组的组长和会话的首领）：并成为两者的首进程，此时刚创建的新会话还没有关联控制终端，所以它是没有输入输出的
- 改变工作目录：守护进程一般随系统启动，工作目录不应继续
使用创建这个守护进程的那个进程的工作目录（继承的工作目录），那个进程可能是另外一个目录，那个目录在文件系统中，甚至有可能被管理员给卸载掉，所以你守护进程随系统启动的时候，可能没用它，用它就可能导致问题，所以我们往往会改变它的工作目录，一般改变到根目录下，或者在根目录下其它的某个固定的子目录下，保证它不会被卸载的地方
- 重设文件权限掩码：不需要继承文件权限掩码
- 关闭所有文件描述符：不需要继承任何打开的文件描述符
- 标准流重定向到/dev/null（三个流全都定向到哑终端）

总体上应该按上面的顺序来，虽然其中有些顺序可以颠倒

创建完了，你可以根用户权限去运行它，它就能够在后台默默地替你做事情了，你还可以设定它随系统一起启动。

```c++
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/fs.h>
int main()
{
 pid_t pid = fork();
 if( pid == -1 ) return -1;
 else if( pid != 0 ) exit( EXIT_SUCCESS );
 // 这个时候它是在父进程里，父进程直接退出
    
 // 子进程
 if( setsid() == -1 ) return -2;
 // 设置工作目录
 if( chdir( "/" ) == -1 ) return -3;
 // 重设文件权限掩码
 umask( 0 );
 // 关闭文件描述符
 for( int i = 0; i < 3; i++ ) close( i );
 // 因为我们这里没打开任何文件描述符，它实际上只打开了三个标准流，所以这里用循环执行三次就完了，文件描述符0、1、2
 // 重定向标准流
 open( "/dev/null", O_RDWR ); // stdin
 // 打开它就会创建一个新的文件描述符，它优先选择最小的文件描述符，最小的是0号文件描述符，因为那三个都关闭了，事实上什么文件描述符都没用，所以打开哑终端的时候它自动地将使用0号文件描述符，0号对应的是标准输入流，这就意味着标准输入流被挂到了哑终端上，所有的数据输入都从哑终端来，所以什么都来不了
 dup( 0 ); // stdout 
 // 文件描述符的复制操作，复制0号文件描述符，产生一个新的文件描述符，放哪呢？优先选择最小的那个文件描述符，现在最小的是1，也就是把0号文件描述符复制到1号文件描述符那里面去了，现在它就把标准输出流也挂到了哑终端上，所有的输出信息全都仍到哑终端，也就是什么内容都不再显示
 dup( 0 ); // stderr
 // 守护进程的实际工作代码在此
 return 0;
}
```

守护进程创建函数daemon()
- 实现了前述功能，减轻编写守护进程的负担
- 原型：int daemon( int nochdir, int noclose );
- 参数：若nochdir非0（true），不更改工作目录；若noclose非0，不关闭所有打开的文件描述符；一般两参数均设为0 
- 返回值：成功时返回0，失败时返回-1，并设置errno值（去查errno的值就知道发生了什么错误）

### 4.进程间通信

我们要谈到如下机制：

管道：相关进程间的顺序通信

进程信号量：进程间通信的同步控制机制

共享内存：允许多个进程读写同一片内存区域

映射内存：与共享内存意义相同，但与文件相关联

消息队列：在进程间传递二进制块数据

套接字：支持无关进程，甚至不同计算机进行通信（这个在网络里讲）

#### 管道

管道（pipe）的性质与意义
- 管道是允许单向通信的自动同步设备（它是一种半双工的模式，一般情况下以这种模式去使用它） 
- 数据在写入端写入，在读取端读取
- 管道为**串行设备**，数据的读取顺序与写入顺序完全相同

管道的用途

- 只能用于有亲缘关系的进程，例如父进程和子进程之间通信

注意事项
- **管道的数据容量有限，一般为一个内存页面的大小**
- 如果写入速度超过读取速度，写入进程将阻塞，直到容量有空闲
- 如果读取速度超过写入速度，读取进程将阻塞，直到管道有数据可以读取

pipe函数：创建管道
- 头文件：“unistd.h”和“fcntl.h” 
- 原型：int pipe( int pipefd[2] ); 
- 参数：一个包含两个元素的整数数组，元素类型为文件描述符，0号元为读取文件描述符，1号元为写入文件描述符（一个管道，有一个写入端，有一个读取端，每一端都有一个文件描述符，所以它是双文件描述符，这个数组保存的就是这个双文件描述符）
- 返回值：成功时返回0，不成功时返回-1，并设置errno值

```c++
int pipe_fds[2];
int read_fd;
int write_fd;
pipe( pipe_fds );
// 构造一个管道，然后它的文件描述符就会给你写到这个数组里，然后你就可以用了
read_fd = pipe_fds[0];// 0号元就是管道读取端 文件描述符
write_fd = pipe_fds[1];
```

```c++
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
const int buf_size = 4096;
// 向stream中写入count次msg
void Write( const char * msg, int count, FILE * stream )
// 向这个特定的一个流里输出一串信息，这串信息我们会重复输出好几遍，所以这个信息是用message传进来的。流是一个文件指针，FILE * stream传进来的，这个消息写多少遍呢？count遍。
{
 for( ; count > 0; --count )
 {
 fprintf( stream, "%s\n", msg );
 fflush( stream );
 sleep (1);
 } }

// 从stream中读取数据
void Read( FILE * stream )
{
 char buf[buf_size];
 // 贪心地读取，当这个流没有结束的时候，当读取这个信息没有出错的时候，当这个流里还有数据可以读的时候，我们就把这个数据全都读出来，一直读取到流的尾部
 while( !feof(stream) && !ferror(stream) && fgets(buf, sizeof(buf), stream) != NULL )
 {
 fprintf( stdout, "Data received: \n" );
 // 向标准输出流里输出这个数据
 fputs( buf, stdout );
 } }
int main()
{
 int fds[2];
 pipe( fds ); // 创建管道
 pid_t pid = fork(); // 创建子进程
 if( pid == 0 ) { // 子进程
 close( fds[1] ); // 只读取，关闭管道写入端；表示在我们的子进程里只从管道里读数据，不向管道里写数据
 // 虽然管道有两个端，但是在两个进程进行通讯的时候，一个进程只使用写入端，一个进程只使用读取端，所以它实际上是一个半双工的模式；虽然可以把读写端倒过来，但是正常情况下一个管道只能一端读取一端写入
     
 // 将文件描述符转换为FILE *，以方便C/C++标准库函数处理
 FILE * stream = fdopen( fds[0], "r" );// 以读模式打开它得到读取端的文件指针，这样的话就可以和C的函数完全地吻合起来，因为C的很多文件操作实际上使用的是文件指针
 Read( stream ); // 从流中读取数据
 close( fds[0] ); // 关闭管道读取端
 }
 else if( pid > 0 ) { // 父进程
 char buf[buf_size]; // 数据缓冲区，末尾封装两个‘\0’
 for( int i = 0; i < buf_size-2; i++ ) buf[i] = 'A' + i % 26;
 buf[buf_size-1] = buf[buf_size-2] = '\0';
 close( fds[0] ); // 只写入，关闭管道读取端
 FILE * stream = fdopen( fds[1], "w" );
 Write( buf, 3, stream );// 向stream里写数据，写这个buffer里面的数据写三遍，一次一个页面
 close( fds[1] ); // 关闭管道写入端
 }
 return 0;
}
```

> 补充：全双工与半双工
>
> 1、全双工： 指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。
>
> 2、半双工：指一个时间内只有一个方向的信号传输（A→B或B→A）。
>
> 举例说明其原理：
> 一座桥的两头分别有车要过桥，如果桥比较宽，就可以来左去右，互不影响，这就是全双工；
> 如果桥窄，只能先过一边的车，然后再过另一边的车，这就是半双工。
> 对讲机就是半双工的典型例子；电话是全双工的应用。
>
> 以太网中的设备之间进行通信，通常有两种双工模式。一种叫全双工，另一种叫半双工，那两者的区别是什么呢？
>
> 全双工是指两个设备或者多个设备之间进行通信时，支持双向数据传输，且可同时传和接收数据。我们生活中的应用有手机打电话，视频通话等。
>
> 半双工是指两个设备或者多个设备之间进行通信时，也支持双向数据传输，但不能同时发送数据，只能一个发送一个接收，如**对讲机通话就是采用这种半双工通信的模式**。
>
> 半双工模式下，共享式网络中共享线路的通信双发必须采用载波侦听多路访问/冲突检测技术来避免冲突。而全双工模式，通信双发可实现双向通信，这种模式不会产生冲突。
>
> 同一物理链路上的设备的双工模式必须一致。

管道重定向

等位文件描述符

- 就是共享相同的文件位置和状态标志设置，它们代表的是同一个文件和设备

dup()函数：将两个文件描述符等位处理
- 原型：int dup( int oldfd ); int dup2( int oldfd, int newfd );
- 参数：创建oldfd的一份拷贝，单参数版本选择数值最小的未用文件描述符作为新的文件描述符；双参数版本使用newfd作为新的文件描述符，拷贝前尝试关闭newfd
- 返回值：成功时返回新文件描述符，失败时返回-1，并设errno值 
- 示例：dup2( fd, STDIN_FILENO )，就是把fd这个文件描述符所对应的那个文件或设备的那个指针，那个值传给STDIN_FILENO这个文件描述符，让它也指向那个地方，这就意味着标准输入流会被我们关闭，然后会被作为fd的副本重新打开，我们的输入就不再从键盘来，而是从fd多表示的那个文件设备里来，

```c++
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <fcntl.h>
const int buf_size = 4096;
int main ()
{
 int fds[2];
 pipe( fds ); // 创建管道
 pid_t pid = fork();
 if( pid == (pid_t)0 ) // 子进程
 {
 close( fds[0] ); // 关闭管道读取端
 dup2( fds[1], STDOUT_FILENO ); // 1号元和标准输出流挂接在一起，这个管道不是写入嘛，所以你一写就向标准输出流里输数据了
 char * args[] = { "ls", "-l", "/", NULL }; // 使用“ls”命令替换子进程
 execvp( args[0], args );// 执行这个程序“ls”，所以这个数据就全写到了管道里；ls一运行嘛，向标准输出流里写数据啊，标准输出流被我们挂哪去了，挂到管道的写入端了啊，所以这个数据就哗啦哗啦全写到管道里了
 }
 else // 父进程
 { 
 close( fds[1] ); // 关闭管道写入端
 char buf[buf_size];
 FILE * stream = fdopen( fds[0], "r" ); // 以读模式打开管道读取端，返回文件指针
 fprintf( stdout, "Data received: \n" );
 // 在流未结束，未发生读取错误，且能从流中正常读取字符串时，输出读取到的字符串
 while( !feof(stream) && !ferror(stream) && fgets(buf, sizeof(buf), stream) != NULL )
 {
 fputs( buf, stdout );
 }
 close( fds[0] ); // 关闭管道读取端
 waitpid( pid, NULL, 0 ); // 等待子进程结束
 }
 return 0;
}
```

#### 进程信号量

我们这里讲到的是UNIX System V里面的信号量 system V

进程信号量： System V信号量
- 可以使用**同步机制确定进程的先后执行关系**（用的就是进程信号量）
- 头文件：“sys/types.h”、“sys/ipc.h”和“sys/sem.h”

信号量的定义

- 信号量是一类特殊的计数器，其值为非负整数，**用于进程或线程同步**（使用这个信号量的值来去做到这一点）

信号量的操作
- 等待（wait）操作（称为P操作，有时称之为P原语）：信号量的值递减1后返回；**如果值为0，则阻塞操作**，直到信号量值为正（其他进程或线程释放了信号量），然后才能继续递减1，才能返回

  你可以访问这个值，你如果需要用，你就减一，相当于它有一个资源，这个资源上有一个标记，这个标记就是用一个数值来表示的，这个数值就是信号量，比如一个标准的信号量就是1或0，就表示这个资源在任意一个时刻只能有一个进程去访问它，一旦一个进程能够访问它，原来值为1，那么一递减，它一等待它，得到了就会变成0，那么其它的进程就不能够得到它了嘛，这个时候其它的进程就会被阻塞，一直等到第一个进程用完了那个资源，做了一次发布操作

- 发布（post）操作（V，也称V原语）：信号量的值递增1后返回（它用完了这个信号量就递增了，递增1以后，原来等待这个信号量的一个进程呢，它就会被唤醒，它就可以去做减一了，就可以访问那个资源了）；如果信号量值原为0，则其中一个等待该信号量的进程或线程取消阻塞

进程信号量它只是一类特殊的信号量，它的操作的原理依然是这个模样，只不过它等待和发布的时候，这个信号量的数值并不固定为1，同时它定义的也不是一个信号量而是一组信号量。

Linux信号量实现：两个版本

- 进程信号量多用于进程同步
- POSIX标准实现多用于线程同步（这个版本相比简单一点）

使用进程信号量时的注意事项
- 每次创建和管理的进程信号量不是一个，而是一个集合（数
组），该集合可能包含多个进程信号量（看你定义的需要，你需要一个就定义一个，需要两就定义两）
- 在进程里使用键值key来关联对应的进程信号量集，但进程信号量集本身由进程信号量的标识符semid（就是ID）标识，函数调用时几乎总是使用semid——可以这么理解：相当于在进程之间进行同步的时候，semid对内，key对外，你创建和管理，想获取这个进程信号量，用的就是key，得到这个进程信号量后，内部想用它，用的就是semid

semget()函数：创建或获取进程信号量集
- 原型：int semget( key_t key, int nsems, int semflg );
- 参数：key为键值，多个进程可以通过此键值访问同一进程信号量；nsems为需要创建的进程信号量集的进程信号量**元素个数**（不是进程信号量的信号数）， semflg为访问标志
- 返回值：成功时返回进程信号量集的标识符，失败时返回-1，并设置errno值 
- 要获取已分配的进程信号量集，使用原先键值查询，此时进程信号量集的元素个数可设置为0 
- 键值IPC_PRIVATE用于创建当前进程的私有进程信号量集（其实并不是真正的私有，创建一个新的和其它的键值不同的进程信号量） 
- 使用IPC_CREAT和IPC_EXCL创建进程信号量集，后者要求创建新的唯一的进程信号量集，若其已存在，则出错

控制和管理进程信号量集
- 原型：int semctl( int semid, int semnum, int cmd, … );
- 参数：semid为进程信号量集的标识符，semnum为进程信
号量集的元素下标，cmd为指定操作，第四个参数arg可有可
无，与cmd有关
- 返回值：成功时与cmd有关，失败时返回-1，并设置errno值 
- 调用semctl()函数的进程的有效用户ID必须与分配进程信号
量集的用户权限匹配（进程信号量的控制和管理它是有一个非常明确的权限要求的，如果你的进程没有这个权限，那么你是没有办法去控制和管理进行信号量的）

释放（删除）进程信号量集：IPC_RMID
- 最后一个使用进程信号量的进程负责清除进程信号量集 - 进程信号量集释放后，内存自动释放
- 调用说明：把cmd这个命令传这个IPC_RMID就可以删除那个进程信号量，这个时候它的第二个参数semnum是忽略的，你简单传0传什么它都不管，第四个arg它也不需要；如果需
要arg，定义union semun类型的变量并作为参数，部分系统可能未定义union semun类型，需按如下格式补充定义：

```c++
union semun
{
 int val; // 供SETVAL使用的值
 struct semid_ds * buf; // 供IPC_STAT、IPC_SET使用的缓冲区
 unsigned short int * array; // 供GETALL、SETALL使用的数组
 struct seminfo * __buf; // 供IPC_INFO使用的缓冲区
}

// union和struct那个结构体的定义是非常非常类似的，唯一的差别就是union中定义的所有的字段共享同样的存储空间，也就是说，在任何时候它就只有一个字段是有意义的，其它字段表达的是同样的存储区，但是那个型的解释对我们是没有意义的
// 所以union是共用同样存储区的一个字段的集合，它这个字段的序列和struct是不一样的，struct每一个字段是连续存储的，而union是存在同样一个地址区的，同一个位置，任何时候我们只能使用其中一个字段
```

初始化进程信号量集：SETALL
- 第一个参数semid为进程信号量集的标识符，第二个参数
semnum为0，第三个参数cmd为SETALL，它就会全部给你设定，设定每一个进程信号量它的值是多少，这个时候就要传第四个参数arg，必须设定好那个union的array那个字段，标记这些元素的每一个进程信号量的信号数是多少，然后把那个数组基地址传进去，就按照这个模式初始化进程信号量集，第四个参数arg必须为union semun类型的数据对象
- union semun的array字段：指向无符号短整型数组首元素的
指针，该数组保存进程信号量集的所有信号量的信号数

等待与发布进程信号量函数semop()
- 原型：int semop( int semid, struct sembuf * sops, size_t nsops );
- 参数：semid为待操作的进程信号量集的标识符；sops为操作数组，nsops为操作数组的元素个数
- 返回值：成功时为进程信号量集的标识符，失败时返
回-1，并设置errno值

struct sembuf类型的成员
- sem_num：需要操作的进程信号量集中的信号量元素下标

- sem_op：指定信号量操作的整数（递增或递减信号量的信
  号数） 

  - 如果sem_op为正数，则立即加到信号量上（V操作） 

  - 如果sem_op为负数，则从信号量上减去（P操作） 

  - 如果会使结果为负数，则阻塞进程，直到信号量的信号数不小于sem_op的绝对值

  - 如果sem_op为0，则阻塞进程，直到信号量的信号数为0 

- sem_flg：指定IPC_NOWAIT则不阻塞进程，指定SEM_UNDO则在进程退出时取消操作

```c++
// P原语：等待二元信号量，信号数非正时阻塞
int WaitBinarySemaphore( int semid ) {
 struct sembuf ops[1];
 ops[0].sem_num = 0;
 ops[0].sem_op = -1;
 ops[0].sem_flg = SEM_UNDO;
 return semop( semid, ops, 1 );
}
// V原语：发布二元信号量，增加信号数后立即返回
int PostBinarySemaphore( int semid ) {
 struct sembuf ops[1];
 ops[0].sem_num = 0;
 ops[0].sem_op = 1;
 ops[0].sem_flg = SEM_UNDO;
 return semop( semid, ops, 1 );
}
```

#### 共享内存

共享内存很特殊，它的出现比较晚，比管道比进程信号量都要晚。

共享内存的意义：快捷方便的本地通信机制

- 头文件：“sys/ipc.h”和“sys/shm.h”

共享内存编程原则
- 系统没有对共享内存操作提供任何缺省同步行为
- 如果需要，程序员自主设计同步策略：使用进程信号量

共享内存使用过程
- 某个进程分配一个共享内存段，其他需要访问该内存段的进程查询、连接（attach）该内存段 
- 完成共享内存访问后，你就可以不要了 ，进程拆卸（detach）该内存段 
- 某个时刻，如果所有的进程都不用这个共享内存了，那么你就可以释放共享内存区段（一个进程释放该内存段）

Linux内存模型
- 每个进程的**虚拟地址空间按页（page）编址**，页缺省为4096（4kb）字节（不同硬件架构和操作系统可能不同，使用
getpagesize()函数获取当前系统下页面的尺寸） 
- 每个进程维持从内存地址到虚拟页面地址的映射
- 多个进程可能使用同一虚拟页面，但是同样的数据在不同进程中的地址并不需要相同（这有一个地址映射和变换的问题）
- 分配新的共享内存段将创建一个新的虚拟内存页面，其他进程连接该共享内存段即可访问，这样两个进程不就可以通过共享内存进行通讯了嘛
- 共享内存段的分配只有由一个进程负责，释放也同样，如果多个进程都负责去管理这个共享内存区段，那不就乱了套了吗，这是不行的。

获取共享内存

shmget()函数：获取或分配一段共享内存
- 原型：int shmget( key_t key, size_t size, int shmflg );
- 参数：key为内存段整数键值，size为内存段分配的字节数（圆整至4096字节整数倍），shmflg为创建共享内存段的位标志

键值参数key
- 其他进程通过键值key访问该内存段，任意设定的键值可能和其他进程的共享内存段键值冲突，使用IPC_PRIVATE以确保无冲突

创建标志：IPC_CREAT（创建）、IPC_EXCL（独占）
- 后者与前者合并使用，如果键值已使用，则创建失败
- 如果未设IPC_EXCL，则在键值已经存在时，返回其代表的共享内存段，而不是创建一个新的共享内存段（它实际上是查询一个已经创建好的共享内存）

有一些特定的位标志，可以在创建共享内存中使用，尤其是涉及到一些用户的读写权限的地方，包括宿主用户、包括组用户、包括其它用户，

位标志参数

- 模式标志：以9位数字表示宿主、组用户和其他人的访问控制权
- 常数位于头文件“sys/stat.h”

常用模式常数
- S_IRUSR和S_IWUSR分别表示共享内存段宿主的读写权限
- S_IRGRP和S_IWGRP分别表示共享内存段组用户的读写权限
- S_IROTH和S_IWOTH分别表示共享内存段其他人的读写权限

```c++
调用示例
int seg_id = shmget( shm_key, getpagesize(), IPC_CREAT | S_IRUSR | S_IWUSER );
```

shmat()函数：连接共享内存
- 原型：void * shmat( int shmid, const void * shmaddr, int shmflg );
- 参数： shmid为共享内存段标识符（shmget()的返回值）， shmaddr为指针，指向共享内存段的映射地址，如果传递NULL，Linux自动选择合适地址， shmflg为连接标志
- 返回值：成功时返回所连接的共享内存段的地址

连接标志
- SHM_RND：shmaddr指定的映射地址向下圆整到页面尺寸的整数倍；如果未指定，则传递shmaddr时必须手工对齐页面地址
- SHM_RDONLY：共享内存段组只读

shmdt()函数：拆卸共享内存段

- 原型：int shmdt( const void * shmaddr );

```c++
#include <stdio.h>
#include <sys/shm.h>
#include <sys/stat.h>
int main ()
{
 struct shmid_ds shmbuf;
 int seg_size;
 const int shared_size = 0x6400;
 // 分配共享内存段
 int seg_id = shmget( IPC_PRIVATE, shared_size, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR );
 // 连接共享内存段,得到共享内存的基地址，把它转型成指向字符指针之后我们就可以操纵这个共享内存区段了
 char * shared_mem = ( char * )shmat( seg_id, 0, 0 );
 printf( "Shared memory attached at %p\n", shared_mem );
 // 获取段尺寸信息
 shmctl( seg_id, IPC_STAT, &shmbuf );// 用IPC_STAT得到它的信息
 seg_size = shmbuf.shm_segsz;
 printf( "Segment size: %d\n", seg_size );
 // 向共享内存区段写入字符串
 sprintf( shared_mem, "Hello, world." );
 // 拆卸共享内存区段
 shmdt( shared_mem );
 // 在不同的地址处重新连接共享内存区段
 shared_mem = ( char * )shmat( seg_id, ( void * )0x5000000, 0 );
 printf( "Shared memory reattached at %p\n", shared_mem );
 // 获取共享内存区段中的信息并打印
 printf( "%s\n", shared_mem );
 // 拆卸共享内存区段
 shmdt( shared_mem );
 // 释放共享内存区段，与semctl类似
 shmctl( seg_id, IPC_RMID, 0 );
 return 0;
}
```

#### 映射内存

它和共享内存非常的类似，它们的基本机制是一样的，唯一的差别就是映射内存它将会**将一个文件映射到我们这个内存区域里边**

mmap()函数：头文件“sys/mman.h” 

- 映射共享文件到内存；**文件被分割成页面大小装载**；这个时候就可以向内存数据一样来操纵这个文件，使用内存读写操作访问文件，速度更快；对映射内存的写入自动反映到文件中
- 原型：void * mmap( void * addr, size_t length, int prot, int
  flags, int fd, off_t offset );

函数参数
- addr：映射目的地的内存地址，NULL表示由Linux自动选择合适
的内存地址
- length：映射内存的大小，以字节为单位
- prot：指定映射内存的保护权限，为PROT_READ（允许读取）、
PROT_WRITE（允许写入）、 PROT_EXEC（允许执行）或以上
三者的组合

- flags：附加选项标志；为MAP_FIXED（如果指定此标志，则
Linux使用用户指定的地址映射文件，地址本身必须页对齐）、
MAP_PRIVATE（内存写入不回写至外部文件，本进程保留写
入的文件副本）、 MAP_SHARED（内存写入立即反映到映射
文件中）； MAP_PRIVATE与MAP_SHARED不能混用 
- fd：待映射文件的文件描述符
- offset：指定映射数据在文件中的偏移量

函数返回值

- 成功调用时返回映射内存的基地址，失败时返回MAP_FAILED

munmap()函数：释放映射内存
- 原型：int * munmap( void * addr, size_t length );
- 参数：addr为映射内存的基地址；length为映射内存的大小
- 返回值：成功时返回0，失败时返回-1并设errno值

msync()函数：映射内存同步
- 原型：int msync( void * addr, size_t length, int flags);
- 参数：addr为映射内存基地址，length为映射内存大小，flags为同步标志，MS_ASYNC（数据更新被调度，但函数返回前并不一定会被执行）；MS_SYNC（数据更新立即执行，在完成前调用进程被阻塞）；MS_INVALIDATE（通知其他进程数据已无效，并自动提供新数据）；MS_ASYNC与MS_SYNC不能混用 
- 返回值：成功时返回0，失败时返回-1并设errno值

```c++
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <wait.h>
#include <iostream>
#include <iomanip>
const int mapped_size = 4096;
const int mapped_count = mapped_size / sizeof(int);
int main( int argc, char * const argv[] )
{
 // 打开文件作为内存映射的对象，确保文件尺寸足够存储1024个整数
 int fd = open( argv[1], O_RDWR | O_CREAT, S_IRUSR | S_IWUSR );
 lseek( fd, mapped_size - 1, SEEK_SET );// 定位到文件结尾
 write( fd, "", 1 );// 朝里面写一个空白
 lseek( fd, 0, SEEK_SET );// 重新再定位到开头
 int * base = ( int * )mmap( 0, mapped_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, fd, 0 );
 close( fd ); // 创建映射内存后，关闭文件的文件描述符
 pid_t pid = fork();
 if( pid == (pid_t)0 ) // 子进程写入数据
 {
 // 写入数据0～1023
 for( int i = 0, * p = base; i < mapped_count; *p++ = i++ ) ;// 因为整个循环内部要做的事情都在循环头部做完了，所以循环体本身是空的
 munmap( base, mapped_size );
 }
 else if( pid > (pid_t)0 ) // 父进程读取数据
 {
 sleep( 10 ); // 等待10秒
 for( int i = 0, *p = base; i < mapped_count; i++, p++ )
 	std::cout << std::setw(5) << *p << " ";
 std::cout << std::endl;
 munmap( base, mapped_size );
 }
 return 0;
}
// 因为这个文件映射是在我们构造这个子进程之前就做完了，所以这个映射的内存自动地被父进程和子进程所共享，父进程和子进程就可以使用那个映射内存来交换数据
//这个显然要比使用管道方便一些，因为，第一它可以和文件挂在一块，第二这个尺寸你可以定很大，当你要传大量数据的时候，这个就很有用了
```

#### 消息队列

消息队列：在两个进程间传递二进制块数据
- 数据块具有类别信息，接收方可根据消息类别有选择地接收
- 头文件：“sys/type.h”、“sys/ipc.h”和“sys/msg.h”

msgget()函数：创建或获取消息队列
- 原型：int msgget( ket_t key, int msgflg );（和进程信号量和共享内存都差不多）
- 参数：key为键值，标识全局唯一的消息队列；msgflg为创建标志，与semget()的标志相同
- 返回值：成功时返回正整数作为消息队列的标识符，失败时返回-1，并设errno值 
- 如果用于创建消息队列，相关内核数据结构struct msqid_ds将被创建并初始化

msgsnd()函数：将消息添加到消息队列中 

- 原型：int msgsnd( int msqid, const void * msg_ptr, size_t
  msg_sz, int msgflg );

- 参数： msqid为msgget()返回的消息队列标识符；msg_ptr指向准备发送的消息； msg_sz为消息数据长度；msgflg控制消息发送行为，一般仅支持IPC_NOWAIT标志，即以非阻塞的方式发送消息
- 返回值：成功时返回0，失败时返回-1，并设errno值

消息缓冲区结构
- msg_ptr指向的数据结构如下
- mtype为消息类别，必须为正整数
- mtext为消息数据，msg_sz为其实际长度

```c++
struct msgbuf
{
 long int mtype;
 char mtext[512];// 它的长度是受限的，512个字节；当然一般来讲你传一个消息不会有太长的，是一个简单的信息传递机制，不能传递太复杂的消息；如果过多，那么消息队列处理的模式就不如我们的映射内存了，不如我们的共享内存了
};
```

msgrcv()函数：从消息队列中获取消息
- 原型：int msgrcv( int msqid, void * msg_ptr, size_t
msg_sz, long int msgtype, int msgflg );
- 参数： msqid为msgget()返回的消息队列标识符；msg_ptr用
于存储接收的消息；msg_sz为消息数据长度；msgtype为消息
类别；msgflg控制消息发送行为，可以为IPC_NOWAIT、
MSG_EXCEPT（msgtype大于0时，读取第一个非msgtype类
别的消息）和MSG_NOERROR的位或
- 返回值：成功时返回0，失败时返回-1，并设errno值 
- 消息类别msgtype说明：为0则读取队列第一条消息，大于0则
读取队列中第一条类别为msgtype的消息，小于0则读取队列中
第一个类别比msgtype绝对值小的消息

msgctl()函数：控制消息队列的某些属性（控制方式和进程信号量类似）
- 原型：int msgctl( int msqid, int cmd, struct
msqid_ds * buf );
- 参数： msqid为msgget()返回的消息队列标识符；cmd指
定要执行的命令，支持的命令有IPC_STAT、IPC_SET、
IPC_RMID、IPC_INFO、MSG_INFO、MSG_STAT；buf
的意义与cmd参数有关
- 返回值：成功时返回值取决于cmd参数，失败时返回-1，
并设errno值

### 5.进程池

动机：为什么需要引入进程池？
- 在进行多进程编程的时候，我们需要频繁地创建子进程，有些特定的服务，它需要创建子进程来替你完成客户的请求，那么当这个客户请求很多很频繁地到达的时候，我们就需要频繁地创建子进程，当它服务完这个请求后，这个子进程又会被清除。那么在这种情况下就会涉及到频繁地创建或释放子进程，这个效率显然是低的
- 动态创建子进程的过程效率较低，客户响应速度较慢
- 动态创建的子进程一般只为单一客户提供服务，当客户较多
时，系统中会存在大量子进程，进程频繁创建、销毁和切换的开销过高
- 动态创建的子进程为当前进程的完整映像，当前进程必须谨
慎地管理系统资源，以防止子进程不适当地复制这些资源

我们在服务器启动的时候可以创建好几个子进程，专门等待着来为客户服务，服务你之后这个子进程就可以一边歇着去了，你不用把它销毁，当新的客户来了，就把这个子进程重新再叫出来，替客户提供服务不就完了嘛，干嘛每次一个客户请求来，都创建一个新的子进程呢，如果这些子进程能够被很好的复用起来，那整个程序的运行效率就会提高很多

什么是进程池？

- 主进程预先创建一组子进程，并统一管理（当客户请求到达以后，它就从主进程所创建的这个子进程池子里选一个子进程出来，响应客户的请求，这样的话我们程序执行起来效率又高，管理起来又方便
- 子进程运行可以使用同样代码，具有同样属性，真实低地创建这个进程池的时候创建出来的子进程个数，它有一个习惯性的约定，一般与CPU数目一致，有时可以多一些，比如可以是CPU数目的两倍，因为现在有的CPU可以做超线程计算，一个核实际上可以同时跑两个线程，甚至我们可以当作跑两个进程，很少超过CPU数目的两倍

进程池的工作原理是什么？
- 主进程创建一个进程池的时候，它充当服务器角色，子进程充当服务员，子进程按照服务器的需要提供服务
- 在任务到达时，主进程选择一个子进程进行服务
- 相对于动态创建子进程，选择的代价显然更小——**这些子进**
**程未来还可以被复用**（如果进程只用一遍，不管你是开始就创建还是临时创建，效果都一样；复用就是可以响应完一个请求后， 又来个请求可以继续响应，这样省略了第二次创建一个子进程的动作）
- 存在多种选择子进程的策略，如随机选择或轮值制度（一个接着一个来），子进程共享单一任务队列，有任务了它就去响应，没有任务它就睡眠也是可以的，这些子进程在提供服务的时候，有的子进程很忙，有的子进程很闲，那么你的程序中还可以使用更加智能化的负载平衡技术
- 父子进程之间应该具有传递信息的通道，如管道、共享内存、
消息队列等，也可能需要同步机制

## 十四.线程编程

### 1.线程基本概念

线程的定义
- 线程是比进程更小的程序执行单位
- **多个线程可共享进程的全局数据**，也可使用专有数据

一个进程包括很多个线程，那么这些线程就共享这个进程的全局堆，每个线程因为要执行自己的那个函数调用，所以线程都有自己独立的栈，但共享进程的堆。

Linux线程支持史
- 1996年，LinuxThreads：基本符合POSIX标准，但
  效率低下，问题多多
- 2003年，内核2.6：提供线程支持库NPTL（Native 
  POSIX Thread Library for Linux），也就是我们俗称的pthread，Linux的多线程编程才逐渐引起重视

内核线程
- 操作系统内核支持多线程调度与执行（那么它内部就会有所谓的内核线程）
- 内核线程使用资源较少，仅包括内核栈和上下文切换时
需要的保存寄存器内容的空间

轻量级进程（lightweight process，LWP） 

此前Linux的调度都是以进程位单位的，调度的开销非常大，所以后来为了降低进程调度的开销，它提出了一个轻量级进程的概念

- 由内核支持的独立调度单元，调度开销小于普通的进程

- 系统支持多个轻量级进程同时运行，每个都与特定的内
核线程相关联，这样才能被调度

用户线程

真正在开发的时候，我们要写的是用户线程

- 建立在用户空间的多个用户级线程，映射到轻量级进程
后调度执行，然后在轻量级进程里再映射到内核线程里去调度执行
- 用户线程在用户空间创建、同步、维护、管理、销毁，开销较低
- 每个线程具有独特的ID

以上三个是从不同角度讨论操作系统内部是如何进行线程调度和管理的

使用说明
- 线程功能不属于C/C++标准库，链接时需用-pthread选项
- 线程功能属于C++11标准库，可用C++11提供的thread类定义线程对象，C++11标准库同时提供基本的线程同步机制

进程与线程的比较
- 线程空间不独立，有问题的线程会影响其他线程；进
程空间独立，有问题的进程一般不会影响其他进程（影响的概率相当小）
- 创建进程需要额外的性能开销，而创建线程的开销它实际上是小的，和进程的创建开销相比要小的多，调度的时候也一样开销要小得多
- 线程用于开发细颗粒度并行性，进程用于开发粗颗粒度并行性（虽然很多事情用多进程来做可以，多线程来做可以，但是从实现这个角度来讲，要开发细粒度并行性的话，用多线程来做实际上要比用多进程来做效果要好上那么一点）
- 线程容易共享数据，进程（地址空间完全独立）共享数据必须使用进程间通讯机制

### 2.线程管理

#### 线程创建

```c++
线程创建函数
- 头文件：“pthread.h” - 原型：int pthread_create( pthread_t * thread, const pthread_attr_t * attr, void * ( *start_routine )( void * ), void * arg );
// 第三个参数是一个函数指针（老师这么说，严格来讲我觉得应该是函数指针函数），回调函数参数嘛，它就是我们的线程那个执行的函数，它会指向那个线程函数；第四个就是一个附加参数arg
```

线程创建流程
- 定义指向pthread_t对象的指针对象，**pthread_t对象用于存储新线程的ID**
- 定义指向线程属性pthread_attr_t对象的指针对象；线程属性对象控制线程与程序其他部分（可能是其他线程）的交互；如果你不需要设定这个线程的属性对象，那么这个指针你可以传NULL，则使用缺省属性构造新线程

- 定义指向线程函数的指针对象，使其指向固定格式的线程函数（你不定义直接传那个线程执行函数的那个地址过来也可以）
- 实现线程函数；线程函数的参数和返回值均为哑型指针；需要传递多个参数时，那么把这些参数打包成形成一个结构单个void*型的指针对象，然后传它的地址；如果返回值也有很多个，也可以把这些返回值打包，把他的地址传出去
- 线程退出时使用返回值将数据传递给主调线程；多个结果同样可以打包传递

线程创建说明
- pthread_create()函数在线程创建完毕后立即返回，它并不等待线程结束
- 原线程与新线程如何执行与调度有关，程序不得依赖线程先后执行的关系（不能对操作系统的调度做任何预先的假定）
- 可以使用同步机制确定线程的先后执行关系

线程退出方式
- 线程函数结束执行
- 调用pthread_exit()函数显式结束
- 被其他线程撤销

```c++
#include <pthread.h>
#include <iostream>
void * PrintAs( void * unused )
{
 while( true ) std::cerr << 'a';
 return NULL;
}
void * PrintZs( void * unused )
{
 while( true ) std::cerr << 'z';
 return NULL;
}
int main()
{
 pthread_t thread_id;
 pthread_create( &thread_id, NULL, &PrintAs, NULL );//子线程负责打印a
 PrintZs( NULL );// 主函数负责打印z
 return 0;
}
```

#### 线程函数参数与返回值

那我要想向这个线程里传递一个参数怎么办？

```c++
#include <pthread.h>
#include <iostream>
class InfoPrinted
{
public:
 InfoPrinted( char c, int n ) : _c(c), _n(n) { }
 void Show() const { for( int i = 0; i < _n; i++ ) std::cerr << _c; }
private:
 char _c;// 要打印的字符
 int _n;// 打印多少遍
};
// 线程函数
void * PrintInfo( void * info )
{
 // 对象的基地址通过制作info传进来了
 InfoPrinted * p = reinterpret_cast<InfoPrinted *>( info );
 if( p ) p->Show();
 return NULL;
}
```

```c++
// 注意：本程序大部分情况下不会输出任何结果
int main()
{
 pthread_t tid1, tid2;
 // 动态构造InfoPrinted类的对象，作为线程函数参数传递给线程tid1
 // 输出100个‘a’
 InfoPrinted * p = new InfoPrinted( 'a', 100 );
 pthread_create( &tid1, NULL, &PrintInfo, reinterpret_cast<void *>( p ) );// 第四个参数就是我们要传给那个线程函数的参数列表中的那个附加参数，这就是那个回调函数的参数啊
 // 构造InfoPrinted类的动态对象，作为线程函数参数传递给线程tid2
 // 输出100个‘z’
 InfoPrinted * q = new InfoPrinted( 'z', 100 );
 pthread_create( &tid2, NULL, &PrintInfo, reinterpret_cast<void *>( q ) );
 // 使用本注释行替换上述线程，可以看到输出结果，可能仅有部分输出
 // PrintInfo( reinterpret_cast<void *>( q ) );
 return 0;
}
```

存在的问题：一般不会产生任何输出
- 子线程需要使用主线程的数据，如果主线程结束，子线程想调度，它用啥数据呢？数据没了，它用不了了 ，所以它访问不到那些数据

解决方案：使用pthread_join()函数，等待子线程结束，就是保证主线程在子线程之后才结束

- 原型：int pthread_join( pthread_t thread, void ** retval );
- 参数：thread为**pthread_t类型的线程ID**；retval接收线程返回值，不需要接收返回值时传递NULL

```c++
// 注意：无法确定两个线程的执行顺序，多次输出结果可能不同
int main()
{
 pthread_t tid1, tid2;
 InfoPrinted * p = new InfoPrinted( 'a', 100 );
 pthread_create( &tid1, NULL, &PrintInfo, reinterpret_cast<void *>( p ) );
 InfoPrinted * q = new InfoPrinted( 'z', 100 );
 pthread_create( &tid2, NULL, &PrintInfo, reinterpret_cast<void *>( q ) );
 // 等待子线程结束
 pthread_join( tid1, NULL );
 pthread_join( tid2, NULL );
 return 0;
}
```

线程函数返回值

```c++
#include <pthread.h>
#include <cmath>
#include <iostream>
void * IsPrime( void * n )
{
 unsigned int p = reinterpret_cast<unsigned int>( n );
 unsigned int i = 3u, t = (unsigned int)sqrt( p ) + 1u;
 if( p == 2u )
 	return reinterpret_cast<void *>( true );
 if( p % 2u == 0u )
 	return reinterpret_cast<void *>( false );
 while( i <= t )
 {
 if( p % i == 0u )
 	return reinterpret_cast<void *>( false );
 i += 2u;
 }
 return reinterpret_cast<void *>( true );
}
```

```c++
// 使用g++ main.cpp –pthread –lm –fpermissive编译
// 以防止编译器将void*到int的转型当作错误
int main()
{
 pthread_t tids[8];
 bool primalities[8];
 int i;
 // 创建8个线程
 for( i = 0; i < 8; i++ )
 	pthread_create( &tids[i], NULL, &IsPrime, 		       reinterpret_cast<void *>( i+2 ) );
 // 等待8个线程都做完，做完之后这个数据就会被写到素性数组里
 for( i = 0; i < 8; i++ )
 	pthread_join( tids[i], reinterpret_cast<void **>(     &primalities[i] ) );
    // 第二个参数传的就是那个线程返回值要放的地方的地址，它接受的是一个哑型指针的指针，严格讲起来它是指向哑型指针的指针
 for( i = 0; i < 8; i++ )
 	std::cout << primalities[i] << " ";
 std::cout << std::endl;
 return 0;
}
```

#### 线程ID

```c++
pthread_equal()函数：确认两个线程是否相同
- 原型：int pthread_equal( pthread_t t1, pthread_t
t2 );
pthread_self()函数：返回当前线程的ID
- 原型：pthread_t pthread_self();
- 示例：
if( !pthread_equal( pthread_self(), other_tid ) ) 
    pthread_join( other_tid, NULL );
```

#### 线程属性

线程属性：精细调整线程的行为

设置线程属性的流程
- 创建pthread_attr_t类型的对象
- 调用pthread_attr_init()函数初始化线程的缺省属性，传递指向该线程属性对象的指针
  - 原型：int pthread_attr_init( pthread_attr_t * attr );
- 对线程属性进行必要修改
- 调用pthread_create()函数时传递指向线程属性对象的指针

- （如果线程创建完之后，这个线程属性对象你不要了）调用pthread_attr_destroy()函数清除线程属性对象（仅仅是清除线程属性对象里边的属性设置），pthread_attr_t对象本身没有被销毁，因而可以调用pthread_attr_init()函数再次初始化
- 原型：int pthread_attr_destroy( pthread_attr_t * attr );

线程属性说明
- 单一线程属性对象可以用于创建多个线程
- 线程创建后，继续保留线程属性对象本身并没有意义，所以大部分的时候都会销毁它
- 对大多数Linux程序，线程最重要的属性为分离状态（detach state），其它我们很少设定

线程分类
- 可联线程（joinable thread）：缺省设置，终止时并不自动清除（类似僵尸进程，进程结束了但是它的状态并没有被取出来），主线程必须调用pthread_join()等待它结束获取其返回值，此后才能清除（joinable，你要联接它然后才能做清除工作）
- 分离线程（detached thread）：结束时自动清除，不能调用pthread_join()进行线程同步
- 可联线程可通过pthread_detach()函数分离，分离后这个线程
  不能再次联接了，再也不能调用pthread_join()去等待它了
  - 原型：int pthread_detach( pthread_t thread );

所有的线程缺省的都是可联线程，你都必须调用pthread_join()去等待它结束

```c++
pthread_attr_setdetachstate()函数：设置线程分离属性
- 原型：int pthread_attr_setdetachstate
( pthread_attr_t * attr, int detachstate );
- 传递线程属性对象指针和分离线程设置参数
// 缺省情况是可联，所以如果你在创建线程的最初就把它变成一个分离线程，那么你的第二个参数就传PTHREAD_CREATE_DETACHED
    
pthread_attr_getdetachstate()函数：获取线程分离属性
- 原型：int pthread_attr_getdetachstate
( pthread_attr_t * attr, int * detachstate );
```

```c++
#include <pthread.h>
// 线程函数
void * ThreadFunc( void * arg ) { ... }
int main()
{
 pthread_attr_t attr;
 pthread_t thread;
 // 初始化线程属性
 pthread_attr_init( &attr );
 // 设置线程属性的分离状态
 pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_DETACHED );
 // 创建线程
 pthread_create( &thread, &attr, &ThreadFunc, NULL );
 // 清除线程属性对象
 pthread_attr_destroy( &attr );
 // 无需联结该线程
 return 0;
}
```

#### 线程撤销

pthread_cancel()函数：撤销线程
- 原型：int pthread_cancel( pthread_t thread );
- 已撤销的线程可以联结，且必须联结，以释放其资源(不联接好多清除工作没法做），除非其为分离线程

线程撤销类型与状态
- 异步可撤销：在其执行的任何时刻都可撤销
- 同步可撤销：线程可撤销，但撤销操作首先进入队列排队，
在线程执行到特定撤销点时才可撤销（所以是一种延迟的撤销）
- 不可撤消：撤销不可撤消线程的企图被系统忽略，且没有任何消息反馈

pthread_setcanceltype()函数：设置线程的撤销类型

**以什么样的方式去撤销**

- 原型： int pthread_setcanceltype( int type, int * oldtype );
- 参数：type为撤销类型，oldtype用于保存原始线程撤销类型，NULL表示不保存
- PTHREAD_CANCEL_ASYNCHRONOUS：线程异步可撤销
- PTHREAD_CANCEL_DEFERRED：线程同步可撤销，即延迟到下一撤销点时撤销

pthread_setcancelstate()函数：设置线程的撤销状态

**这里是能不能够撤销**

- 原型： int pthread_setcancelstate( int state, int * oldstate );
- 第一个参数state为可撤销状态，第二个参数oldstate用于保存原始线程可撤销状态，NULL表示不保存
- PTHREAD_CANCEL_ENABLE：线程可撤销
- PTHREAD_CANCEL_DISABLE：线程不可撤销
- 线程的撤销状态可多次设置

pthread_testcancel()函数：设置撤销点
- 原型：void pthread_testcancel();
- 在线程函数中调用pthread_testcancel()函数设置撤销点 
- 建议：周期性地设置撤销点，保证线程函数内部每隔一些代码就有一个撤销点，以保证资源能够正确释放

使用撤销状态构造临界区（critical section） 

- 临界区：要么全部执行，要么一条都不执行的代码段

- 设置线程的撤销状态，线程一旦进入临界区，你就把它设置成不可撤销的这个模式，那么就必须等到它离开临界区（恢复它的可撤销模式之后），才可以被撤销

  保证代码一定别执行或者一定不被执行

```c++
// 账户转账
void Transfer( double * accounts, int from, int to, double amount )
{
 int ocs;
 // 数据有效性检查代码在此，确保转账操作合法有效
 // 将线程设置为不可撤销的，进入临界区
 pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, &ocs );
 accounts[to] += amount;
 accounts[from] -= amount;
 // 恢复线程的撤销状态，离开临界区
 pthread_setcancelstate( ocs, NULL );
}
```

#### 线程局部存储

线程局部存储（thread local storage，TLS）：用它来存储每个线程的独有数据

- 线程特定数据（thread-specific data） 
- 进程的多个线程通过全局堆共享全局数据对象
- 每个线程拥有独立的栈

如果有几个线程想要设定这个全局对象的值呢，那到底以哪一个为准呢，所以很多时候每个单独的线程都想访问自己的那个全局对象的唯一的一个副本，那么怎么保证这一点呢，这就叫线程的局部存储

让线程拥有数据的独立副本：不能简单赋值或读取
- pthread_key_create()函数：为线程特定数据创建一个键，把它和线程局部存储的数据对象关联起来，接下来就可以通过键值对这个数据对象进行控制和管理
- 参数：第一个为指向pthread_key_t类型变量的指针（每个线程都可以使用它访问自己的独立数据副本）；第二个参数为指向线程清除函数的指针，如果不存在，传递NULL
- pthread_setspecific()函数：设置对应键的值 
- pthread_getspecific()函数：读取对应键的值

```c++
#include <pthread.h>
#include <stdio.h>
static pthread_key_t tlk; // 关联线程日志文件指针的键
// 每个线程都有自己独立的日志文件；但是这个日志文件本身作为一个对象在我们程序内部一开始是独一的，当你创建很多线程的时候显然不能访问那个独一的文件，因为每个特定的文件那个文件的名字应该是和线程的id是相关的，所以我们就需要使用线程局部存储
void WriteToThreadLog( const char * msg ) {
 FILE * fp = ( FILE * )pthread_getspecific( tlk );
 fprintf( fp, "%d: %s\n", (int)pthread_self(), msg );
}
void CloseThreadLog( void * fp ) {
 fclose( ( FILE * )fp );
}
void * ThreadFunc( void * args ) {
 char filename[255];
 FILE * fp;
 // 生成与线程ID配套的日志文件名
 sprintf( filename, "thread%d.log", (int)pthread_self() );
 fp = fopen( filename, "w" );
  // 设置线程日志文件指针与键的局部存储关联
 pthread_setspecific( tlk, fp );
 // 向日志中写入数据，不同的线程会写入不同的文件
 WriteToThreadLog( "Thread starting..." );
 return NULL;
}
int main()
{
 int i;
 pthread_t threads[8];
 
 // 每一个线程都可以使用tlk（talk）这个键值来访问它自己所独有的那个文件指针对象
 // 要在线程的创建之前完成这个线程的局部存储键值的创建
 // 创建键，使用CloseThreadLog()函数作为其清除程序
 pthread_key_create( &tlk, CloseThreadLog );
 for( i = 0; i < 8; ++i )
 	pthread_create( &threads[i], NULL, ThreadFunc, NULL );
 for( i = 0; i < 8; ++i )
 	pthread_join( threads[i], NULL );
 pthread_key_delete( tlk );
 return 0;
}
```

#### 线程清除

线程清除函数：回调函数，单void*参数，无返回值

- 目的：销毁线程退出或被撤销时未释放的资源

pthread_cleanup_push()函数：注册线程清除函数
- 原型： void pthread_cleanup_push( void (* routine)(void *), 
void * arg );
- 参数：routine为指向**线程清除函数的函数指针**，arg为传递给回
调函数的附加数据对象

pthread_cleanup_pop()函数：取消线程清除函数注册
- 原型： void pthread_cleanup_pop( int execute );
- 参数：整型值，非0调用回调函数释放资源（在取消注册的时候，替你完成线程最后的清除工作，你不pop，它实际上是不清除的），0不释放

```c++
#include <malloc.h>
#include <pthread.h>
void * AllocateBuffer( size_t size )
{
 return malloc( size );
}
void DeallocateBuffer( void * buffer )
{
 free( buffer );
}
void DoSomeWork()
{
 void * temp_buffer = AllocateBuffer( 1024 );
 // 注册清除处理函数
 pthread_cleanup_push( DeallocateBuffer, temp_buffer );
 // 此处可以调用pthread_exit()退出线程或者撤销线程
 // 取消注册，传递非0值，实施清除任务
 pthread_cleanup_pop( 1 );// 取消这个函数的注册，执行那个函数，把这个线程分配的这个缓冲区给销毁
}
```

C++的问题
- 对象的析构函数在线程退出时可能没有机会被调用，因而线程栈上的数据未清除
- 如何保证线程资源被正确释放？

解决方法
- 定义异常类，线程在准备退出时引发异常，然后在异常处理中退出线程执行
- 引发异常时，C++确保析构函数被调用

```c++
#include <pthread.h>
class EThreadExit {
public:
 EThreadExit( void * ret_val ) : _thread_ret_val(ret_val) { }
 // 实际退出线程，使用对象构造时的返回值
 void* DoThreadExit () { pthread_exit( _thread_ret_val ); }
private:
 void * _thread_ret_val;
};
void * ThreadFunc( void * arg ) {
 try {
 if( 线程需要立即退出 )
 throw EThreadExit( 线程返回值 );
 }
 catch( const EThreadExit & e ) {
 e.DoThreadExit(); // 执行线程实际退出动作
 }
 return NULL;
}
```

### 3.线程同步机制

#### 资源竞争

编程任务
- 存在一个任务队列，多个并发线程同时处理这些任务。每个线程在完成某项任务后，检查任务队列中是否有新任务。如果有，就处理该任务，并将该任务从任务队列中删除。 
- 假设：两个线程碰巧完成各自任务，但队列中只有一个任务。 
- 可能发生的情况：第一个线程发现任务队列非空，准备接收该任务，但没有完成全部设置。此时，操作系统碰巧中断该线程。第二个线程获得了执行，也发现任务队列非空，同样准备接收该任务，但发现已无法正确设置任务队列。 
- 最坏情况：第一个线程已经从队列中摘取了任务，但是还没有将任务队列设置为空，第二个线程对任务队列的访问导致段错误，系统崩溃。

```c++
// 有问题的程序代码
#include <list>
struct Job;
std::list<Job *> job_queue;
// 线程函数
void * DequeueJob( void * arg ) {
 if( !job_queue.empty() )
 {
 Job * job = job_queue.front();// 取到队列的队首元
 job_queue.pop_front();
 ProcessJob( job );
 delete job, job = NULL;
 }
 return NULL;
}
// 这个任务队列里，只有一个任务，两个线程去竞争访问的时候，这段程序代码就会出问题，单线程的程序，这一切都很正常，但是多线程编程的时候就需要特别注意
```

#### 互斥

第一种解决方案就是互斥

互斥（mutex）定义与性质：MUTial EXclusion
- 就是相互独占锁，与二元信号量类似
- 一次只有一个线程可以锁定一个数据对象，并访问
- 只有该线程释放锁定，其他线程才能访问该数据对象

pthread_mutex_init()函数：初始化互斥
- 原型：int pthread_mutex_init( pthread_mutex_t * 
mutex, const pthread_mutexattr_t * mutexattr );
- 参数： mutex为互斥对象，mutexattr为互斥属性对象，NULL表示使用缺省属性
- 可使用预定义宏PTHREAD_MUTEX_INITIALIZER初始化互斥

```c++
pthread_mutex_destroy()函数：销毁互斥
- 原型：int pthread_mutex_destroy( pthread_mutex_t * mutex );
pthread_mutex_lock()函数：互斥加锁
- 原型：int pthread_mutex_lock( pthread_mutex_t * mutex );
- 锁定这个互斥，获取这个互斥的访问
- 如果无法锁定，则当前线程就会被阻塞，一直到它能够锁定
pthread_mutex_trylock()函数：互斥加锁
- 原型：int pthread_mutex_trylock( pthread_mutex_t * mutex );
- 如果无法锁定，则立即返回，不阻塞
pthread_mutex_unlock()函数：互斥解锁
- 原型：int pthread_mutex_unlock( pthread_mutex_t * mutex);
```

使用互斥的流程
- 定义pthread_mutex_t类型的变量，将其地址作为第一个参数传给pthread_mutex_init()函数；初始化函数只需调用一次 
- 锁定或尝试锁定该互斥；获得访问权后，执行正常程序代码；
并在执行完毕后解锁

互斥属性
- pshared属性：进程共享属性

  - 取值：PTHREAD_PROCESS_SHARED（跨进程共享），
    PTHREAD_PROCESS_PRIVATE（本进程内部共享） 

  大部分时候使用第二个属性取值，就是本进程内共享，进程外不共享；大部分操作系统支持进程间共享互斥，但是很多时候因为我们做的是多线程编程，往往是一个进程的很多个线程，所以进程内共享是最常见的属性

- type属性：互斥类型

互斥type属性
- PTHREAD_MUTEX_NORMAL：普通锁 

  - 被某个线程锁定后，其他请求加锁的线程将等待

  - 容易导致死锁 

  - 解锁被其他线程锁定或已解锁的互斥，这个结果可能是无定义的，将导致不可预期的后果

- PTHREAD_MUTEX_ERRORCHECK：检错锁 

  - 线程对已被其他线程锁定的互斥加锁，将返回EDEADLK

- PTHREAD_MUTEX_RECURSIVE：递归锁 

  - 允许线程对互斥多次加锁；解锁次数必须与加锁次数匹配

- PTHREAD_MUTEX_DEFAULT：默认锁 

  - 实现上可能为上述三种之一，它并不是单独的一个选择，缺省的时候大部分系统使用的是第一个

```c++
互斥属性函数
- 初始化互斥属性对象：
int pthread_mutexattr_init( pthread_mutexatt_t * attr );
- 销毁互斥属性对象：
int pthread_mutexattr_destroy( pthread_mutexatt_t * attr );
- 获取pshared属性：int pthread_mutexattr_getpshared( const pthread_mutex_t * mutex, int * pshared );
- 设置pshared属性：
int pthread_mutexattr_setpshared( pthread_mutex_t * mutex, int pshared );
- 获取type属性：int pthread_mutexattr_gettype( const
pthread_mutex_t * mutex, int * type );
- 设置type属性：int pthread_mutexattr_settype( pthread_mutex_t * mutex, int type );
```

...

```c++
// 作业入队时需要加锁
void * EnqueueJob( void * arg ) {
 Job * job = reinterpret_cast< Job * >( arg );
 pthread_mutex_lock( &job_queue_mutex ); // 锁定互斥
 job_queue.push_back( job );
 // 入队时也输出线程ID和作业内容信息
 std::cout << "Thread " << (int)pthread_self();
 std::cout << " enqueueing (" << job->x << ", " << job->y << ")\n";
 pthread_mutex_unlock( &job_queue_mutex ); // 解锁，这个动作应该放在push_back()之后，让我们这个临界区内部的代码尽可能的短
 return NULL;
}
```

#### 死锁

死锁：资源被竞争占用，且无法释放

处理策略：更改互斥类型

- 创建互斥属性pthread_mutexattr_t型的对象
- 调用pthread_mutexattr_init()函数初始化互斥属性对象，
传递其地址
- 调用pthread_mutexattr_setkind_np()函数设置互斥类型，
函数第一个参数为指向互斥属性对象的指针，第二个参数为
PTHREAD_MUTEX_RECURSIVE_NP（递归互斥）或
PTHREAD_MUTEX_ERRORCHECK_NP（检错互斥）
- 调用pthread_mutexattr_destroy()函数销毁互斥属性对象

#### 信号量

问题：如何确保任务队列中有任务可以做？
- 如果队列中没有任务，线程可能退出，后续任务出现时，没有
线程可以执行它

POSIX标准信号量：头文件“semaphore.h” 

- 用于多个线程的同步操作

- 操作方法比进程信号量简单

初始化信号量
- 原型：int sem_init( sem_t * sem, int pshared, unsigned 
int value );
- 参数：sem为信号量对象，pshared为共享属性，value为信
号量初始值

等待信号量：P操作
- 原型：int sem_wait( sem_t * sem );
- 原型：int sem_trywait( sem_t * sem );
- 原型：int sem_timewait( sem_t * sem, const struct
timespec * abs_timeout );
- 说明： sem_wait()在无法操作时阻塞， sem_trywait()则立
即返回，sem_timewait()与sem_wait()类似，但有时间限制，过了时间期限它就返回了

发布信号量：V操作

- 原型：int sem_post( sem_t * sem );

销毁信号量

- 原型：int sem_destroy( sem_t * sem );

#### 条件变量

条件变量的功能与目的
- 互斥用于同步线程对共享数据对象的访问
- 条件变量用于在线程间同步共享数据对象的值

初始化条件变量
- 原型：int pthread_cond_init( pthread_cond_t * cond, 
const pthread_condattr_t * cond_attr );
- 可使用宏PTHREAD_COND_INITIALIZER代替

销毁条件变量

- 原型：int pthread_cond_destroy( pthread_cond_t * cond );

广播条件变量
- 原型：int pthread_cond_broadcast( pthread_cond_t * cond );
- **以广播方式唤醒所有等待目标条件变量的线程**

（你也可以只唤醒一个）唤醒条件变量

- 原型：int pthread_cond_signal( pthread_cond_t * cond );

等待条件变量
- 原型：int pthread_cond_wait( pthread_cond_t * cond, 
pthread_mutex_t * mutex );
- 参数：这样的条件会被很多线程所共享，所以必须使用互斥来对这个条件变量进行保护，以确保函数操作的原子性

### 4.C+11线程库

先省略，以后需要再学吧

## 十五.网络编程

### 1.Internet网络协议

#### TCP/IP协议

- Internet主流协议族 
- 分层、多协议的通信体系

它把整个网络实际上分成了四层

数据链路层
- 它描述了网卡接口的网络驱动程序，和数据在物理媒介上的传输的特征；不同的物理网络具有不同的电气特性，网络驱动程序本身这些实现细节对于不同的网络架构来讲肯定是不一样的，所以我们在设计数据链路层的时候通过隐藏实现细节就可以为上层协议提供一致的接口
- 数据链路层常用协议：地址解析协议（ARP）和反向地址
解析协议（R（reverse）ARP），实现IP地址与机器物理地址（通常为MAC地址）之间的相互转换

网络层

- 实现数据包的路由和转发
- 常用协议：IP、ICMP
  - IP协议：**逐跳发送模式**；根据数据包的目的地IP地址决定
  数据如何发送；如果能直接发给它那就发给它，如果数据包不能直接发送至目的地，IP协议负责寻找一个合适的下一跳路由器，并将数据包交付给该路由器转发(寻找一个中间人帮它转发，中间有一个转发就称它为产生一次额外的一跳，那个转发者如果发现能够直接发送到目的地，它就直接发送，如果不行，它还得找下一个转发者，所有的数据传输都是按照这个模式去做的，那么它就是IP协议)
  - ICMP协议：因特网控制报文协议，主要用于检测网络连接

传输层
- **为两台主机的应用程序提供端到端通信**
- 传输层使用的主要协议：TCP、UDP

- TCP（Transmission Control Protocol）：传输控制协议，为应用层提供可靠的、面向连接的、基于流的可靠服务；使用超时重发、数据确认等方式确保数据被正确发送至目的地

- UDP（User Datagram Protocol）：用户数据报协议，它也是为应用层提供一个基于流的服务，但是它提供的服务是不可靠的、无连接的、简单的基于数据报的服务；不保证数据能正确发送到目的地

如果是一个可靠的服务，那么你需要额外的控制和管理就多一些，不可靠的就少一点，它不可靠，所以效率就会高一些

正是因为TCP协议和IP协议在因特网协议中占了最主要的地位，所以我们才把因特网用到的这个协议统称TCP/IP协议

应用层
- 应用程序逻辑实现
- 常用协议：ping、telnet、DNS、HTTP、FTP、DHCP等

#### HTTP协议

它仅仅是TCP/IP协议我们整个因特网上最顶层应用层协议中的一种

超文本传输协议：应用层协议

主要特点
- 支持客户/服务器模式
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径；请求方法常用GET、HEAD、POST等，每种方法规定了客户与服务器联系的不同类型；HTTP协议简单，实现起来它的服务器程序规模小，通信速度较快 
- 灵活：HTTP允许传输任意类型的数据对象；正在传输的类
型由Content-Type加以标记

- 无连接：无连接是指每次连接只处理一个请求；服务器处理完客户请求，并收到客户应答后，即断开连接，节省传输时间（下次你再想连接继续重新地新造一个连接，这个连接在客户请求的时候才会发生，此外的时间它是不存在的，所以它叫无连接的）
- 无状态：无状态是指协议对于事务处理过程、它的历史没有记忆能力；没有包袱啊，所以应答较快，但是每次传输的时候数据量较大，因为它不知道你之前要了什么东西，每次都跟新的连接一样，当然传输的数据量就会大一点

所有的HTTP资源都使用HTTP URL的方式去定位网络资源，也就是通过这个网址来定位对应的网络资源

- ```c++
  http://host[:port][abs_path]
  // 协议、主机、端口、绝对路径
  ```

HTTP请求
- 由三部分组成：请求行、消息报头、请求正文
- 格式：Method Request-URI HTTP-Version CRLF
- Method：请求方法，GET、POST等 
- Request-URI：统一资源标识符
- HTTP-Version：请求的HTTP协议版本
- CRLF：回车换行

HTTP响应
- 由三部分组成：状态行、消息报头、响应正文
- 状态行格式：HTTP-Version Status-Code ReasonPhrase CRLF
- HTTP-Version：服务器HTTP协议版本
- Status-Code：服务器返回的响应状态码 - Reason-Phrase：状态码的文本描述

你必须按照这个模式去构造，因为你返回的是字节流、是字符串啊

HTTP状态码
- 状态代码有三位数字组成，首数字定义响应类别
  - 1xx：指示信息，表示请求已接收，继续处理；2xx：成功；3xx：重定向，**要完成请求必须进行更进一步的操作**；4xx：客户端错误，请求有语法错误或请求无法实现；5xx：服务器端错误，服务器未能实现合法的请求

- 常见状态代码
- 200：OK，请求成功；
- 400：Bad Request，请求有语法错误，不能被服务器所理解；401：Unauthorized，请求未经授权；403：Forbidden，服务器收到请求，但是拒绝提供服务；404：Not Found，请求资源不存在；
- 500：Internal Server Error，服务器发生不可预期的错误；503：Server Unavailable，服务器不能处理客户请求

### 2.套接字

#### 套接字的基本概念

通信类型：控制套接字如何传输和处理数据，数据以包的形式传输

- 连接（connection）类型：确保所有包依序传输，如果丢包，则请求重传
- 数据报（datagram）类型：不保证包的到达顺序，包可能丢失

套接字的属性呢还有一个对应的名空间

名空间：指定套接字地址格式

- 如果使用的是本地名空间：那么套接字地址可能就是一个本地的普通文件名
- 如果使用Internet名空间：套接字实际上就是对应着Internet地址和端口号（用于区分一台主机上的多个套接字）确定

套接字它是以一个一致的方式处理你的本地套接字和网络套接字的通讯的。自己的一台计算机，两个进程之间，可以使用套接字进行通讯，本机通过Internet连接的另外一台计算机之间也可以使用套接字来通讯，只是对于本地的套接字来说，我们使用本地的普通文件名来标识它，两个进程就可以互相访问了；如果这两个进程是通过Internet通讯的，那么你就只能通过Internet名空间访问它，也就是说你要标定这两台计算机它们在因特网上的地址，整个套接字的地址就必须以网络模式进行标识，有地址有端口号。

（套接字的通讯的）协议：确定数据如何传输，大部分情况下，我们是不关心这个协议的，因为机器会自动地替我们选择一个它认为最佳的协议模式

#### 套接字函数：“sys/socket.h”

我们怎么调用这些函数来实现我们进程间的通讯的模式

socket()函数：创建套接字
- 原型：int socket( int domain, int type, int protocol );
- 参数：名空间、通信类型和协议
- 名空间：PF_LOCAL（本地）或PF_INET（Internet） 
- 通信类型：SOCK_STREAM（流的模式连接类型）或SOCK_DGRAM（数据报类型） 
- 协议：传递0，让系统自动选择协议（通常为最佳协议） 
- 返回值：套接字描述符

close()函数：释放套接字

- 原型：int close( int fd );

connect()函数：创建两个套接字之间的连接（两个套接字要连接，要不然怎么叫套接呢，就像两个管子把它套在一块拧紧，它两个套接字数据不就可以流了嘛）
- 客户发起此系统调用，试图与服务器建立套接字连接
- 原型：int connect( int sockfd, const struct sockaddr * 
addr, socklen_t addrlen );
- 参数： sockfd为套接字文件描述符； addr为指向套接字地
址结构体的指针（服务器地址）； addrlen为服务器地址字
符串的长度
- 返回值：0表示连接成功，-1表示连接失败

在创建连接成功之后，你就可以调用send()这个函数发送这个数据

```c++
send()函数：发送数据
- 原型：ssize_t send( int sockfd, const void * buf, size_t len, int flags );
- 原型：ssize_t sendto( int sockfd, const void * buf, 
size_t len, int flags, const struct sockaddr * dest_addr, socklen_t addrlen );
- 原型：ssize_t sendmsg( int sockfd, const struct msghdr* msg, int flags );
//只有在套接字处于连接状态时才可调用
```

```c++
bind()函数：绑定服务器套接字与其地址
- 原型：int bind( int sockfd, const struct sockaddr * addr, socklen_t addrlen );
// 你构造一个套接字然后你要把这个套接字和这个服务器那个地址给绑定起来
```

```c++
listen()函数：侦听客户连接
- 原型：int listen( int sockfd, int backlog );
- 参数：backlog指定有多少个挂起连接可以进入队列，外卖都服务器最多可以侦听多少个连接，同时处理多少个，超出该值的连接将被抛弃
```

```c++
// 侦听到客户连接之后，服务器就可以调用accept()这个函数接受客户的连接
accept()函数：接受连接，为该连接创建一个新的套接字，和这个客户构造一个新的连接，就把它拧紧，就像两个管子一样把它拧上
- 原型：int accept( int sockfd, struct sockaddr * addr, 
socklen_t * addrlen );
- 参数：addr为指向套接字地址结构体（客户地址）的指针
- 返回值：创建一个新的套接字，以接受客户连接，返回值为新的套接字文件描述符
- 原先套接字文件描述符可以继续接受新连接（下一个客户的连接）
```

#### 本地套接字

```c++
// 服务器端
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
// 持续读取消息，直到套接字关闭或接收到客户发送的“quit”消息
// 前者返回true，后者返回false，服务器随后将停止服务
bool Serve( int client_socket ) {
 while( true )
 {
 int length;
 char * msg;
 // 从套接字中读取文本消息的长度，返回值为0表示客户连接已关闭
 if( read( client_socket, &length, sizeof(length) ) == 0 )
 	return true;
 msg = new char[length];
 read( client_socket, msg, length );
 std::cout << msg << std::endl;
 if( !strcmp( msg, "quit" ) ) 
 { 
  delete[] msg, msg = NULL; 
  return false; }
 else delete[] msg, msg = NULL;
 } 
}
int main( int argc, char * const argv[] )
{
 const char * const socket_name = argv[1];
 int socket_fd;
 struct sockaddr_un name;
 bool serving = true;
 // 创建套接字
 socket_fd = socket( PF_LOCAL, SOCK_STREAM, 0 );
 // 设定服务器性质
 name.sun_family = AF_LOCAL;
 strcpy( name.sun_path, socket_name );
 // 绑定套接字
 bind( socket_fd, (struct sockaddr *)&name, SUN_LEN( &name ) );
 // 侦听客户连接
 listen( socket_fd, 5 );
 // 重复接受连接，直到某个客户发出“quit”消息
 while( serving )
 {
 struct sockaddr_un client_name;
 socklen_t client_name_len;
 int client_socket_fd;
 // 接受客户连接请求
 client_socket_fd = accept( socket_fd,
 (struct sockaddr *)&client_name, &client_name_len );
 serving = Serve( client_socket_fd ); // 服务连接请求
 close( client_socket_fd ); // 关闭客户连接
 }
 close( socket_fd );
 unlink( socket_name ); // 删除套接字文件
 return 0;
}
```

```c++
// 客户端
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
void SendMsg( int socket_fd, const char * msg )
{
 int length = strlen( msg ) + 1;
 write( socket_fd, &length, sizeof( length ) );
 write( socket_fd, msg, length );
}
int main( int argc, char * const argv[] )
{
 const char * const socket_name = argv[1];
 const char * const msg = argv[2];
 int socket_fd;
 struct sockaddr_un name;
 // 创建套接字
 socket_fd = socket( PF_LOCAL, SOCK_STREAM, 0 );
 // 在套接字地址中存储服务器名称
 name.sun_family = AF_LOCAL;
 strcpy( name.sun_path, socket_name );
 // 连接
 connect( socket_fd, (struct sockaddr *)&name, SUN_LEN( &name ) );
 // 发送消息
 SendMsg( socket_fd, msg );
 close( socket_fd );
 return 0;
}
```

程序测试运行
- 编译链接服务器端程序和客户端程序(形成两个可执行文件)
- 进入服务器端程序目录，在终端中输入：./server 
/tmp/socket（启动套接字的服务器）；./server为服务器端程序名，/tmp/socket为本服务器启动后的套接字文件名（服务器和客户端就会通过这个文件通讯）
- 进入客户端程序目录，在新终端中输入：./client 
/tmp/socket "Hello World!"；./client为客户端程序名
- 停止服务器，在客户端输入命令：./client /tmp/socket "quit"

#### 网络套接字

网络套接字和本地套接字理论上来讲实现上几乎没有差别，它就是那个属性设置的问题，剩下的基本上没有差别，只不过因为我们网络上数据的传输大部分的时候我们要生成HTML文档，那个时候生成HTML文档或解析HTML文档会比较麻烦一点，除此之外和本地套接字的实现基本上差不多，步骤是非常非常类似的。

```c++
// 客户端
#include <stdlib.h>
#include <stdio.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <string.h>
// 请求Web服务器的主页
void GetHomepage( int socket_fd ) {
 char buffer[8192];
 sprintf( buffer, "GET /\n" );// 把这个命令发到web服务器上
 write( socket_fd, buffer, strlen( buffer ) );// 向套接字里写入请求
 while( true ) {
 ssize_t count = read( socket_fd, buffer, 8192 );
 if( count == 0 ) return;
 fwrite( buffer, sizeof( char ), count, stdout );
 } 
}
int main( int argc, char * const argv[] )
{
 int socket_fd;
 struct sockaddr_in name;
 struct hostent * hostinfo;
 socket_fd = socket( PF_INET, SOCK_STREAM, 0 );
 name.sin_family = AF_INET;
 hostinfo = gethostbyname( argv[1] );
 if( hostinfo == NULL ) return 1;
 else name.sin_addr = *( (struct in_addr *)hostinfo->h_addr );
 name.sin_port = htons( 80 );
 if( connect( socket_fd, (struct sockaddr *)&name,
 sizeof(struct sockaddr_in) ) == -1 ) 
 {
 perror( "Failure to connect the server." );
 return 2;
 }
 GetHomepage( socket_fd );
 return 0;
}
```

服务器端自己去实现！