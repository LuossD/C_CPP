# 

---记录老师展开讲的内容，附加网上看的一些

## 小知识

### 1.endl与"\n"

cout << endl
相当于cout << "\n" + flush
回车同时刷新了缓冲区
所谓刷新缓冲区的意思如下
很简单的一个例子:

```c
代码1，输出123之后才会出现暂停提示
cout << "123"<<endl;//有endl
system("pause");
代码2，出现暂停提示之后才会输出123
cout << "123";//无endl
system("pause");
```

cout << '\n' 只是单纯换行，没有清除缓冲
cout<<endl 换行又清除缓冲
如果你的 程序都是cout << '\n' 结束，缓冲区就会满满的，相当于内存泄漏；

cout是输出流，用cout<<endl 能够将流中的内容全部输出，而cout<<"\n"不一定。在c++中建议用cout<<endl。

### 2.cin

cin是忽略换行和空白符的
但是你可以用cin.get(ch)就可以把'\n'赋给ch

```c
char ch;
cin.get(ch);
```

cin在键盘输入后按回车才会继续执行。

### 3.C++中单引号与双引号的区别

C＋＋中单引号、双引号的区别为：**表示类型不同、数据长度不同、尾部不同**。

1）表示类型不同

> 单引号：单引号的表示类型为字符类型。
>
> 双引号：双引号的表示类型为字符串类型。

2）数据长度不同

> 单引号：单引号的数据长度固定，因为只有一个字符，所以数据长度为1。
>
> 双引号：双引号的数据长度不固定，由字符串的字符数量决定。

3）尾部不同

> 单引号：单引号只有一个字符，不会在字符尾部添加＇＼0＇结尾。
>
> 双引号：系统会将双引号里的字符串内容的尾部自动添加＇＼0＇结尾。

> "a"和'a'的区别，前者是字符串，后者是字符。
> 实际上，"a"在内存中一般占2个字节（不是说字符串长度，是占用内存。注意说是一般占2字节，有特殊情况），"a\0"，以'\0'结尾。而'a'是一个单字符。
> **当然字符串可以是"abcde"这样的，'abcde'这样就是错误的。**

> 在C++中sizeof('a')=1,它是占一个字节，sizeof("a")=2，它后面还有一个\0结束符；而在C语言中，sizeof('a')=4（字符在C语言中是用int型数据存储的）

### 4.cout怎么控制输出的小数点位数

基本格式为cout << fixed << setprecision(N) <<X<< endl;
X为待打印的数，N为期望输出的小数点后的位数；
setprecision包含在iomanip头文件下；

**补充：**cout的默认精度是6，所以运行此代码：
cout << 12.3456789 << endl; 的结果是12.3457；
setprecision(n)指的是精度为n(不是小数点后的)
如，运行cout<<setprecision(5)<<12.3456789<<endl;的结果是12.345；
精确到小数点后n位就需要加上fixed,其意义上制定小数点后
如：cout << fixed << setprecision(2) << 3.1415 << endl;就是指精确到小数点后两位。

### 4.C 中的左值（Lvalues）和右值（Rvalues）

C 中有两种类型的表达式：

左值（lvalue）：**指向内存位置的表达式被称为左值**（lvalue）表达式。左值可以出现在赋值号的左边或右边。

右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。

### 5.初始化局部变量和全局变量

当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化。正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。

**初始化不是赋值**，初始化的含义是创建变量赋予其一个初始值，而赋值的含义是把当前值擦除，而以一个新值来替代。

### 6.c++中派生类和基类是要放在同一个头文件里吗?

可以一起可以不一起；
但是派生类的定义的时候是必须先定义了基类的；
即如果不在同一个文件中，派生类所在文件必须包含基类的定义的头文件。

### 7.派生类定义复制构造函数怎么传、传什么初始化参数给它的基类们？

若派生类定义复制构造函数，一般都要为基类的复制构造函数传递参数，但是复制构造函数的形参表里只能有一个参数，那么这个问题怎么解决呢？解决的关键就是：已有的派生类的对象的引用，可以作为实参，传给任意一个基类的复制构造函数。例如如下的派生类的复制构造函数的实现：

```c++
C::C(const C &c1): B(c1),D(c1),...{...};
//其中C是派生类，B、D等等是其基类，c1是已有的派生类的对象。
//拷贝构造函数中提到参数必须为本类的一个常对象，而派生类属于基类，所以派生类的一个常对象可以作为基类的拷贝构造函数的参数，个人理解
```

### 8.函数名是地址么？

我们经常把函数名当地址用，可实际上他不是地址，但是你可以把他理解成地址，心里清楚他不是就行。

对于test和&test你应该这样理解，test是函数的首地址，它的类型是void ()，&test表示一个指向函数test这个对象的地址， 它的类型是void (*)()；因此test和&test所代表的地址值是一样的，但类型不一样。test是一个函数，&test表达式的值是一个指针！ 

网上看的不知道对不对

### 9.c++中类对象不能访问类的私有成员变量

原则上，C++类中私有变量不允许在类之外的其他任何地方访问。

- 类的成员函数可以访问类这三类（public、protected、private）
- 继承类成员函数可以访问 protect 类型
- 只有本身类的成员函数才可以访问 private 类型
- 类的对象若在其他函数中是不可以访问类的 protect private类型变量

如果你确实需要调用某个private的变量，你可以定义一个public的函数来返回这个变量，比如：

```c++
class D
{
private：
	int a；
public：
	int Getint（）{return a;}
......
}
这里你的对象不能调用a的，
也就是不能
int b；
D d；//假设已经写好了构造函数
b=d.a;//这是错误的，
但是你可以
b=d.Getint();
这样就可以把a的值给b了。
所有的public的函数都可以通过
<对象>.<函数名>的方式来调用
```



## 写程序出现的问题

### 1.warning: control reaches end of non-void function

> 别人的博客：
>
> 用gcc编译一个程序的时候出现这样的警告：
>
> warning: control reaches end of non-void function
>
> 它的意思是：控制到达非void函数的结尾。就是说你的一些本应带有返回值的函数到达结尾后可能并没有返回任何值。这时候，最好检查一下是否每个控制流都会有返回值。

### 2.no space left on device

​		原因是磁盘空间满了，经查看c盘确实没一点空间了。

### 3.error: 'constexpr' needed for in-class initialization of static data member 'const double Example::scd' of non-integral type [-fpermissive]

​		const static 和 static const一样，都不能在类内直接初始化非整形常量，可以修饰int，bool，char，但不能修饰其他类型（如double，float）

​		在c++11中，可以使用 constexpr static 或者 static constexpr 来修饰 非整形静态成员常量。

```c++
static const double scd = 1.01;
改为如下：
static constexpr double scd = 1.01;
或者 constexpr static  double scd = 1.01;
```

### 4.error: cast from 'void*' to 'int' loses precision [-fpermissive]

​		学习linux多线程时看别人的示例代码直接将void * 转化为int，在自己的程序中也这样写可是提示错误。

​		在32位系统中int为4字节，地址也为4字节，所以可以直接转换，不会损失精度。但是在64位系统中，int依旧为4字节，但是地址已经变为64位了，所以直接转换会损失精度。

​		解决办法:

（1）这时就**可以使用intptr_t来进行转换**，因为intptr_t就是为了跨平台而存在的，总是所在平台的位数，不会损失精度。
（2）另一种方法是使用unsigned long 来进行转换，因为unsigned long 在32位平台是4字节，在64位平台占用8字节，与地址占用字节数相同也不会损失精度，所以也可以。（**而我的编译器实际测试long为4字节，所以这个时候有另一个办法，使用__int64 来定义变量，这样就是64位了**）

## 疑惑的地方

1.为啥void * 可以直接存放int类型数据？

​		首先可以通过void * 查看编译器的位数，如下：

```c++
在程序中返回sizeof(void*)  的值（通过指针地址来判断，也可以使用long类型），返回的结果是操作系统的字节数。若返回4则是32位操作系统，返回8即是64位。
```



2.缺省的构造函数里面没有代码是如何分配内存的？缺省的析构函数里面没有代码是如何销毁对象的？

3.浅拷贝老师说的是一个字节一个字节拷贝过去为啥是只拷贝了指针？

​		一个字节一个字节拷贝的是指针的那四个字节

4.拷贝就是赋值么？对象没有定义只是声明所以它没有分配内存空间所以就不能拷贝？

​		在谭浩强《C++面向对象程序设计》2.2节里有说“类是抽象的，不占内存空间，而对象是具体的，占用存储空间”。所以类只声明是不分配空间的；而sizeof()这个函数只是计算数据类型所占空间大小，不存在实例化，但存在对内部类型大小计算，sizeof是一个操作符（operator），其作用是返回一个对象或类型所占的内存字节数，sizeof对对象求内存大小，最终都是转换为对对象的数据类型进行求值。拷贝的前提是对象已经存在了。

5.delete如果销毁的不是指向类对象的指针只是个普通数据成员，它会调用类析构函数么？

​		不会。其实一句话可以回答，类才有析构函数。

​		是否调用析构函数得看动态内存里面的对象是否是自定义类对象。如果是内置类型int ,char就不会涉及到析构函数；另外，delete有没有调用析构函数，就是看那个地方以前到底new的是什么东西。

```c++
如果
int* p = new int [10];
//。。。。。。
delete []p; 这里的delete就没有调用什么析构函数
如果
class A{
  int a;
//。。。。。
}
A* apple = new A;这里new A没有给定参数，其就调用了默认构造函数。。
//。。。。
delete apple;
这里调用了个析构函数
```

6.一个类可以赋值给另一个类么？

​		不能，类对象可以赋值给另一个类对象

## 一.C/C++基本语法元素

### 1.程序设计的基本概念

程序：一系列遵循一定规则并能正确完成待定功能的代码或指令序列

**通常包括数据结构与算法两部分**

------

算法：

描述问题的求解方法和步骤

不允许存在二义性（计算机是一个机械计算过程，逻辑非常机械）

算法设计过程是逐步求精的（不能指望写一个算法解决实际问题一步到位调试正确；逻辑错误比较难发现；先完成一个初步的算法，然后一步一步不断修正它改进升级它）

常使用流程图和伪代码描述算法（伪代码用的较多）

数据与数据结构：

数据：程序操作的对象

数据结构：数据对象之间的**相互关系及构造方法**

数据结构与算法关系密切，良好的数据结构可使算法更简单，恰当的算法可使数据结构更易理解

> 对象：行动和思考的目标；
>
> 对象之间的关系如若不构建出来你的程序数据对象就是零散的，就不能深刻的表达我们现实世界中的这种联系，事物是普遍联系的；
>
> 一个数据结构应该有一个和它相配套的算法，一个算法应该有一个和它相适应的数据结构，两者是一种紧密联系的关系，不能单纯的割裂这二者，而且在某些情况下还会互相转化。

很多很有经验的程序员也是按照这个方式来做，老师把这个思维模式叫做数据中心主义；

这是很多学习者一开始不自觉的思维习惯，不太容易纠正过来；

好处：解决某个问题我怎么用数据来表达它，这个目标是清晰的；

坏处：当我这个问题没想清楚时，这个数据的表达可能是不恰当的；当我在一个不恰当的地基上写算法时，最终发现这个数据表达是错误的，那么所写的算法基本上是没用的，程序越大越复杂这个问题越严重。

所以最后才把它变为称之为算法中心主义的一个东西。

怎么做程序设计：

涉及三种形态的程序设计

- 结构化程序设计

- 面向对象程序设计

  **对象：行为与属性的集合**

  类与对象、对象构造、继承与派生

- 范型编程

**结构化程序设计是早期从C那里继承过来的，必须会用！**（后两者中的代码实现还是结构化的）

面向对象程序设计做了一个很巧妙的改变：**把数据对象和这个对象的行为也就是算法合在一块，把它辩证统一**；

好处：现在行动和思考的目标是对象，没错，但是你不再是数据中心主义了，而是对象中心主义；行动和思考的目标不仅仅包括数据和数据结构，还包括了在这个数据和数据结构上面可以执行的操作，也就是它的行为，实际是完成了从数据中心主义向算法中心主义的一个转化，这点很重要！

为什么做这样的转变？

一个程序里面要么是数据结构要么是算法，不太容易变动的是算法，数据结构是易变的；**写程序首先应攻克那些不太容易变化的地方**，先把这个固定下来然后去攻克那些容易变动的地方。走极端肯定不对，我们要中庸，那就应该是对象中心主义，两者融合在一起，这就是面向对象程序设计的由来或者产生面向对象程序设计的根本原因，就是为了解决大程序开发时候原来的结构化程序设计解决不了的问题：程序太大，规模太大，控制不住！

### 2.简单C程序介绍

wins命令行中编译c程序：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190115211433592.png)

gcc 是编译命令，刚刚我们安装的，-g参数是表示编译时带上可调试记号，不然编译好的东西只能运行不能调试，-o 是表示指定输出文件，后面紧跟输出文件的名字，这一条指令就可以将c文件编译成一个可执行的二进制文件。

------

int main()

每一个C/C++程序都有一个主函数main()，名字固定，一个程序就这么一个，必须有一个，只能有一个。除非你写的不是程序，而是C或C++的库，这个不需要main！

#include <stdio.h>,printf函数原型位于"stdio.h"中，没有它就找不到该函数的入口，函数用的对不对也是参照header文件！

main()前面有个int，表示main函数完成后会带回一个结果，即函数的返回值，返回值是一个整数；0，1，2等等，返回值是给操作系统用的，正确执行即返回0，运行出错会有很多类型的错误，返回不同的值。

------

若想用C++的新格式包含stdio.h，就要写cstdio，后面的.h可以不要了。

早期的C++头文件为<iostream.h>，后改为<iostream>。

C++引入了一个很特殊的东西，成为（命）名空间---namespace，这个空间的名字叫std！C++标准库的名字都在标准名空间里。比如C++中，cout，endl等都在标准命名空间std里面；如果前面不写using namespace std;那么cout应该改为std::cout，endl改为std::endl；::成为名解析操作符。**std和别的名空间是分开的，这是一个非常重要的设计**，如果名字太多，在一个空间里，重名的话不太好解决。两个名空间里名字可以一样，通过名空间来解析他们。

**小结：**

程序执行由主函数开始，其他函数由主函数直接或间接调用；

程序执行流程与函数定义顺序无关；

每个函数包含函数头与函数体两部分；

C/C++包含大量库函数和算法，可直接使用。

### 3.程序设计的基本流程

包含如下几个过程：

1）编辑源代码

包括源文件和头文件，最后的输出结果就是源文件和头文件。源文件的名字就叫main.cpp，a.cpp等，后缀都为.cpp。编译器自动根据后缀来选择C++的编译还是C的编译；有些是这样做的，至于Linux下面看自己选择，使用gcc编译器还是g++编译器。头文件就是<stdio.h>或者没有.h的就是iostream。

2）编译、链接与测试

编译出来的就是目标文件，是二进制的代码。然后把这些二进制代码按照一个可执行文件的特定格式把它组装在一起，这个过程称为链接。生成可执行文件。

在此过程中我们需要使用到那些函数库里面抽取出来的那些二进制的目标代码，比如printf那样的函数目标代码它就会和我们的这个程序中的目标代码链接在一起形成我们的可执行文件。可执行文件运行，测试这个程序对不对。

------

Linux中可执行文件是放在固定的目录下面的，我们**当前目录往往不在可执行文件的那个搜索路径上**，所以要想执行当前目录下面的"a.out"文件，必须写"./a.out"。

> PATH 是环境变量，里面保存了执行文件路径（通常会包含多个路径，各路径之间以冒号“:”进行间隔）。**当执行一个可执行文件（命令）时，Linux 会优先到 PATH 环境变量中保存的路径下进行查找**。使用export $PATH命令可以查看环境变量的内容。
>
> 二、“.”表示当前目录，Windows/Dos 的默认搜索路径（即 PATH 环境变量）里有当前目录，所以不需要加。其实加上也是一样的效果。因为 Linux 的默认搜索目录里没有当前目录，所以如果你在当前目录需要执行程序就要加上路径。
>
> 三、理论上，如果要让当前目录下的文件不需添加“./”即可运行，只需将“./”加入路径参数PATH中即可，如下所示：
>
> export PATH=$PATH:./
>
> 但通常不建议这样做，这是基于安全性的考虑。若系统管理者所在的目录中有可运行文件，而该文件有问题时，被执行后会发生不可预测的问题。
>
> 例如：任何用户对 /tmp 都有 w 的权限，若某用户在 /tmp 之下新增 ls 这文件，而文件内容如下：
>
> ```
> /usr/sbin/useradd -m adm0
> /bin/ls
> ```
>
> 同时，将 PATH 的路径设为`export PATH=./:$PATH`，则当 root 进入 /tmp 并执行 ls 时，就会优先执行 /tmp/ls，而非系统默认的 /bin/ls，这样不知不觉中新增了一个用户 adm0。因此即使要将当前目录加入路径参数中，`export PATH=$PATH:./`的安全性也将优于`export PATH=./:$PATH`。

如果不想使用默认的可执行文件名"a.out"，使用g++ main.cpp -o hello；-o hello 写在main.cpp前面也可以。

### 4.基本语法元素

#### 数据类型

整数类型

整数的符号：确定是否表示负数

signed、unsigned；

定义b为无符号整数：unsigned int b；

整数的长短：确定整数取值范围的大小

long、short；

定义c为短整数：short int c

> 有时候我们需要的整数不需要表达那么宽，现在很多主流的计算机都是64位的CPU，宽度都是64位宽的；
>
> 但是现在我们使用的很多主流的编译器实际上都是32位的，包括我们用的一些应用程序还仍然保留在32位，因为对一个正常普通应用来讲32位程序是够用的；所以迁徙到64位相对于它的难度来讲大家的兴趣不大；现在主流的C++编译器仍然是32位的，int基本上都是32位的，能表达从-21亿到+21亿的数据范围，如果是unsigned的类型，可表达从0-42亿的数据范围。
>
> 有时候不需要这么大数字，这时候我们可以把这个整数再弄短一点，前面加一个short就短了；短多少看编译器，有16位的有8位的；在主流的编译器下面long int 就是int。

浮点数类型：使用double或float表示小数；首选double，精度更高。平时尽量不要用float，因为float的有效位数只有六位和七位。

#### 量与表达式

**表达式**定义：

操作数与操作符序列，表达运算过程。

**变量**

**文字与常量**：

整数类型文字：8进制很少用，16进制倒是蛮常用的。

常量的定义：程序执行期间其值不可改变的量。

**格式：const  数据类型  常量名称 = 初始值**

这里的=既不是赋值也不是等号，而是初始化符号。

常量的意义：解决直接出现的文字无法解释其意义的问题。比如孤零零的出现一个3.14，你说这个3.14是个什么？谁告诉你一定是圆周率了。const double pi = 3.14。

> # C++ 常量
>
> 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。
>
> 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
>
> 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。
>
> 在 C++ 中，有两种简单的定义常量的方式：
>
> - 使用 **#define** 预处理器。
> - 使用 **const** 关键字。

**赋值与初始化**：

变量的初始化只能做一次，而赋值可以随便做。

**操作符与操作数**：

操作符的优先级很复杂，分成了10多级，搞不清楚时就加括号，编译器会自动将不需要的括号去除。

**基本输入输出**：

输出（插入）操作符：<<

输入（提取）操作符：>>

cin >> a >> b；一般不要这么写，因为没有提示信息，用户不知道输入啥

### 5.程序设计风格

**注释**

同一种注释标记不可以嵌套

**命名规范**

字符集：ASCII字符集

标识符：区分大小写；

**不能以数字开头**：如果允许变量名开头是数字，则无法区分变量名和数字类型，例如：如果变量名 091合法，则程序无法区分这个变量和数字 091。另外，有些数字可能含有字母，如浮点数 1E10。程序设计语言不能存在歧义，因此，需要约定变量名开头不能是数字，以便区分变量与数字。

**宏与常量**

宏定义：

#define 指令：预处理命令

#define后面跟着两个部分：宏的名字及后面跟着的一大串（即宏想要对应的那个文本），注意它实际上是个文本，简单的文本替换，**后面不需要分号，如果有分号，分号就是替换文本的一部分了！**

例如：#define PI 3.14

一旦定义，可以替代常量使用；宏定义不是常量；程序中应优先使用常量而不是宏。

在编译的时候查找PI，然后全用后面的文本替换，替换完一遍才开始编译；有了const关键字后可以定义常量后我们很少再使用宏来定义像这样的宏文字。

**赋值语句的简写形式**

除赋：x / a

注意：到底是在整数上做操作还是浮点数上，是不一样的；对于操作数都为整数的，结果也是整数，舍去小数部分，比如 9 / 2结果是4而不是4.5；9.0 / 2 结果是4.5；除数与被除数有一个是double或float，结果就是相应的类型。

特别说明：x * = a +b 等价于x = x * (a+b)

**源代码的排版**

函数代码不超过60行，如果太长可拆成两三个函数，这样别人阅读和维护起来就更方便了；

标识符的命名规范应该是一致的；

**除非特别必要，否则不要在一行上书写多条语句。**

## 二.程序控制结构

### 1.结构化程序设计基础

**三种基本控制结构：**

顺序结构

分支结构：

有时候真分支这一路是存在的，假分支这一路，我们什么都不需要做时，那假分支可以省略；

循环结构

程序中常见的控制结构是分支和循环，当然架构整个程序本身的那个结构一定是顺序的；从数学角度上将，它实际上是一种时间严格偏序。

任何复杂结构都可以使用这三种控制结构来完成。

**复杂控制结构：**

控制结构可以嵌套，以构成更复杂的控制结构

### 2.布尔数据

只有真或假两种可能的数据量

#### 枚举类型

即一一列举，编程中有些很特殊的量，这些量的取值范围极其有限，比如自然月份。

月份就12个，如果你使用int来表达它，那实际上它可以取任何一个整数值，问题是如果你映射，1代表1月，2代表2月，12代表12月，那13代表啥？0代表啥？-1代表啥？就有一些量你用不到；但是你在程序中又不能限制它把13赋值给这样一个整型量，也即你不能限制它只能得到有效的月份，所以这种情况建议应该使用一个枚举型。

类型声明：

格式：enum 枚举名 {元素1，元素2，...，元素n}；

例：enum MONTH{JAN, FEB, ...}

枚举类型声明中的元素为枚举文字，不是变量。枚举值是常量不是变量，不能在程序中再为枚举元素赋值。

```c
enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};*

这句话有两个作用：
第一：声明enumType为新的数据类型，称为**枚举**(enumeration);
第二：声明Monday、Tuesday等为符号常量，通常称之为枚举量，其值默认分别为0-6。
接着利用新的枚举类型enumType声明这种类型的变量：enumType Weekday'就像使用基本变量类型int声明变量一样，如 int a;也可以在定义枚举类型时定义枚举变量enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;
但如果使用tpyedef enum {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;则表示将weekday定义为枚举类型不是变量。
```

**计算机怎么存储这个枚举数据对象呢？**

有个很特别的规则：内部把它映射为一个整数，最顶头的文字映射为0，往后依次加一；也可以更改默认的映射，将{JAN = 1，FEB，...}，这样月份从一开始映射。

枚举类型变量的定义：

例如：MONTH month；

然后这个month变量就可以赋值了，比如赋值为JAN等，但是不能赋值为数值，数值是int类型，而month是enum MONTH类型；两者类型不匹配。那么能不能将**枚举量**赋给**非枚举变量**呢？如：int a=Monday;这是允许的，因为**枚举量**是符号常量，这里的赋值编译器会自动把**枚举量**转换为int类型。

注意：枚举型不能直接输出，直接输出最终会转化为整数去输出。

> 也可以在定义枚举类型时定义枚举变量enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;
>
> 然而与基本变量类型不同的地方是，**在不进行强制转换的前提下**，只能将定义的**枚举量**赋值给该种枚举的变量，如：*Weekday = Monday;*或者Weekday = Sunday;不能将其他值赋给**枚举变量**，如：Weekday = 10;这是不允许的，因为10不是**枚举量**。也就是说Weekday只能是定义的Monday-Sunday这些定义过的**枚举量**。然而这不是绝对的，下面会讲到利用强制类型转换将其他类型值赋给**枚举变量**。
>
> 枚举型可以隐式的转换为int型
>
> ```c
> enum Suit{Diamonds,Hearts,Clubs}a;
> a = Diamonds;
> int n = 100;
> n = a;
> ```
>
> 也可以强制转换（int）date;(int)a，是类型强转化。

**enum的其他用法：**

在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量，言下之意就是可以**通过强制转换将其他类型值赋给枚举变量**：

*Weekday = enumType(2);*等同于：Weekday = Wednesday;但是，如果试图将一个超出枚举取值范围的值通过强制转换赋给枚举变量，会出现什么结果？

*Weekday = enumType(20);*结果将是不确定的，这么做不会出错，但得不到想要的结果。

**对于枚举，只定义了赋值运算符，没有为枚举定义算术运算。**

不能对枚举量进行算术运算，那么枚举量能不能参与其他类型变量的运算呢？int a;a = 1 + Monday;这是允许的，因为编译器会自动把枚举量转换为int类型。

```C++
也可以只显式的定义一部分枚举量的值：

enum enumType {Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday};这样Monday、Wednesday均被定义为1，则Tuesday=2，Thursday、Friday、Saturday、Sunday的值默认分别为2、3、4、5.总结：未被初始化的枚举值的值默认将比其前面的枚举值大1。
    
这还说明另外一个现象，就是枚举量的值可以相同。
```

**enum(枚举)可以没有枚举名**

如果声明枚举类型时没有指定枚举名，其作用就和#define类似，比如以下代码：

```C
enum {
    STATION_IDLE = 0,
    STATION_CONNECTING,
    STATION_WRONG_PASSWORD,
    STATION_NO_AP_FOUND,
    STATION_CONNECT_FAIL,
    STATION_GOT_IP
};
```

这里声明了一个枚举类型确没有指定其枚举名，那么它就相当于用#define定义了六个名称和其对应的值，从0开始赋值每次加1，相当于：

```c
#define     STATION_IDLE = 0;
#define     STATION_CONNECTING = 1;
#define     STATION_WRONG_PASSWORD = 2;
#define     STATION_NO_AP_FOUND = 3;
#define     STATION_CONNECT_FAIL = 4;
#define     STATION_GOT_IP = 5;
```

只不过eunm类型表示的是一个确定的值，而这里#define了六个值，**可见如果要表示同一个事件的不同反馈status，使用这种没有枚举名的枚举效果更好**。

枚举类型的意义：

将多个文字组织在一起，表达从属于特定类型的性质；取代魔数，使源代码更易理解。

#### 用户自定义类型

自定义类型：

格式：typedef 原类型标识 新类型名；

例一：typedef int DWORD；

自定义类型的性质：

新类型与原类型相同，类型性质一模一样，并未产生新类型，重新命名的自定义类型使程序更易理解。

**bool类型：**

取值：false、true；

这个三个关键字是C++里面有的，在C里面是没有的；如果写C程序，不能使用这个布尔类型。

bool量的定义：

定义：bool modified；

赋值：modified = true；某个数据对象有更新的话，那modified就给它设为true，没有更新就设为false。这样就可以通过modified这个值来决定我们数据有没有更新，这样就把这个数据持久化，这是一个非常重要的概念。

#### 关系表达式

关系操作符：共6种

逻辑值（布尔值）

C 语言以0表示假，以非0表示真（经常以1表示）。

C++里尽量使用bool类型表示逻辑值。

但是有的时候我们要写的程序代码涉及到很多Linux操作系统的功能，它的很多系统代码实际上是早期的代码，都使用C来实现的。所以C的很多架构我们还离不开。

#### 逻辑表达式

逻辑运算符：逻辑与（&&）、逻辑或（||）、逻辑非（!）

关系操作符与逻辑操作符的优先级：

从高到低顺序：逻辑非"!"；"<"、">="、">"、"<="(同级)；"=="、"!="(同级)；"&&"；"||"。

#### 逻辑表达式的求值

给定年份year，判断是否为闰年：

year % 4 == 0 && year % 100 != 0 || year % 400 == 0

实际上能够被8000整除的年份就不是闰年，但是现在才2020年，8000年一轮回的那东西我们一时半会不用去考虑。

### 3.分支架构

**If分支架构**的三种格式：

格式1：if(条件表达式) {语句序列}

格式2：if else 

格式3：if else if else

如果{}里就一条语句{}可以省略。

PS:若仅用于确定某条语句是否执行，else分支可以省略。单独出现if可以，如果有else一定要有一个if配对，两个if一个else没有问题，问题在于else与哪个if配对？

C/C++的配对原则：离它最近：距离最短；同层次：排除底层嵌套。

**switch分支结构**：

switch(表达式){}

switch后面的表达式必须为整型、字符型或枚举型；总之它能和整数形成一一对应。

break语句的目的：

终止switch语句的执行；case子句中的**常数表达式**仅起到语句标号的作用，不是分支之间的分隔标记，也即**只起到什么时候进入这条switch语句的作用**，并不能起到离开这条switch语句的作用，想要离开必须加break，没有break是不能够工作的。

### 4.循环结构

发生无限循环的场合：

循环体内没有改变循环变量值的语句；

即使改变循环变量值，也不能否定循环条件；

循环体内没有能够强制终止循环执行的语句或命令。

**偶尔也需要用无限循环做一些特别的处理：**

```C
//有些程序除非用户产生一个特别的明确的要求，我要结束，否则的话循环就应该不断地做下去；这种循环架构使用无限循环更合适。
```

用户给出结束条件的时候我们再退出，这种东西我们称为哨兵。

哨兵：使循环满足终止条件的循环变量值。

**for循环**

递增递减表达式的优先级非常高。

注意：不要在复杂表达式中使用递增递减操作符，因为它有可能给我们带来错误的结果。

for循环与while循环其实等价，可以互换使用。

> while常用于不需要或很少需要初始化的场合
>
> for常用于需要简单初始化和通过递增递减运算控制循环体执行的场合
>
> for循环将所有循环控制因素都放在循环头部，循环结构最清晰

for循环的初始化表达式可以不写，如果for循环真的需要初始化表达式，那么在for循环前面得加上；

步进表达式也可以不写，如果真的需要步进，那么在循环体的最后要加上步进表达式；

条件表达式也可以不写，那就是无限循环，内部应该要加上哨兵。

## 三.函数

### 1.函数声明、调用与定义

**函数调用**：主调（客户）函数与被调（服务器）函数。

**函数调用过程中为了保证调用没有问题，必须要为每一个函数书写正确的函数原型**，表达这个函数的实现和调用格式的标准说明。**正常情况下它将充当函数的接口，所以它一般出现在头文件里。**

格式：函数返回值类型 函数名称（形式参数列表）；

**函数定义**：不仅可以使用标准库里边提供的一系列函数来实现程序，还可以自己定义一些函数；函数的定义需要使用编程语言来给出函数的执行步骤，它的每一条代码应该怎么写，怎么装配，这个过程就叫函数的定义。

1）函数没有返回值时，只需直接写return；即可。C/C++的编译器还告诉你：当这样的return语句在函数最结尾的时候，其实不写也没关系。

2）程序中可以写很多条return，但遇到第一条return程序就结束了；多条return语句的返回往往都是出现在这样的if-else-if所有的分支上。

**谓词函数**：

编写函数IsLeap，判断某个给定年份是否为闰年

```c
bool IsLeap(int year)
{
	return year % 4 == 0 && year % 100 !=0 || year % 400 == 0;
}
```

谓词函数最重要的一个用途是：可以充当条件表达式，比如if(IsLeap(year))。必须会用！

**函数重载**：

定义同名但参数不完全相同的函数就叫函数重载。

参数不完全相同：参数的个数可以不一样，参数的类型可以不一样，参数的顺序也可以不一样。

示例：比较数值、字符、布尔型的大小

```c
int Max(int x, int y);
char Max(char x, char y);
bool Max(bool x, bool y);
```

没有函数重载时这三个函数不能同名。有了重载就可以，同名的好处是：调用的时候，明确的知道调用的是Max，从功能上将求的就是两个数的大小，管它这两数是整型还是字符型还是布尔型呢，名字固定就是Max，这样可以避免搞混淆。

注意：把所有函数写在main函数前面不好，原因就是别人看你代码应该一眼就看到我们的主函数才对；如果他看到太多我们自己写的内部函数的话，他就看到太多细节，然后再去理解这个主函数的框架就不太容易。**所以从理解和维护的角度上讲，应该先写主函数！所有的函数都应该写在main函数后面**。问题来了：写在main后面函数能运行么，不能，所以需要把函数的原型写在main前面！

```c
//先整体后局部的逻辑进行思考，俗称自顶向下，逐步求精。
//如果一开始就特别关注细节，就会导致一个问题：一叶障目，不见森林
//先从战略高度然后再从战术角度来实现我们的代码
```

### 2.函数调用栈框架

初学者非常容易忽略的：就是在程序启动的最初，应该给出整个程序功能性的简单说明，应该给出提示信息让使用这个程序的程序员或者用户知道这个程序的基本功能。所以我们要把整个程序的功能代码抽取成一个又一个的函数。

值传递的机制：

- 形式参数在函数调用时才分配存储空间，并接受实际参数的值
- 实际参数可以为复杂的表达式，在函数调用前获得计算
- 形式参数与实际参数可以同名，也可以不同名
- 参数较多时，实际参数值逐一赋值，它们必须保持数目、类型、顺序一致
- 值的复制过程是单向不可逆的，函数内部对形式参数的修改不会反映到实际参数中去（就是个一次单向动作，就在函数调用的时候发生那么一次，拷贝完成后，形式参数和实际参数的关系就割裂了）

整数互换示例第二版：

**使用全局变量**：写在using naemspace std；后面，函数原型前面；int a, b。从变量的定义开始到这个文件的结尾，中间这些代码中所有的函数都能够使用这两个量a和b，将被后面所有的函数所共享。

这种解决方案不太好，并不是每个函数都需要用这两个全局变量，但是你能限制某个函数不用它们么？

> 全局变量不易于管理，不像局部变量，在函数调用结束后会自动释放
>
> 1 全局变量是很好；
> 2 但是有缺点：容易被修改错，尤其在工程很大的时候；
> 3 使用时一定要控制好全局变量的修改；
> 4 不过小工程小项目使用全局变量是很方便的！
>
> 全局变量可以被所有的函数访问，所以全局变量的值（正确的、安全的）可能会被其他的函数无意间修改。程序的行为依赖值的正确，**如果全局变量的值被无意或者恶意修改就会导致问题。所以，不推荐使用全局变量**。基于此，某些编程语言是不允许修改变量的值的。(一旦第一次赋值，就不能再修改变量的值了)。

如果你的全局变量过多，就有可能给程序的正确性带来威胁。

## 四.算法

### 1.算法概念与特征

算法定义：解决问题的方法与步骤

设计算法的目的：给出解决问题的逻辑描述，根据算法描述进行实际编程

算法特征：

- 有穷性：算法在每种情况下都可以在有限步后终止（步骤）
- 确定性：算法步骤的顺序和内容没有二义性
- 输入：算法有零个或多个输入
- 输出：算法至少具有一个输出（如果返回值是void的，它的输出体现在当事情做完以后，计算机内部的状态发生了变化，比如Swap函数交换了两个数，x和y两个形式参数的值发生了变化啊，这个就是输出，隐含着了，并没有在函数的返回值里体现出来）
- 有效性：所有操作具有明确含义，并能在有限时间内完成（有效性表示时间是有限的）

**注意：正确性不是算法的特征，算法的正确性需要数学证明**。不知道怎么证明那就测试，测试你的程序的正确的，这样才行。

示例：如果查找单词Abort，按照人的思维这个单词在字典的前几十页，所以不会一开始就去查中间位置，这个是人的智力**启发方式**，编程的时候除非你使用了启发式，否则这个事情是做不了的，它不像你的头脑中可以做到这件事。我们编程机械语言不是那么容易做到的，我们能做到的最快的就是折半（二分）查找，除非你启发式，一开始就说A在哪一个附近，B在哪一个附近....，完全告诉它，在这样一个情况，既然首字母是A，直接去查A那一部分就完了，B以后部分全砍掉；这就叫启发式了，你的算法可以这么设计；**如果没有启发式，折半效率是最快的**。

### 2.算法描述

如果一个算法没有想清楚就去写代码，那写出来的代码质量基本是不高的，更有可能是你压根就写不出来。也就是这个问题在头脑中就已经完全明确到了应该如何去实现；如果不明确，那么这个算法就很难去真正编程。

**伪代码**

混合自然语言与计算机语言、数学语言的算法描述方法描述算法的过程和步骤，第一步做什么第二步做什么...怎么方便怎么来，采用其中一个也行混着来也行，你把这个事情讲清楚了，写出来它，这就叫伪代码。

优点：方便，容易表达设计者的思想，能够清楚描述算法流程，便于修改。

缺点：不美观，（一会计算机语言一会数学语言，或者全是自然语言，全是数学语言，全是计算机语言，都有可能，这么写在一起不美观，别人看复杂算法就不太容易理解），复杂算法不容易理解。

**流程图**(程序框图)

使用图形表示算法执行逻辑；

优点：美观，算法表达清晰；

缺点：绘制复杂，不易修改，占用过多篇幅。

流程图往往是我们算法都设计完了，最终形成设计文档给别人看的时候，这样绘制觉得漂亮，给别人看，印象深刻。

**平时写程序的时候往往都是使用伪代码。**

### 3.算法设计与实现

算法选择的权衡指标：

- 正确性：算法是否完全正确？
- 效率：在某些场合，对程序效率的追求具有重要意义
- 可理解性：算法是否容易理解，也是必须考虑的（让别人容易看懂，同时维护起来也方便）

通常，效率与可理解性是不可兼得的，所以：

算法评估：衡量算法的好坏，主要是效率；但是对于初学者，可理解性其实更重要！尽可能用简单的方式去实现哪怕效率低一点也可以接受。

### 4.递归算法

递归的工作步骤：

递推过程：逐步分解问题，使其更简单

回归过程：根据简单情形组装最后的答案

一个函数通过直接或间接的手段调用自身的动作就叫递归，这样的函数就叫递归函数。

**理论上，任何递归程序都可以使用循环迭代的方法解决**

**写递归算法时需要问两个问题**：

Q1：是否存在某种简单情形，问题很容易解决

Q2：是否可将原始问题分解成性质相同但规模较小的子问题，且新问题的解答对原始问题有关键意义

**递归信任**：

有时候，初学者初学者经常会觉得，这个递归函数能实现么？总是怀疑疑虑，这里要特别强调：递归它一定是能正确工作的，养成最基本的递归信任，不用去怀疑递归工作的基本原理。递归信任里我们能够注意到六个问题：

- 递归实现是否检查了最简单情形

  大多数情况下，递归函数以if开头，如果不是，要仔细检查源程序

- 是否解决了最简单情形

  最简单情形不能调用自身递归，可以调用与它无关的递归

- 递归分解是否使问题更简单

- 问题简化过程是否能够回归最简单情形，还是遗漏了某些情况

- 子问题是否与原始问题完全一致

  如果递归过程改变了问题实质，则整个过程肯定会得到错误的结果

- 使用递归信任时，子问题的解是否正确组装为原始问题的解

### 5.容错与计算复杂度

容错的定义：允许错误的发生

正常情况下我们应允许错误的发生，并且在错误发生的时候能够知道按照什么方式对它进行正确的处理。

典型容错手段：

对于用户输入错误：数据有效性检查

致命错误：程序流程的提前终止（放置错误扩散，造成更严重的后果）

## 五.程序组织与开发方法

### 1.库与接口

从库与接口的角度上讲，实际上C/C++的程序包括了两类文件

```c
程序文件：源文件（*.cpp）

头文件（*.h、*.hpp、*）
```

使用.h和.hpp后缀对头文件命名有助于编译器更好地管理程序

库：源文件与头文件

库从本质上讲是不会独立运行的，那就意味着不需要为它编写main函数。所以从库的设计角度来讲，源文件就包括了具体的实现代码，而头文件则提供了库的接口。想使用库就要通过库的接口来使用，正常情况下也就是.h/.hpp这样的头文件。

**接口**：

通过接口使用库：包括制定库的头文件与源文件

优势：不需了解库的实现细节，只需了解库的使用方法

C++标准库提供了一系列的功能有很多很多个接口，合在一起统称为标准库。标准库包含两部分：C的标准库，C++的标准库；两者是不一样的。写代码时两者皆可使用。

**其中数学库，在Linux和Wins下的处理的方式不太一样。**

在windows下面"math"事实上就是C标准库中的一部分，但是在Linux下数学库是单列的，缺省的时候是不链接数学库的，所以如果链接，就用"-l"链接特定库的选项，后面跟着就是库的名字；所以-lm（l为link，m代表math）

在C下头文件：math.h；C++下头文件：cmath。

库文件：libm

链接方式：g++ -lm main.cpp

如果使用数学库的函数，就必须把数学库链接进去。

**工具与辅助函数**

头文件：stdlib.h/cstdlib

常用函数：

```c
void exit(int status);
void free(void *p);
void *malloc(size_t size);
int rand();
void srand(unsigned int seed);
```

### 2.随机库

```c
#include <cstdlib>
//rand()特别简单，不带任何参数，生成的随机整数在[0,RAND_MAX]这个闭区间范围内，RAND_MAX这个值到底为多少，不同的操作系统对其定义不一样。
srand((int)time(0));
//程序运行过程中，srand()函数只能调用一次，如果生成一个随机数调用一次，那就不行了，因为生成一个随机数的运行时间是非常非常短的，生成一个然后再做一个种子，那时间都没变，每次都设置同样的种子，那随机数不就一样嘛。而且必须是在你生成第一随机数之前调用！
```

**接口设计原则**

四项基本原则：

1）用途一致

接口中所有函数都属于同一类问题（用途不一致，别人就很难用）

2）操作简单

函数调用方便（让别人很容易用），最大限度隐藏操作细节

3）功能充足

满足不同潜在用户的需求

4）性能稳定

经过严格测试，不存在程序缺陷

**设计随机数接口**

随机数库这个接口应该设计一些什么样的函数，提供什么样的功能。

rand()生成[0,RAND_MAX]，但是我想掷骰子，生成0-6之间的随机数；再比如我想生成1-52之间的某个数，模拟扑克牌。就是说能够随机生成在指定范围内的随机数，而不是固定范围内的随机数。第二点，我还要能生成指定范围内的随机小数，尤其是0-1之间的随机小数。这就是随机库两个最主要的功能。还有一个需要对它进行随机化，即设定随机数发生器的种子

```c
void Randomize();
int GenerateRandomNumber(int low, int high);
double GenerateRandomReal(double low, double high);
//就这三条函数原型
```

**随机数库测试**

单独测试库的所有函数

​		合法参数时返回结果是否正确

​		非法参数时返回结果是否正确，即容错功能是否正常

（每一个函数都测试，保证每个函数单独运行时没有问题）

联合测试

​		多次运行程序，查看生成的数据是否随机

​		测试整数与浮点数随机数是否均能正确工作

（混合在一块运行时也是没有问题的）

库的使用者只要知道在生成随机数之前一定要调用Randomize进行随机化。

怎么重新设计数据库让用户不需要调用Randomize？

### 3.作用域与生存期

#### 量的作用域与可见性

作用域：标识符的有效范围

可见性：程序中某个位置是否可以使用某个标识符

**标识符仅在其作用域内可见**，但是位于作用域内的标识符不一定可见

**局部数据对象**：

定义于函数或复合语句块内部的数据对象（包括变量、常量与函数形式参数等）

```c
int func(int x, int y)
{
	int t;
	t = x + y;
	//单独出现的花括号对用于引入嵌套块
	{
		//允许在块中定义数据对象，作用域仅限本块
		int n = 2;
		cout << "n = " << n << endl;
	}
	return t;
}
//c和c++允许单独的复合语句块--一对孤零零的花括号，n从定义到cout语句做完就无效了。
```

**全局数据对象**：

全局数据对象具有文件（全局）作用域，有效性从定义处开始直到本文件结束，其后函数都可直接使用。

若全局数据对象定义的文件被其他文件包含，则其作用域扩展到宿主文件中，这可能导致问题。不要在头文件中定义全局对象，因为放在头文件里非常容易被别人包含，一被别人包含作用域就会扩展过去，编译器很可能报错，因为**不允许定义同名的全局变量**！在一个工程项目里不允许定义全局变量，哪怕他们是在不同的文件里。

**函数原型作用域**：

定义在函数原型中的参数具有函数原型作用域，其有效性仅延续到此函数原型结束，不会延展到函数所对应的实现里面去；这就意味着原型里的参数和实现里的参数名字可以不一样！

**全局变量如果没有初始化，都自动的初始化为0**。

**注意**：如果复合语句块内有变量i，全局变量里也有i，那复合语句块内输出i时到底是哪个i呢？作用域它都在嘛，那就体现一个点，**可见性**嘛。全局变量i作用域很长，在复合语句块内不可见，原因就在于它被一个新定义的作用域更小的局部变量i覆盖了可见性。**如果在复合语句块内非要访问全局变量i，可使用全局解析操作符，::i**。

#### 量的存储类与生存期

生存期：量在程序中存在的时间范围。通俗的讲，就是这个量能活多长时间。

**C/C++都使用存储类来表达生存期**。

作用域与可见性表达的是量的空间特性，存储类表达量的时间特性。

一般来讲，C/C++代码里的量具有两类生存期，一个称为静态（全局）生存期，一个称为自动（局部）生存期。

- 全局数据对象具有静态生存期；也就是说它的生死仅与程序是否执行有关，程序运行它就出手了，程序结束它就死掉了。
- 局部数据对象具有自动生存期；生死仅与程序流程是否位于该块中有关。程序代码进入语句块，在语句块内部定义的局部变量就算出手了，离开了这个局部块，局部变量就死掉了；程序每次进入该块时就为该对象分配内存，退出该块时释放内存；两次进入该块时使用的不是同一个数据对象（人不能两次踏进同一河流）。

**static关键字**

修饰局部变量：静态局部变量

使局部变量具有静态生存期；程序退出该块时局部变量仍存在，并且下次进入该块时使用上次的数据值；因为static修饰的局部变量的生存期就像全局变量一样长；**静态局部变量必须进行初始化，同时它不改变量的作用域，只改变生存期**（即生命被拉长了，但存在的空间仍然没有发生变化）

**注意**：静态局部变量**看上去就像全局变量一样**，**初始化在程序启动前就做好了，调用main函数之前该变量就被初始化了**。

修饰全部变量

不表示将生存期拉长，而表示限定作用域，**只在本文件内部使用，其它文件不可见**。

#### 函数的作用域与生存期

所有函数具有文件作用域与静态生存期（空间尽可能大，时间尽可能长）

在程序每次执行时都存在，并且可以在函数原型或函数定义之后的任意位置调用。

**内部函数与外部函数**

内部函数：不可以被其它文件中的函数所调用

函数缺省时均为外部函数

内部函数定义：使用static关键字

示例：static int Transform(int x);static int Transform(int x){...}

注意:**内部函数不能把它写在所对应的头文件里**

**声明与定义**

声明不是定义。定义是在程序产生一个新实体，声明仅仅在程序中引入一个实体，不创造只是引入，这个实体可能是别人替我们创造的，可能是我们在另外一个文件中创造的。

**函数的声明与定义**

对于函数来讲，声明就是给出函数的原型，定义就是给出函数的编码实现。如果产生一个新的类型那就叫定义，如果新的类型没有被产生那就是声明；定义一定会构造出新的型来，而声明是没有构造出来。

**全局变量的作用域扩展**

全局变量的定义不能出现在头文件里，只有其声明才可以出现在头文件中。（如果定义出现在头文件里，工程项目中很多文件include该头文件时，就会出现重复定义，编译器是通不过的；**想要全局变量跨文件使用，又不能重复定义，怎么办呢，有个技巧，使用external关键字**）

声明格式：使用extern关键字

```c
/*库的头文件*/
//此次仅引入变量a，其定义位于对应源文件中
extern int a;//变量a可导出，其他文件可用;将变成变量的声明，而不是定义

//库的源文件
//定义变量a
int a;
```

#### 典型软件开发流程

软件工程概要

问题的提出

- 需求分析
- 概要设计
- 详细设计
- 编码实现
- 系统测试

经验总结

从软件工程角度来讲，真实的开发程序实际上要通过以上5个步骤才能完成，没有这些流程，程序的开发实际上是非常困难的。

**软件工程概要**

需求分析：确定软件需要解决什么问题

决定因素：人

​		软件开发人员需要与用户深入交流，明确问题的输入、输出以及其他附加信息。

​		从设计程序的角度上来讲，**不要轻视任何问题**，因为哪怕是最简单的问题，用计算机语言实现起来可能都是非常复杂的。

**方案设计：设计程序框架**

**分为概要设计与详细设计**

概要设计：设计总体方案，形成高层模块划分

详细设计：细化模块，获得各模块的输入、输出与算法

有了概要设计，有了总体方案，那么就可以向总体方案中填充细节，包括每一个模块的输入、输出和算法，都要在概要设计里完成。有了概要设计之后，其实已经明确了程序中要设计什么样的函数，设计什么样的模块，如果具体到某一个特定的函数的话，那么每一个函数输入是什么、输出是什么、算法是什么，所有的信息理论上都应该完成，有了它就可以很容易地编写程序代码。

**编码实现：实际编程**

**系统测试：测试程序的正确性与稳定性**

这里面的每一个过程都有可能会产生一种反馈，修改原来的设计、原来的分析、原来的实现，形成一个螺旋式的开发流程。这种情况就是最常见的软件开发过程。

**有了概要设计其实就决定了程序的主体框架是什么。**

**系统测试**

**真实测试的时候可能就是干脆直接输出实际的价格，不然真的自己去猜去玩这个有效那测试效率太低了！**

所有数据对象是否已经正确初始化？

随机生成的价格是否合理有效？测试过程可能需要在源程序中添加必要的测试代码，例如：

```c
double PlayGame()
{
    ...
    actual_price = InitializeBout();
    #ifndef NDEBUG
    	cout << "Debugging:Actual price = " << actual_price << endl;
   	#endif//结束这个条件判断
    ...
}
```

那么在真实程序运行的时候，cout这段输出肯定是不能要的，程序真正发布的时候这行代码是要删掉的，可是如果总是一开始测试的时候贴上去，后来又删除，那当代码量很大的时候很难删的，一不小心就删错了。

在这种情况下就有个小技巧。凡是用于测试的这些输出在未来都不应该出现，用一个宏包起来，#ifndef（它是一个条件编译指令），作为一个**宏测试**，意思是如果没有定义，NDEBUG为宏的名字，那么编译器就编译cout这条语句，程序运行的时候就会执行这段代码；如果你定义了这个宏，那么它里面封包的cout这条语句就不编译了，所以就不需要你删除，想去掉这样的cout语句，很简单，在程序的最开头写上一行，

```c
#define NDEBUG
```

**经验总结**

Q:这个问题一开始大家认为它难不难？

A:不难

Q:程序设计难不难？

Q:难，如果要程序员从系统分析、方案设计开始做起的话

Q:编码难不难？

A:不难，与系统分析与设计相比编码实在简单，不过就是使用了所有代码控制结构和函数编写原则而已。

## 六.复合数据类型

### 1.字符

**字符类型、字符文字与量**

定义格式：char ch；const char cch = 'C'；

字符文字使用单引号对

**实际存储时字符类型量存储字符的对应ASCII值**

可使用signde与unsigned修饰字符文字；缺省的情况下它是signed。正常情况下我们不需要对它进行限制，即使用unsigned。

这个字符的存储一般有多大呢？正常情况下使用8位，也就是一个字节来存储它。表达范围实际上是在-128~127之间。

如果是unicode字符，则使用2个字节存储。

ASCII码表示的字符的整数范围为0-127。ASCII值'\0'在计算机内部保存的时候，保存的其实就是0。而真正的数字0在计算机内部保存的时候，事实上保存的是ASCII码值48。

实例：判断某个字符是否为数字（0-9）

```c
//不能写在‘0’~‘9’之间，而是在48-57之间
```

**标准字符特征库**

在C++里边提供了一系列标准字符运算，当然实际上这是C代码，C的函数库里边包括了一系列字符特征，库函数它写在"ctype.h"这个头文件里，用C++模式包含这个头文件的时候，你就可以写"cctype"。

### 2.数组

**数组的意义与性质**

数组的定义：

定义格式：元素类型 数组名称[常数表达式]

示例：int a[8]; //定义包含8个整数元素的数组

**特别说明**：常数表达式必须是常数和常量，不允许为变量。

```c++
const int count = 0;
int c[count];
//大多数编译器这样可以通过，但是在C程序里这样不行，只能为常数才行 
```

数组的存储表示

数组元素的访问

数组与函数

多维数组



## 七.指针与引用

引用是一个和指针相关的一个新的数据类型，和指针非常相似，但是又完全不同，某些方面它起到的作用和指针是相同的，但是在具体的实现上，和指针实际上是截然不同的。**它不仅是一种新的数据类型，它事实上还是一个新的参数传递机制**。

### 1.指针基本概念

每一个变量，也就是说每个数据对象，它有四个基本特征：VANT。一旦你的程序编译完成后，N（name）和T（type）就没了，正常情况下，信息是缺失的，在我们的程序代码里面，实际上主要就那么两个东西：一个是地址，一个是值。

**数据对象的地址与值**

地址：数据对象的存储位置在计算机中的编号

值：在该位置处存储的内容

地址与值是辩证统一的关系，通过一种恰当的机制，我们可以让一个量的地址就是值，可以让一个值就是一个地址。**这个机制就叫指针**（它就是构造地址和值辩证统一的最重要的一个桥梁）。

#### 指针的定义格式

格式：目标数据对象类型*指针变量名称；

例一：定义p为指向整数的指针：int * p；

```c++
int *p; //*号前有空格，可以是任意个空格
int* p; //*号后有空格，可以是任意个空格
int*p; //*号前后都没有空格
int * p; //*号前后都有空格，可以是任意个空格
//在定义的代码中，有一个*代表指针，有两个*就代表指向指针的指针，有三个*就代表指向指针的指针的指针~~~
//这个写法看个人习惯，其实如果*靠近返回值类型的话可能更容易理解其定义。

int *a;
int* a;
两者意思相同且后者看上去更为清楚:a被声明为类型为 int* 的指针. 但是,这并不是一个好技巧,原因如下:
int* b, c, d;

人们很自然地以为这条语句把所有三个变量声明为指向整形的指针, 但事实上并非如此. 我们被它的形式愚弄了. 星号实际上是表达式 *b 的一部分, 只对这个标识符有用。 b 是一个指针, 但其余两个变量只是普通的整形. 要声明三个指针, 正确的语句如下:

int *b, *c, *d
```

> 上述四种写法编译都没有错误，在定义中的 * 号我们现在可以理解为这仅仅代表定义了一个指针变量p, p的类型是 int * 或者 int* 。
>
> 之后要讲到 * 的 “取地址中的内容” 这个意思，那么这个 * 号和定义中使用的 * 号，是一个意思么？
>
> 我们先从 * 和 & 后边接的变量以及作用说起，之后再对第一篇文章中讲解的指针的定义进行更加深入的理解
>
> **& 和 * 可以理解为对紧接在后边的变量进行一定的信息提取**
>
> & 和 * 后边紧接的都是变量，但后边接的变量有所不同，& 后边紧接的是存放真实数据的变量（整型变量 a 或者是字符变量 b等），而 * 后边紧接的是存放地址数据的变量（比如int * 类型的变量或者char *类型的变量）
>
> &a 意味着提取变量 a 的地址，我们想要知道 a 放到哪里了
>
> *p意味着提取变量p里存放的地址所对应的存储空间里存放的真实数据，我们想知道这个地址处放了什么内容，101教室上的什么课。
>
> 知道了 * 符号代表的意思，我们来看一下上一篇文章讲的指针的定义~
>
> ```cpp
> int *p;
> ```
>
> 定义一个int型数据 a 时，是这样的语句 int a; 我们不妨类比一下，把 *p 先看成一个整体， *p 就是一个整型变量。
>
> *p是一个整型变量，我们讲 * 后边接的变量是一个指针变量，那么 p 就是一个指针变量了，那么 p 就是存放 *p 的内存的地址；
>
> *p 是一个整型变量，同时我们能得到 &*p 就是存放 *p 的内存的地址；
>
> **最终我们得到 p=&*p** 

含义：定义一个指针类型的变量名字叫p，它是一个指针，指向一个整数；把这个写法倒过来看，定义一个变量，名字叫p，它是一个指针，指向一个整数。

多个指针变量的定义：

例二：int * p，* q；

如果怕忘记第二个变量的*，可采用如下方式：typedef int * PINT；PINT p,q；如果写PINT p, * q；那么q指向PINT，即指向指针的指针。

#### 指针变量的存储布局

在使用指针的时候**一定要记住**：指针数据对象事实上涉及到两个数据对象，并不是只有一个，一个就是指针数据对象本身，第二个就是指针所指向的目标数据对象。

如果你在定义这个指针变量过程中，同时对它进行初始化，那么这个时候就会涉及到两个数据对象。

> 一定一定记住一点， **指针和变量一样，也是有值的，只不过变量的值被解释成一个值，而指针的值被解释成一个地址。**

定义指针变量，**并使其指向数组首元素**：

例三：int a[8] = {1,2,3,4,5,6,7,8};int * p = a;

p作为一个指针，只能指向一个整数，并不能指向8个整数，即p指向数组的0号元素。

**指针变量可以像普通变量一样赋值**

示例：

```c++
int n = 10; 
int *p = &n, *q;
q = p;
//两个指针指向同一个目标数据对象
```

#### 取址操作符“&”

获取数据对象的地址，可将结果赋给指针变量（得到的地址像一个普通的值一样赋值给指针变量）

#### 引领操作符

获取指针所指向的目标数据对象

用* p去引领p所指向的目标数据对象，p指向n，那* p就代表这个指针p所指向的目标数据对象n

#### 指针的意义与作用

**作为函数通信的一种手段**

使用指针作为函数参数，不仅可以提高参数传递效率，还可以将该参数作为函数输出集的一员，带回结果；（和外界进行通讯的时候，函数可以有一个返回值或者没有，它只能带回来一个结果，如果想带回来两个以少的结果怎么办呢？把它的两个结果合成一个结构体，用这个结构体作为函数的返回值，它就可以把这个同时都带回来；还有一种方案，指针作为函数参数，它就可以把这个结果带回来）

**作为构造复杂数据结构的手段**

使用指针构造数据对象之间的关联，形成复杂数据结构

**作为动态内存分配和管理的手段**

可以在程序执行期间动态构造数据对象之间的关联

**作为执行特定程序代码的手段**

使用指针指向特定代码段，执行未来才能实现的函数

**<font color = "00aaee">这四种使用场合务必掌握！</font>**

### 2.指针与函数

一个结构体的尺寸往往会很大，你要传结构体，那么结构体得整体赋值，如果传指向结构体的指针，那么它只需要赋结构体的地址就行了，结构体的地址有多大呢？32位的计算机、32位的编译器，它的尺寸是固定的4个字节。

**注意**：示例中main函数中写了swap函数，在main函数里有两个量m，n，调用swap时实际上是覆盖了这个main函数的栈框架，所以在swap执行过程中是看不见main函数的数据的，实际上是不能访问m和n的值的，也就是说不能在swap中使用main函数的m和n，并不表示它们不存在，只是我们没办法通过名字m和n来访问它们。现在我们有指针了，可以用* x，* y访问，* x就是m，* y就是n。

> 变量的作用域（生命周期）可以通过所在du的大括号界别来确定；
> main里定义的变量，是在main的大括号里， 所以在test的大括号是访问不到的（他们不是包含的关系）
> 而类的那个，定义的成员变量（字段）是属于class的大括号，而里面的方法的大括号是class大括号里面的（包含），所以是可以访问到的

#### 常量指针与指针常量

常量指针：指向常量的指针

性质：不能通过指针修改目标数据对象的值（即不可以通过引领操作符来修改目标数据对象的值），但可以改变指针值，使其指向其他地方。

```c++
示例一：
int n = 10; const int *p = &n;
```

典型使用场合：作为函数参数，表示函数内部不能修改指针所指向的目标数据对象值。

```c++
示例二：
void PrintObject(const int *p);
//限定了指针p只能作为函数输入集的一部分，不能作为函数输出集的一个部分
```

指针常量：指针指向的位置不可变化

性质：不可将指针指向其他地方，但可改变指针所指向的目标的数据对象值

**<font color="00aaee">指针常量和其他常量一样，必须在定义的时候初始化！</font>**

```c++
示例三：
int n = 10;
int * const p = &n;
//这个时候必须把它初始化为&n；因为p是一个常量，不可以被赋值，所以你定义它的瞬间必须初始化。
//前面的常量指针你不初始化是可以的，然后再赋值p=&n
```

常量指针常量：指向常量的指针常量（指针的双重只读属性）

```c++
示例四：
const int n = 10;
const int * const p = &n;
//const关键字实际上是左结合的，它作用在它左边的标记上面，
const int * p = &n;//const左边啥都没有，这个时候就只能作用它右边的int上面，它不作用在*上面，也不作用在int *上，表示那个整数是常量。
//如果严格按照const的左结合，那么const int应该写为int const，所以示例四中的第一个const写在int前或者后都是对的，第二个const一定要写在*后边。
```

典型使用场合：主要作为函数参数使用（大部分情况下不需要搞这么复杂，主要使用常量指针）

#### 指针与函数返回值

指针类型可以作为函数返回值，它会带回来一个目标数据对象的地址，但是指针作为函数返回值的时候，它不能返回函数内部定义的局部变量的地址，只能返回某个全局变量的地址或者作为函数的参数传给函数的指针。

```c++
程序示例：
int global = 0;
int * ReturnPointer()
{
return &global;
}
```

网上查找补充知识点：

**指针函数与函数指针**

指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，**而该函数的返回值是一个指针**（即地址值）。
声明格式为：类型标识符 *函数名(参数表)

```c++
int* fun(int x,int y);
```

函数指针，**其本质是一个指针变量，该指针指向这个函数**。总结来说，函数指针就是指向函数的指针。
声明格式：类型说明符 (*函数名) (参数)

```c++
int (*fun)(int x,int y);
```

函数指针是需要把一个函数的地址赋值给它，有两种写法：

```c++
fun = &Function;
fun = Function;
```

取地址运算符&不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。
调用函数指针的方式也有两种：

```c++
x = (*fun)();
x = fun();
```

两种方式均可，其中第二种看上去和普通的函数调用没啥区别，如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。当然，也要看个人习惯，如果理解其定义，随便怎么用都行啦。

### 3.指针与复合数据类型

#### 指针与数组

数组基地址：&a或者a

数组首元素地址：&a[0]

数组第i个元素地址：&a[0]+i*sizeof(int)

**数组基地址与首元素地址数值相同**，故：数组第i个元素地址可表示为a+i*sizeof(int)

**指针运算**

指针与整数加减运算的结果仍为指针类型量，故可赋值。

设p为指向整数数组中某元素的指针，i为整数，则p+i表示指针向后滑动i个整数，p-i表示指针向前滑动i个整数。

**规律**：以指针指向的目标数据对象类型为单位，而不是以字节为单位。

递增递减：p指向a[0]，则p++指向a[1];p指向a[1]，则--p指向a[0]

指针减法运算：两个指针的减法运算结果为其间元素个数

过尾元：让一个指针指向数组0号元，在数组最后增加一个元素，让另一个指针指向它，两个指针相减即得到数组的长度。

关系运算：p==q测试两个指针是否指向同一个目标数据对象

**空指针**：NULL

​	指针值0：表示指针不指向任何地方，表示为NULL；其实它指向的是内存条最开头的存储区。不过现在主流的操作系统，几乎所有的操作系统在那个存储区都是什么数据都不保存的，专门就用来捕获指针错误的。

例：设p为指针，则p=NULL表示p不指向任何目标数据对象

**特别注意**：使用指针前一定要测试其是否有意义，if(p != NULL)或if(p)；当你在编写带有指针的程序的时候，它非常容易出错，如果这个指针是错的，它指向一个无意义的地方或者它没有权利去访问的地方，这个程序不是错的而是崩溃，这个错误就太严重了，所以每次使用指针都要注意这点！每次访问指针，想通过引领操作符访问它的目标数据对象的时候，都要测试这个指针是不是有意义。

指针数据对象，理论上来讲，你应该对它进行初始化。要么是合法有效的目标数据对象的地址，要么就是0。只有这样才能保证你的测试每次都是有意义的。因为如果你不对它初始化，它是个全局量，自动被初始化为0，如果这个指针变量本身是个局部量，那么它内部的位序列就是随机的，极有可能不是0。如果不是0，你一访问，目标数据对象区域没有权利访问的，程序一下就崩了。

**作为函数参数的指针与数组**

```c++
*p++ = GenerateRandomNumber(lower_bound, upper_bound);
```

*p++，这是两个操作符 * p、p++，因为是后缀++，所以是把函数调用后生成的那个整数赋值给 * p，然后才能做p++。它做的绝不是（* p）++，不是（* p），如果你是想把* p这个目标量累加，那么你必须写（* p）括号完毕后++那才对。p一开始指向0号元，所以把生成的那个数赋值给0号元，然后p++让p指向1号元。

指针作为函数参数：函数调用

​	必须传递已分配空间的数组基地址，比如int a[8]。

#### 指针与数组的可互换性

指针一旦指向数组的基地址，则使用指针和数组格式访问元素时的地址计算方式是相同的，此时可以互换指针与数组操作格式：p[i]与*（a+i）分别与a[i]与 * (p+i)的功能是一样的。但是并不表示此时指针与数组真的等价。在某种程度上讲，指针和数组的等价的，可以互换，**注意**，这并不是全部的应用场合，在一维数组上是有效的，在高维它可能就是无效的了。

指针和数组真是完全等价的吗？当然也不是，它还是有一些例外的。数组名本身它是一个常数，此时不能在数组格式上面进行一些特定指针运算的；比如：

```c
for(int i = 0; i < 3; i++)
	cout << *a++ <<endl;
//可以写*a+1，*a+2等，但是不能写*a++；因为a++它是a+1赋值给a，因为a是一个常数，它不能被赋值。
//而*p++可以，它是指针量
```

#### 指针与数组的差异

```c
int a[3] = {1,2,3};
int *p = &a; //会为p分配一个存储空间，这个存储空间有多大呢？我们现在32位计算机、32位的编译器，p是四个字节，int a[3]是12个字节，

```

定义数组的同时确定了数组元素的存储布局：a为静态分配内存的数组；若a 为全局数组，则程序执行前分配内存；若为局部数组，则在进入该块时分配内存。

定义指针时规定指针数据对象的存储布局：**p** 为指针，若 p 为全局变量，则程序执行前分配内存；若为局部变量，则在进入该块时分配内存。

**注意**：**定义指针的时候，规定的是指针数据对象的存储空间**，定义数组的时候，它规定的是数组元素的存储空间。这两者是不一样的。如果你定义一个指针，它就不会为那个数组分配空间，它只分配指针这个对象的空间，如果这个指针指向那个数组，你必须保证那个数组已经分配了，其他地方分配的跟这个指针没关系，**除非你是动态分配的**。

定义指针时未规定目标数据对象的存储布局：**p** 为指针，指向一个已存在数组的基地址，即指向该位置处的整数 a[0]；若a未初始化，则目标数据对象未知。

**所以**：使用指针时，指针这个对象和指针所指向的目标数据对象两者之间的关联在你的程序里必须显示地构造它。

#### 多维数组作为函数参数

不能每维都不传递元素个数，语法规则不允许，二维数组只能第一个中括号里什么都不写，三维数组里也只能第一个中括号里什么都不写，后面的你都必须给写上，没有数据是不对的，编译器是通不过的。所以采用另一种方案，把二维数组当一维数组降维，但是找具体的a[i] [j]，使用运算a+n*i+j运算有点麻烦，到了高维数组以后要这么运算，能不能算出来都不好说了，到了高维降维都有可能出问题；而且从逻辑上讲明明是二维搞成一维有点怪怪的。

那么有没有一个妥当的方案呢？没有，不管是C还是C++里，当多维数组作为函数参数传递的时候，就没有一个好方案能够解决这个问题。所以实在没招，建议按照第一个方案写：

```c
void PrintTwoDimensinalArray(int a[8][8], unsigned int m, unsigned int n);
```



#### 指针与结构体

```c++
指向结构体的指针对象
struct STUDENT{ int id; STRING name; int age; };
STUDENT student = { 2007010367, "Name", 19 };
STUDENT * pstudent = &student;
```

**访问指针所指向的结构体对象的成员**

必须使用括号：选员(.)操作符优先级高于引领操作符，比如：（*pstudent).id

C/C++提供了一个新的操作符，选员操作符"->"，比如pstudent -> id

> 如果对象是使用 new 在自由存储区中实例化的，或者有指向对象的指针，则可使用指针运算符（->）来访问成员属性和方法。

**结构体成员类型维指针**

```c
struct ARRAY{ unsigned int count; int * elements; };
int a[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
ARRAY array = { 8, &a };
//访问指针类型的结构体成员
//访问 elements 的第 i 个元素： array.elements[i];也就是把element当作数组用
```

```c
//若有定义：ARRAY * parray = &array;

访问parray指向的结构体对象elements的第i个元素：

//(*parray).elements[i]或parray->elements[i]
```

#### 结构体指针的使用场合

有两个非常重要的使用场合：

​	**使用指向结构体对象的指针作为函数参数**

```c
好处一：节省结构体整体赋值的时间成本
好处二：（普通结构体类型的参数作为参数传进去，它不能把结果带回来，我们就觉得不方便，想带回来结果，传它的指针，结果就能带回来了）解决普通函数参数不能直接带回结果的问题，可以在函数内部改变目标结构体对象的值
//你又想快，又不想带回来结果，就指向const结构体的指针
```

​	**构造复杂的数据结构**

```c
我想创建一个数据结构，这个数据结构能够表达动态的数组信息，表达数组元素个数，可以在整个程序运行期间，随时发生变化的数据结构，它里边保存了一系列元素，这些元素的个数可以在程序运行期间动态的变化，可以大也可以缩小，这个我们就称它为动态数组，我们就需要使用很特殊的像这样的数据结构
动态数组：struct ARRAY { unsigned int count; int * elements; };
//count为数组元素的个数，然后用一个int * element来表达指向特定元素的指针，以后就可以通过element指针的运算来访问它的0号元、1号元、2号元；你定义好这个数据结构必须为它创建一系列对动态数组进行操作的函数
```

### 4.字符串

字符串的表示

三种理解角度：作为字符数组，作为指向字符的指针，作为抽象的字符串整体

#### 多个字符数组连续存储时的问题

如何区分存储空间刚好连续的多个字符数组?

解决方案：字符数组末尾添加结束标志'\0'，'\0'即ASCII码值为0的那个字符

**优** **点**

可以在程序运行时通过测试‘\0’字符确定字符数组是否结束，而不需要了解数组元素个数，使处理元素个数未知的数组成为可能通过指针运算直接操作字符数组中的字符，而不再使用数组格式访问字符元素

**字符指针量的定义、初始化与存储**

char *s = "CPP-Prog"；

s作为一个指针它会分配一段存储空间4个字节，里面保存字符串的基地址，而那个字符串基地址里面会分配9个字节，来存"CPP-Prog\0"。注意，这里面双引号字符串文字尾部的'\0'是编译器为我们自动添加的。

**特别注意**：不管char *, int *, float *,所有类型的指针变量在32位系统上都是4字节， 64位系统上都是8字节。

**用char *s定义的时候它会多一个指针变量**

#### 字符数组与字符指针的差异

①按指针格式定义字符串，可以直接赋值

```c
示例：
char * s; 
s = "CPP-Prog"; // 正确
//字符串文字首先分配空间，然后将其基地址赋给 s，使 s 指向该字
//符串基地址
```

②按字符数组格式定义字符串，不能直接赋值

```c
示例：
char s[9]; 
s = "CPP-Prog"; //** **错误**

//不能对数组进行整体赋值操作
//char s[9]会分配9个字符的存储空间，然后“CPP-Prog”它本身也要分配9个字符的存储空间，保存进去，然后把这个基地址赋值给s，赋值不了，s是个数组，它必须接受9个字符，而不是接受9个字符的基地址。
//原因：数组空间已分配，字符串文字空间已分配，且它们位于不同位置，不能直接整体复制
```

示例：编写函数，将某个字符c转换为字符串

```c
typedef char * STRING
STRING TransformCharIntoString( char c )
{
 STRING _s = (STRING)malloc( 2 );
 _s[0] = c;
 _s[1] = '\0';
 return _s;
}
//分配2个字节的存储空间，分配出来的空间转换为STRING，然后把它初始化或赋值给STRING类型变量_s
```

```c++
char * TransformCharIntoString( char c )
{
 char _s[2];
 _s[0] = c;
 _s[1] = '\0';
 return _s;
}
//错误函数定义
	对于所有返回值为指针类型的函数，都不能返回在函数内部定义的局部数据对象——所有局部对象在函数结束后不再有效，其地址在函数返回后没有意义
```

#### 标准字符串库

**标准库中关于字符串处理的函数很多，均定义于头文件“cstring”中**，用C++的就包含“string”。

如果写C++，不建议使用标准字符串库，使用string类代替。

**string类**

```c
定义于头文件“string”中
声明与构造string对象
string s = "abcdefg"; //定义s然后把它初始化
string s( "abcdefg" ); //直接构造的时候对它初始化，这种方式更好
读取与写入string对象
cout << s << endl;
cin >> s; // 读取以空格、制表符与回车符分隔的单词
getline( cin, s, '\n' ); // 读取包含空格和制表符在内的整行
//从cin这个输入流里面去读取，然后把这个东西读到s字符串里面去，最后的'\n'表示以它结尾，读的是一整行
```

①获取string对象的长度

使用length()函数，从属于string类这个对象的。

②改变string对象的容量大小

s.resize(32); // 将s设为32字符长，多余舍弃，不足空闲
s.resize(32, '='); // 多余舍弃，不足补‘=’

③string对象的追加操作

string s1 = "abcd", s2 = "efg";
s1.append( s2 ); // 将字符串s2追加到s1尾部

或者更简单直接使用’+‘，提供了重载操作符，可以直接使用。

④string对象的比较操作

string s1 = "abcdefg", s2 = "abcdxyz";
int a = s1.compare( s2, 0 ); // 从0号位字符开始比较

⑤string对象的查找操作

string s1 = "abcdefg", s2 = "bcd";
int a = s1.find( s2, 0 ); // 从字符串开头开始查找，结果为
s2在s1中首次出现的位置

### 5.动态存储管理

#### 内存分配与释放

①静态内存分配方式

适用对象：全局变量与静态局部变量

程序运行前分配好，程序结束了它就释放

静态的方式分配的这些内存它的生存期是巨大的，它就和我们的程序一样长。实际上比我们真正的main函数运行还要长，它在main函数之前就能分完，main函数做完了它才能够销毁。

②自动内存分配

适用对象：普通局部变量
分配与释放时机：在程序进入该函数或该块时自动进行，退出时自动释放

③动态内存分配方式

你想让它什么时候分配就什么时候分配，想让它什么时候销毁就什么时候销毁，全由程序员编程说了算。

动态内存分配的目的
	静态与自动内存分配方式必须事先了解数据对象的格式和存储空间大小，部分场合无法确定数据对象的大小

动态内存分配的位置
	计算机维护的一个专门存储区：堆
	所有动态分配的内存都位于堆中

动态内存分配的关键技术
	使用指针指向动态分配的内存区
	使用引领操作符操作目标数据对象

​	也就是说没有指针这个动态内存分配是做不到的。

#### 标准库的动态存储管理函数

```c
动态存储管理函数的原型
头文件：“cstdlib”和“cmalloc”，两者包含其一即可
内存分配函数原型：void * malloc( unsigned int size );
内存释放函数原型：void free( void * memblock );

```

**void * 类型**

**<font color="00aaee">一个非常非常非常重要的数据类型</font>**

称它为哑型指针，特殊的指针类型，它非常特殊。

它表示指向的目标数据对象类型是未知的，它是一个指针没错，指针的目标数据对象类型void也没错，不是说它的目标数据对象没有类型，**目标数据对象一定是有类型的，但是它的类型是什么呢？我不知道**。

所以你绝不能在其上使用引领操作符访问目标数据对象

> This gives `void` pointers a great flexibility, by being able to point to any data type, from an integer value or a float to a string of characters. In exchange, they have a great limitation: the data pointed to by them cannot be directly dereferenced (which is logical, since we have no type to dereference to), and for that reason, any address in a `void`pointer needs to be transformed into some other pointer type that points to a concrete data type before being dereferenced.
>
> ---cplusplus.com/doc/tutorial/pointers
>
> ---它们指向的数据不能直接解引用(这是符合逻辑的，因为我们没有类型可以解引用）

可以转换为任意指针类型，不过转换后类型是否有意义要看程序逻辑
可以在转换后的类型上使用引领操作符（或称解引用操作符）

主要目的：作为一种**通用指针类型**，首先构造指针对象与目标数据对象
的一般性关联（我用一个指针，指向一个东西，那个东西类型是什么我现在还不知道，那我就用void * 指针，然后指向它），然后由程序员在未来明确该关联的性质（这就是void * 最重要的一个地方）

所以在C语言里，它是通用的类型，什么东西都可以表示，因为如果它不能表示，它一定能够表示那个东西的地址，比如那个结构体 void * 不能表示，但是我能表示指向结构体的指针，能够表示那个结构体的地址啊，int * 它也能表示，实际上因为在32位编译器下边，它这个void * 指针尺寸是固定的4个字节，如果int刚好也是四个字节呢，int就可以直接转换成void * ，反正尺寸是够的，你直接传进去就行了。它是通用的一个型。

1）malloc与free

示例：编写函数，复制字符串

```c
char * DuplicateString( char * s )
{
 char * t;
 unsigned int n, i;
 if( !s )
 	{ 
     	cout << "DuplicateString: Parameter Illegal."; 			exit(1);
 	}
 n = strlen( s );
 t = ( char * )malloc( n + 1 );
 for( i = 0; i < n; i++ )
 	t[i] = s[i];
 t[n] = '\0';
 return t;
}
//这个地方指针是不能直接赋值的，直接赋值那两个指针都指向目标字符串了
//这个字符串的构造我们一定要动态地构造，因为在调用这个函数之前，我压根就不知道s所指向的那个串有多少个字节，所以你没有办法预先假定新的串的存储空间要多大合适，你只能按照这个方式来，给我多长就分配多长。
```

特别说明：有分配就有释放

**free 函数释放的是 p 指向的目标数据对象的空间，而不是 p 本身的存储空间**，p本身不需要销毁，它要么是全局量，要么是局部量。

调用 free 函数后，p 指向的空间不再有效，但 p 仍指向它

为保证在释放目标数据对象空间后，不会再次使用 p 访问，建议按照下述格式书写代码：

```c++
free(p); 
p = NULL;
```

```c++
示例二：
int * p = ( int * )malloc( 10 * sizeof( int ) ); 
free( p );
//示例二分配能够容纳 10 个整数的连续存储空间，使 p 指向该空间的基地址，虽然指向0号元，实际上通过这个指针操纵的是40个字节的存储空间；最后调用 free 函数释放 p 指向的整个空间,而不是只销毁数组的0号元
```

2）new与delete

这个功能要比malloc和free强大很多；它事实上不仅能够替你分配内存，还能够替你构造所分配的那个目标数据对象。

new和delete是配对使用的，new[]和delete[]是配对使用的，malloc和free配对使用；c的与c++的不能混用。

**所有权与空悬指针**

指针为什么难用？它涉及到很重要的一个地方，就是这里面涉及到两个数据对象，一个是目标数据对象，还有一个指针数据对象本身，尤其是当目标数据对象本身它是没有名字的时候，那么这种情况下面，访问它的唯一的手段，就是需要通过一个指针数据对象来指向它。这种时候我们可以称之为这个指针拥有那个目标数据对象的所有权，问题就在于我们编程的时候，我们有可能很多个指针指向同一个目标数据对象，那么这种情况下谁拥有它，谁有权使用它，一个是使用权，一个不仅有使用权还有所有权。这个就需要决定。但是我们的程序中呢，其实也没有什么很好的方案能够解决这个问题，尤其是在C/C++早期的代码里，这个东西是没有办法解决的，你只能是程序员头脑中要很清晰地架构这个目标数据对象是谁所有 的，谁只有使用权而不是拥有权。这样才能保证你的程序不容易写错，否则的话非常容易出错。

（所以）指针使用的一般原则

```c
主动释放原则：如果某函数动态分配了内存，在函数退出时该目标数据
对象不再需要，应主动释放它，此时 malloc 与 free 在函数中成对出现
    
所有权转移原则：如果某函数动态分配了内存，在函数退出后该目标数
据对象仍然需要，此时应将其所有权转交给本函数之外的同型指针对象，
函数内部代码只有 malloc，没有 free
//因为这个内存区域是这个函数中某一个局部变量所拥有的，它有所有权，但是那个变量将会随着这个函数一样死掉了，所以这个所有权必须在这个函数结束之前要能够完成它的转移，往往都是通过函数的返回值转移给我们的主调函数
```

在编写指针类型的程序的时候，经常会出现两种问题，一个就是空悬指针的问题，

```c
//所有权的重叠：指针赋值操作导致两个指针数据对象指向同样的目
//标数据对象，即两个指针都声称“自己拥有目标数据对象的所有权”
示例：
int *p, *q; 
q = ( int* )malloc( sizeof(int) ); 
p = q;
产生原因：如果在程序中通过某个指针释放了目标数据对象，另一
指针并不了解这种情况，它仍指向不再有效的目标数据对象，导致
空悬指针
示例：free( p ); p = NULL; // q 为空悬指针，仍指向原处
//碰到这种情况，你一旦再尝试使用q去访问它的目标数据对象的时候程序就崩掉了，q这个指针就空悬了。
```

解决方案：

```c
确保程序中只有惟一一个指针拥有目标数据对象，即只有它负责目标数
据对象的存储管理，其它指针只可访问，不可管理；
若目标数据对象仍有存在价值，但该指针不再有效，此时应进行所有权移交；
在一个函数中，确保最多只有一个指针拥有目标数据对象，其它指针即
使存在，也仅能访问，不可管理；
如果可能，在分配目标数据对象动态内存的函数中释放内存，如 main 
函数分配的内存在 main 函数中释放（在哪一个函数内部分配的这段动态内存，那么就在哪个函数内部销毁它），//如果做不到这一点，那么就应该把这一段分配出来的内存把它的所有权转移给我们主调函数中对应的指针,如果在主调函数里仍然不能够销毁它，那么这个所有权还必须进一步地向主调函数的主调函数转移，一直转移到main函数，如果main函数还不销毁它，main函数结束的时候操作系统会全部销毁它。
退一步，如果上述条件不满足，在分配目标数据对象动态内存的函数的
主调函数中释放内存，即将所有权移交给上级函数

//这个所有权移交的过程，是要由内部最底层的函数一层一层地向它的主调函数上去移交的，所以用8个字总结：级级上报，层层审批
```

如果你不销毁，就应该做到8字总结，做不到这条，那么这个指针就会出问题，很重要的一个地方就是内存泄漏。

#### 内存泄漏与垃圾回收

你弄了一个函数，分配了一个动态内存区域，然后函数结束了，那个指针死了，动态内存分配区域呢你忘了销毁，没有任何一个指针指向它了，它那个区域又没有名字，那么它就会变成一个无主之物。无主之物的结果就是出了一个垃圾，对于内存来讲，就变成了内存泄漏，那片内存区域，操作系统已经分配给你了，你的程序本来可以用的，但是你没有任何一个机制可以访问它了，指针没了嘛，所以那个地方明明给了你，但是你不能用，就相当于内存那个地方被挖了一个洞一样。

```c
示例：
void f(){ int * p = new int; *p = 10; }
函数 f 结束后，p 不再存在，*p 所在的存储空间仍在，10 仍在，但没
有任何指针对象拥有它，故不可访问
//问题的实质：动态分配的内存必须动态释放，函数本身并不负责管理它
```

**垃圾回收机制：系统负责管理，程序员不需要主动释放动态分配的内存，Java有此功能，C 语言无**，C++也无。你可以自己写，但是效率可能不高。

垃圾回收机制有个巨大问题是：**垃圾回收机制在需要时效率很差，而不需要时效率很好**

### 6.引用

**和指针不一样**

#### 引用的定义

定义格式：数据类型& 变量名称 = 被引用变量名称；
示例：int a; int & ref = a;

> 定义引用的表示方法与定义指针相似，只是用&代替了*。引用（reference）是c++对c语言的重要扩充；
>
> 引用说明：
> 　　（1）&在此不是求地址运算，而是起标识作用。
> 　　（2）类型标识符是指目标变量的类型。
> 　　（3）声明引用时，必须同时对其进行初始化。
> 　　（4）引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。
>
> 学习的《面向对象的嵌入式软件开发》一书中做出了如下解释：
> 引用和const修饰的变量很相似。实际上，C++编译器在编译的过程中**使用常指针作为引用的内部实现**，即指向位置不可变的指针。因此引用所占用的空间大小与指针相同。从我们使用的角度看，引用会让我们误会它只是一个别名，没有自己的存储空间。这是C++为了使用性而做出的细节隐藏。

引用的性质：

引用类型的变量不占用单独的存储空间
为另一数据对象起个**别名，与该对象同享存储空间**

特殊说明
引用类型的变量**必须在定义时初始化**，除非引用类型的量作为函数参数；
此关联关系在引用类型变量的整个存续期都保持不变
对引用类型变量的操作就是对被引用变量的操作

> 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起；
>
> 初始化常量引用时允许用任意表达式作为初始值

**引用的最大意义：作为函数参数**

前面我们谈到“&”和“*”是可逆的，那是指针，这里是引用，不可逆。

```c++
函数原型示例：void Swap( int & x, int & y );
函数实现示例：
void Swap( int & x, int & y ){
int t; t = x; x = y; y = t; return;
}
函数调用示例：
int main(){
int a = 10, b = 20; Swap( a, b ); return 0;
}
//在Swap函数内部，x就是main函数里面变量a的别名
//它最大的好处就是将主调函数中的两个量a、b把它们引入到Swap这个函数的名空间，换了一个名字访问它。可以直接修改我们的实际参数的值，而不是像指针那样修改指针所指向的目标对象的值
```

#### 引用作为函数返回值

常量引用：仅能引用常量，不能通过引用改变目标对象值；引用本身也不能改变引用对象(**也即自己不能变，也不能通过引用改变被引用对象**)

> **常量引用的定义方式：int b;const int &a =b;或者int b;int const &a=b;** 
>
> 对引用来说，引用的类型必须和其引用对象的类型必须一致，但常量引用只要求其返回的结果能转换成引用的类型。
>
> 常量引用只有2种情况会**绑定到实际的对象**:一是常量引用的初始值为const对象,且该对象类型与常量引用类型相同(如const int i ; const int &r = i;);二是常量引用的初始值为非const对象,且该对象也与常量引用类型(除去const的类型)相同(如int i; const int &r = i;)

引用作为函数返回值时不生成副本

```c
函数原型示例：int & Inc( int & dest, const int & alpha );
函数实现示例：
int & Inc( int & dest, const int & alpha ){
dest += alpha; return dest; }
函数调用示例：引用类型返回值可以递增
int main(){
int a = 10, b = 20, c; Inc( a, b ); c = Inc(a, b)++; return 0;
}
```

其重要性不仅仅于此，当我们想重载输出操作符的时候，你就能看到引用为什么那么重要，没有引用，新的面向对象的那种架构是非常非常难以实现的，

补充知识：形参中使用常量引用，常量，普通引用的区别

```c++
C++中的引用，给我们提供了一种区别于C指针的形参定义方式。一般我们可以将其定义为

1）普通引用

void foo(int &n);

2）常量

void foo(const int n);

3）常量引用

void foo(const int& n);

//三种方法用途不一样，都可以通过编译。
```

以普通引用为形参的函数，一般会更改实参的值，比如increment(int &n)等；**以常量以及常量引用为形参的函数，一般不对实参进行修改**。需要注意的是，当函数的功能确定后，不能把常量引用和普通引用混淆，虽然编译可以通过，运行也没有错误，但是会对函数的安全性以及功能造成影响：

1）如果一个本该是常量引用的形参定义成了普通引用，那么程序员会误认为这个形参可以修改。而且，在调用该函数的时候，会产生意想不到的错误。比如：

```c++
int getSize1(string &str){
    return str.size();
}
int getSize2(const string &str){
    return str.size();
}
void main(){
    getSize1("helloworld");//报错
    getSize2("helloworld");//正确
}
//显然，getSize2才是符合正常函数思维的实现。
```

2）常量引用为形参时，形参指向实参的空间，而常量为形参时，编译器会给形参重新分配空间。

```c++
void foo1(const int n){
    printf("%x\n", &n);
}
 
void foo2(const int &n){
    printf("%x\n", &n);
}
int main(int argc, char *argv[]){
    int n = 1;
    printf("%x\n", &n);
    foo1(n);
    foo2(n);
    return 0;
}
 
//输出：
//e25f58cc
//e25f58ac
//e25f58cc
```

## 八.链表与程序抽象

### 1.数据抽象

1）数据抽象的目的与意义

程序中的数据对象在C++里面有四个主要特征：VANT（值、地址、名称、类型），在真实的程序中最终只会留下两个---地址和值。N、T在程序运行的过程中就消失了。那么它就对我们的程序带来一个巨大的问题，就是我们真实编程的时候所希望所表达的那些信息或意义，有一些东西就没了。这个东西我们称为信息缺失。

解决这个问题的主要手段就是**抽象**

数据抽象最重要的地方就是：第一，怎么表示我们的数据，前面讲过，我们要用注释、**有意义的数据对象名称**来表示数据；第二、在我们的程序代码中应该在算法的关键处，对于特殊的数据结构的使用、对于特殊类型的使用要给出注释。这些都能够让我们**在源代码级别保持数据对象的意义**，这是一个非常重要的地方。

虽说这样的保持在编译成可执行文件以后它这个信息就没了，但是在源代码级别它能够让我们保持数据的意义。

2）结构化数据类型的性质

类型

​	细节由用户自定义，语言只给我们提供技术手段

成员

​	结构化数据类型的子数据对象

成员类型

​	每个成员具有确切的类型

成员数目

​	部分结构化数据类型可变，部分固定

成员组织

​	成员组织结构（线性结构或非线性结构）必须是显示定义

操作集

​	每个结构化的数据类型都会有一个可以和它相适应的操作集

3）数据封装

数据封装：将数据结构的细节隐藏起来

实现方式：分别实现访问数据成员的存取函数

数据封装示例：

```c++
struct DYNINTS{
 unsigned int capacity;
 unsigned int count;
 int * items;
 bool modified;
};
//动态数组
//平常访问count时使用.操作符，但是如果把count改为num_of_element，那整个程序需要很多修改，特别是如果给别人使用了你的库，他们的程序也需要大量的修改
//这是一个非常不好的设计方式，那么我们就想一个办法，就是提供一个函数，我为你实现一个函数的接口DiGetCount，用这样的函数来获取动态数组的元素个数
unsigned int DiGetCount( DYNINTS* a )
{
 if( !a ){ cout << "DiGetCount: Parameter illegal." << endl; exit(1); }
 return a->count;
}
```

我们希望通过一个技术手段，能够将整个程序分解成很多个库，并且这些库的修订、升级、改变这样的操作只要在接口不变的情况下不影响其它的库或者库的使用者，数据封装就是一个最重要的概念。

你不把细节藏起来，就没法保证这个库和其它的库是隔离的。我们怎么实现这样的数据封装呢？就是要对结构体里面的数据成员提供相应的存取函数。

4）信息隐藏

**数据封装的问题**

你如果只有数据封装这个是不够的，我们假设实现那个结构体，你也提供一系列的存取函数，把数据已经封装起来了，这实际上是暗示这个库的使用者，就是如果你想访问结构体里面的成员，你该使用相应的存取函数而不是直接访问成员的名字。这样的话数据才能封装起来。但是只有这些是不够的，因为struct这个结构体类型，它是设计并没有限定用户不能访问它的数据成员，虽然有了接口函数，可是你不能限制不使用这个函数而直接访问那个count成员，也就是说，对库的使用者来讲，他可以在DiGetCount函数的调用和直接访问那个count字段之间自由地切换，你没有办法限定他只能使用存取函数。

所以问题就是：只要将结构体类型定义在头文件中，库的使用者就可以看到该定义，并按照成员格式直接访问，而不调用存取函数

**解决方法**

将结构体类型的**具体细节定义在源文件中**，所有针对该类型量的操作都只能通过函数接口来进行，从而隐藏实现细节。

数据封装和信息隐藏合在一起才是我们编写抽象程序的关键，这是最重要的两个核心概念：数据封装、信息隐藏。

信息隐藏示例

```c++
/* 头文件“dynarray.h”*/
struct DYNINTS; typedef struct DYNINTS * PDYNINTS;
//要保证调用者能够正确使用这个结构体，那么就会在头文件里给出这个结构体的声明，并且提供一个指向这个结构体的指针，我们保证只使用这个指针来操纵它的目标结构体的数据对象。
/* 源文件“dynarray.cpp”*/
struct DYNINTS{
 unsigned int capacity; unsigned int count; int * items; bool modified;
};
```

5）抽象数据类型

```c++
设计能够存储二维平面上点的抽象数据类型
/* 点库接口“point.h”*/
struct POINT;
typedef struct POINT * PPOINT;
//注意：因为我们的目标结构体的定义是未知的，那么实际上这样的PPOINT型虽然可以在函数原型里面使用，但是我们实际上不能使用它的目标结构体的任何内部信息
PPOINT PtCreate( int x, int y );//返回值为struct POINT类型的指针，
void PtDestroy( PPOINT point );
void PtGetValue( POINT point, int * x, int * y );
void PtSetValue( PPOINT point, int x, int y );
bool PtCompare( PPOINT point1, PPOINT point2 );
char * PtTransformIntoString( PPOINT point );
void PtPrint( PPOINT point );
```

```c++
/* 点库实现“point.cpp”*/
#include <cstdio>
#include <cstring>
#include <iostream>
#include "point.h"
using namespace std;
static char* DuplicateString( const char* s );
struct POINT{ int x, y; };
PPOINT PtCreate( int x, int y )
{
 PPOINT t = new POINT; t->x = x; t->y = y; return t;
}
void PtDestroy( PPOINT point )
{
 if( point ){ delete point; }
}
```

```c++
void PtGetValue( PPOINT point, int * x, int * y )
{
 if( point ){ if( x ) *x = point->x; if( y ) *y = point->y; }
}
void PtSetValue( PPOINT point, int x, int y )
{
 if( point ){ point->x = x; point->y = y; }
}
bool PtCompare( PPOINT point1, PPOINT point2 )
{
 if( !point1 || !point2 ){ cout << "PtCompare: Parameter(s) illegal." << endl; exit(1); }
 return ( point1->x == point2->x ) && ( point1->y == point2->y );
}
void PtPrint( PPOINT point )
{
 if( point ) printf( "(%d,%d)", point->x, point->y );
 else printf( "NULL" );
}
```

```c++
char * PtTransformIntoString( PPOINT point )
{
 char buf[BUFSIZ];
 if( point ){
 sprintf( buf, "(%d,%d)", point->x, point->y );
 return DuplicateString( buf );
 }
 else return "NULL";
}
char* DuplicateString( const char* s )
{
 unsigned int n = strlen(s);
 char* t = new char[n+1];
 for( int i=0; i<n; i++)
 t[i] = s[i];
 t[n] = '\0';
 return t;
}
```



### 2.链表

#### 基础概念

链表的意义与性质：

存储顺序访问的数据对象集
数据对象占用的存储空间总是**动态分配**的

链表的定义：

元素序列，每个元素与前后元素相链接

结点：链表中的元素，一个NODE包括两个字段（两个域），一个叫数据域一个叫链接域，我们用data和next来表达；

实际上你在设计这个链表的过程中，你的data字段是有可能很多个域，你的数据可能很复杂，在这样的一个链表中为了维持数据之间的关系，需要一个表头结点和一个表尾结点，用head和tail表示，**head和tail分别指向头尾结点，没有data字段**；

表头、表尾：链表的头尾结点；
头指针、尾指针：指向表头、表尾的指针。

那么这样的链表数据结构，正常情况下面，如果想要符合数据封装和信息隐藏的基本要求的话，那么我们就需要通过这样的两个域--data域和next域来分别描述它的数据字段和链接字段。

假设定义的这个链表是用来表达前面的点结构体的，所以在这样的链表中，每一个结点都包含两部分

```c++
struct NODE; 
typedef struct NODE * PNODE;
struct NODE{
	PPOINT data; /* 当前结点的存储数据 */
	PNODE next; /* 指向下一结点，表尾此域为 NULL */
};
//注意在这个结构体类型的定义中，它里面有一个成员为指向结构体的指针，这是允许的，你如果让它的next字段为struct NODE类型的成员，那么这样的定义就涉及到了结构体的递归定义，这是不允许的。因为它没有办法决定这个结构体的存储空间的大小，而如果是指向本结构体的一个指针，这就是合法的，因为每一个指针存储空间的大小都是固定的，不管它是指向别人还是指向它自身。所以它不影响struct NODE结构体的内存的分配和管理，所以就可以用指向本结构体的指针作为结构体的某一个特定成员类型。
```

**仅有这个链表结点数据结构是不够的**，还要为它定义整个链表的结构来管理所有的结点。

```c
链表结构：封装结点表示的细节
struct LIST; 
typedef struct LIST * PLIST; // 一个指向链表的一个指针PLIST
struct LIST{
	unsigned int count; /* 链表中包含的结点数目 */
	PNODE head, tail; /* 链表头尾指针 */
    //PNODE为指向NODE的指针类型，head和tail就为指向NODE的指针变量
};
```

特别说明：

结点总是动态分配内存的，所以结点逻辑上连续，物理上地址空间并
不一定连续；（因为没有办法规定malloc，没有办法规定new它们分配出来的存储空间一定是连续的）

时刻注意维护链表的完整性：一旦头指针 head 失去链表表头地址，
整个链表就会丢失；任一结点 next 域失去下一结点地址，后续结点
就会全部丢失；

单向链表、双向链表、循环链表、双向循环链表

单向链表的next域一般都设为NULL。

如果这个链表的最后一个结点（就是尾结点）不是NULL值，不是空值，而是指向这个链表的表头，就构成了一圈，就像我们自行车链条一样，这个就称它为循环链表。

#### 抽象链表接口

现在就使用数据封装与信息隐藏的技术手段来设计抽象的链表库

```c++
编写函数，实现链表的构造与销毁操作
PLIST LlCreate()
{
 PLIST p = new LIST;
 p->count = 0;
 p->head = NULL;
 p->tail = NULL;
 return p;
}
void LlDestroy( PLIST list )
{
 if( list )
 {
 LlClear( list );
 delete list;
 } }
//参数list实际上是一个指向struct LIST的指针，我们要销毁的就是那个struct LIST，目标数据对象；而这个目标数据对象有head指针和tail指针，尤其是head指针，它指向我们链表表头结点，而我们的链表结点都是struct NODE这样一个数据对象，而这样的数据对象又总是动态内存分配出来的，所以在我们销毁list所指向的链表目标数据对象之前，必须保证这个链表中所有的结点都已经被我们销毁了，如果你没有销毁链表中的全部结点，你就销毁了这个list所指向的struct LIST那个目标结构体，那么这个链表中全部结点都会丢掉，
```

```c++
void LlClear( PLIST list )
{
 if( !list )
 {
 cout << "LlClear: Parameter illegal." << endl;
 exit(1);
 }
 while( list->head )
 {
 PNODE t = list->head;
 list->head = t->next;
 PtDestroy( t->data );
 delete t;
 list->count--;
 }
 list->tail = NULL;
}
//data字段保存的是点的抽象数据，实际上保存的是指向POINT那个二维点的指针，所以在你销毁t所指向的表头结点之前必须调用PtDestroy(t -> data)，销毁这个data字段所指向的那个二维点的目标数据对象
```

链表头文件要包含“point.n”，list.cpp也要包含它，因为要使用PtDestroy来销毁t->data所指向的目标二维点。

**表头结点的删除**

表头结点从链表中抠出来，我们有临时指针t指向它，倒不担心内存泄漏，但是链表本身这个结点已经不存在了。

最后要递减链表的结点数目。

#### 结点的追加

操作步骤：

①动态构造一个新结点，用 t 指向它；

②使 t 的 data 域指向 point 参数指向的目标数据对象，next 域为NULL；

③如果链表的 head 域为 NULL，则说明当前链表中没有任何结点，将此结点作为链表惟一结点添加到链表中，此时简单将链表的 head 域与 tail 域设为 t 即可；

④否则，将当前尾结点的 next 域设为 t，即让其指向新结点；

⑤将链表的 tail 域设为 t，即将新结点作为链表尾结点；

⑥递增链表结点数目。

#### 结点的插入

表头插入的操作步骤：

①动态构造一个新结点，用 t 指向它；

②使 t 的 data 域指向 point 指向的目标数据对象，next 域为NULL；

③将 t 的 next 域设为 list 的 head 的值，即使得原链表首结点链接到 t 所指向的结点之后；

④修改链表首结点指针，使其指向新结点；

⑤递增链表的结点数目。

**③④的顺序不能变**，不然不是插入，而是替换了链表，新链表只有插入的这一个元素，原来的结点都丢了。

**注意**：不管是追加还是插入，在任何时候都要维持链表的链接关系不变

表中插入的操作步骤：

动态构造一个新结点，用 t 指向它；

使 t 的 data 域指向 point 指向的目标数据对象，next 域为 NULL；

从表头开始向后查找待插入位置的前一结点，用 u 指向它，例如若插入位置为 1，则用 u 指向 0 号结点；

将 t 的 next 域设为 u 的 next 的值，即使得原链表中位置 pos 处的结点链接到 t 所指向的结点之后；

将 u 的 next 域设为 t，**即将 t 指向的结点链接到 u 指向的结点之后**(后面）；

递增链表的结点数目

代码：

```c++
void LlInsert( PLIST list, PPOINT point, unsigned int pos ) {
 if( !list || !point )
 {
 cout << "LlInsert: Parameter illegal." << endl;
 exit(1);
 }
 if( pos < list->count )
 {
 PNODE t = new NODE;
 t->data = point;
 t->next = NULL;
 if( pos == 0 )
 {
 t->next = list->head;
 list->head = t;
 }
 else
 {
 unsigned int i;
 PNODE u = list->head;//存放头结点的地址，即指向头结点，0号结点，头指针
 for( i = 0; i < pos - 1; ++i )
 	u = u->next; 
    //下一个结点赋值给u，直到u指向pos-1
    //pos为1时u还是指向头结点，0号结点
 t->next = u->next;//t的next域指向2号结点
 u->next = t;//1号结点的next域赋值为t，
 }
 list->count++;
 }
 else //pos=list->count
 	LlAppend( list, point );
 
}
```

#### 结点的删除

表中或表尾删除的操作步骤：

使用临时指针 u 保存待删除结点前一结点的地址；

t 保存待删除结点的地址；

将 t 的 next 域赋给 u 的 next 域，这保证 u 跳过 t 指向下一结点；

如果t 的 next 域不再指向其他结点（t 指向的结点本身就是链表尾结点）则将链表尾结点设为 u；

释放 t 的 data 域所指向的目标数据对象；

释放 t 所指向的结点数据对象；

递减链表的结点个数。

```c++
void LlDelete( PLIST list, unsigned int pos ) {
 if( !list )
 {
 cout << "LlDelete: Parameter illegal." << endl;
 exit(1);
 }
 if( list->count == 0 )
 return;
 if( pos == 0 )
 {
 	PNODE t = list->head;
 	list->head = t->next;
     if( !t->next )
     	list->tail = NULL;
     PtDestroy( t->data );
     delete t;
     list->count--;
 }
 else if( pos < list->count )
 {
     unsigned int i;
     PNODE u = list->head, t;
     for( i = 0; i < pos - 1; ++i )
         u = u->next;
         t = u->next;
         u->next = t->next;
     if( !t->next )
     	list->tail = u;
     PtDestroy( t->data );
     delete t;
     list->count--;
 } }
    
```

#### 链表的遍历

#### 链表的查找

#### 上述链表设计中存在的问题

链表要存储点数据结构，就必须了解点库的接口；

这个抽象链表库，不能保存其他数据对象，只能保存二维点，如果你想保存其它东西，比如三维点，比如一个复数，那么你必须重新写一个抽象链表库，也就是说，像这样一个链表，它事实上是不抽象的。

如果你要想存储目前还没有实现的数据结构，那怎么办呢？那更糟了，这个头文件你包含不了，你压根就没有办法做，所以还是刚才那句话，现在实现的抽象链表实际上不是抽象的。从某种程度上来讲，像这样一个链表实际上是用来存储其它数据对象的，我们习惯上称它为一个容器，一个container，一个容器理论上应该是抽象的。

### 3.函数指针

在讨论如何编写更抽象的链表库之前，我们还需要补充一个知识点：函数指针。

函数指针的目的与意义：抽象数据与抽象代码

​	---数据与算法的对立统一

数据结构和算法从某种程度上来讲，是一个辩证统一的，他们既对立又统一，有了函数指针这个概念之后，数据和算法就能统一起来。如果没有它，它们就是对立的，有了它，两者就可以统一起来。

为什么能够做到这一点呢？最主要的一点，我们来看执行一个函数，我们怎么执行它，我们需要知道这个函数的入口地址，对于我们计算机系统结构来讲，只要知道这个函数的入口地址，实际上就知道这个函数第一条指令该怎么去做，只要知道它第一条指令怎么去做，那么这个函数就能够做下去，第一条做完第二条、第三条...如果有跳转，就跳转到指令的指令，当所有的指令都做完，它有个return语句，它能够返回给它的主调函数，这是很明确的执行流程，这也就是说，对于一个函数的执行过程来讲，函数的入口地址是个关键的地方，入口地址那也是地址啊，它和我们数据的地址有差别么？没差别！它放在我们计算机的内存条里，不管是数据还是代码，那个编号是统一编址的，所以说数据的地址也好，算法和函数的地址也好，对于我们计算机系统结构来讲，两者是无差别的，这就暗示着我们能不能够将一个函数的入口地址也保存起来呢？当然可以，这个就是函数指针，指向一个函数的指针。

```c++
函数的地址：函数入口位置，将该数值作为数据保存起来，就可以通过特殊
手段调用该函数
typedef void * ADT; 
typedef const void * CADT;
//对于一个指针来讲，不管它指向哪一种类型，指针的数据地址它实际上存储空间是固定的，所以事实上它可以表达指向任意类型对象的数据的这样一个概念，它既然可以表达任意对象的地址，就可以代表着任意类型的对象。到了这里，我们就很明确了，哑型指针它将充当我们抽象数据类型的概念。
```

当我们想把前面的抽象的链表和它所存储点的数据结构完全给割裂开的时候，那么就必须保证抽象的链表数据结构里面不能有对抽象的点库的任意函数的调用，也不能使用点库中定义的任意的类型，这样才能让他们完全的独立开，那么我们怎么指代抽象链表里节点里面的data字段？哑型指针，前面的代码用的是point * ，现在把它替换成void * 。这就意味着我们的抽象链表中将不再保存指向一个点的结构体的一个指针，而是指向一个哑型的指针。

特别注意，ADT作为一个指向void类型的一个指针，并不意味着它的目标数据对象是一个“无”的类型的一个概念，它仅仅意味着我们的目标数据对象类型是未知的，我不知道它的具体类型是什么。我们只知道有一个指针指向一个目标数据对象。**这样就完成了一个通用性的编程**。这就是抽象数据类型的根本意义之所在。

```c++
函数指针的定义格式
数据类型 ( * 函数指针数据对象名称 )( 形式参数列表 );
示例：
char * ( * as_string )( ADT object );
函数指针变量的赋值
// 这个变量的类型很特殊，它指向一个函数，那个函数有一个ADT 类型参数返回值是 char * ，凡是这样的函数它都能指向。这就意味着凡是具有这样特征的函数都可以把它的入口地址赋值给as_string 作为它的值！
    
// 函数指针变量可以像普通变量一样赋值;可以被赋值，可以赋值给别人
函数指针数据对象名称 = 函数名称;
char * DoTransformObjectIntoString( ADT object )
{ return PtTransformIntoString( (PPOINT)object ); }
as_string = DoTransformObjectIntoString;
```

#### 函数指针的使用

**通过函数指针调用函数**

函数指针被赋值后，即指向实际函数的入口地址；
通过函数指针可以直接调用它所指向的函数（通过引领操作符，引领完它就是那个目标函数了）。

```c++
调用示例：
 char * returned_value;
 PPOINT pt = PtCreate( 10, 20 );
 as_string = DoTransformObjectIntoString;
//把这个函数入口地址赋值给as_string之后，就可以像普通的函数一样调用as_string，你就可以认为as_string就是那个对应的实际函数

returned_value = as_string( (ADT)pt );//第一个小括号表示函数调用
//因为as_string需要带的是ADT类型的参数，而不是PPOINT类型的参数，而我们实际上是PPOINT类型的对象，要传进去，所以要把它转换成ADT，在它的内部，DoTransformObjectIntoString这个函数内部还要把pt从ADT类型再重新转换成PPOINT，然后才能去操作，中间这两步转换其实都是必要的。
要区分函数指针调用和函数直接调用，使用下述格式调用函数指针指向的函
数：
 returned_value = ( *as_string )( (ADT)pt );
//严格来讲，as_string实际上是一个指针，你要想访问他的目标数据对象或者它的目标函数，需要使用引领操作符，其实标准格式就应该这么写： *as_string引领它的目标数据对象，这是一个函数，然后调用函数；
//第一个小括号对必不可少，如果没有这个小括号对，那就相当于as_string就是一个函数，然后调用，因为它是一个函数指针，那么你还可以调用，没问题，as_string就调用这个函数指针变量所指向的那个目标函数DoTransformObjectIntoString，然后去做点的转换，转换完以后它会返回一个字符串指针，前面用“*”去引领，返回那个目标字符串，实际上得到返回的目标字符串的0号字符，然后你想赋值给returned_value就出现赋值不兼容，把字符赋值给一个字符串，编译器就报错！
```

#### 实例

```c++
设计程序，随机生成 8 个 10~99 之间的整数，调用 stdlib 库的
qsort 函数对其进行排序
    
qsort 函数原型
void qsort( void * base, unsigned int number_of_elements,
 unsigned int size_of_elements,
 int ( * compare )( const void *, const void * ) ); 
// 第一个参数表示我们需要排序的数组的基地址；
//第二个参数表示数组的元素个数；
//第三个参数表示数组中每个元素所占的存储空间的大小，以字节为单位；
//第四个参数就是一个函数指针，它用于比较两个数据对象的大小关系。
//这个原型实际上是非常复杂的，但是三行就写完了，因为这里使用了一个函数指针变量来作为函数的形式参数，这个是非常非常常见的一个编程设计技巧。一定要会用！

调用时需按照下述格式实现自己的比较函数
 int ( * compare )( const void *, const void * );
//e1、e2可以省略，什么意思呢？我们将比较两个数据对象的大小关系，而这两个数据对象我们将作为函数的参数传给compare，也就是说compare在比较两个数据对象大小关系的时候，这两个数据对象本身对它而言是已知的，我们实际上并没有传递那两个数据对象，而是传递指向那两个数据对象的指针，因为我们不允许你在compare这个函数里面通过指针修改目标数据对象的值，所以这两个指针所指向的目标数据对象都定义成了const void 而不是 void。

当你想使用qsort函数的时候，你必须定义一个自己的比较函数，这个比较函数还必须按照如下格式来。你必须按照像这样的一个格式来定义compare所指向的那个目标比较函数。
比较函数示例
int MyCompareFunc( const void * e1, const void * e2 );

比较函数必须返回正负值（一般为正负 1）或 0 ，规则按照题目要求自定义
```

补充：qsort什么时候实现的呢？已经很有一些年头了，在C标准库出来的时候它就有了，那个时候实现这个qsort的那个程序员他知道你用它来对什么类型的数组进行排序吗？他当然不知道，也许是个整数数组也许是个浮点数组也许是个结构体数组（**数组的每个元素都是一个结构体**），如果是结构体数组，那显然是你定义的结构体，这个结构体是什么样子，他几十年前怎么能够知道呢，他是不可能知道的。他不知道你未来才会实现的结构体，那么他哪里能够进行大小排序呢。当他实现qsor函数的时候，当他需要对未来才会实现的一个数组进行排序的时候他显然没有办法决定这两个元素之间的大小，在他不能够决定这两个元素大小关系的情况下面，他又想实现qsort函数，那么他只好把这部分悬而未决的东西留待实现数据结构的程序员来去做，因为这个函数你没实现你就不能直接调用它，**那么就只能通过函数指针来调用它**。这个就是函数指针最重要的应用场合。就是**作为另外一个函数的形式参数**。

```c++
#include <iostream>
#include <cstdlib>
using namespace std;
#include "arrmanip.h"
#define NUMBER_OF_ELEMENTS 8
int DoCompareObject( const void * e1, const void * e2 );
int main()
{
 int a[NUMBER_OF_ELEMENTS];
 GenerateIntegers( a, NUMBER_OF_ELEMENTS );
 cout << "Array generated at random as follows: \n";
 PrintIntegers( a, NUMBER_OF_ELEMENTS );
 qsort( a, NUMBER_OF_ELEMENTS, sizeof(int), DoCompareObject );
 cout << "After sorted: \n";
 PrintIntegers( a, NUMBER_OF_ELEMENTS );
 return 0;
}
int DoCompareObject( const void * e1, const void * e2 )
{
 return CompareInteger( *(const int *)e1, *(const int *)e2 );
 // 我们必须把e1和e2转换成const int * 之后，才能去引领；你不能先引领后转换，你先引领 * e1，它实际上表示什么呢，表示const void，然后你想把它转换成const int ，这事不能做，因为void类型和const void类型的量它不能参与实际的操作，你想访问它这事非法的，类型未知。
}
```

函数指针的赋值

同类型函数指针可以赋值，不同类型则不能赋值（即指针可以赋值给指针）
如何确定函数指针类型是否相同：函数参数与返回值不完全相同

函数指针类型：用于区分不同类型的函数指针
typedef int ( * COMPARE_OBJECT )( const void * e1, const void * e2 );

前面添加 typedef 关键字，保证 COMPARE_OBJECT 为函数指针**类型**（表示类型的时候我们全部大写），而不是函数指针**变量**

可以像普通类型一样使用函数指针类型定义变量：

```c++
COMPARE_OBJECT compare = DoCompareObject;
qsort 函数的简明书写方法
void qsort( void * base, unsigned int number_of_elements, unsigned int
size_of_elements, COMPARE_OBJECT compare );
```

### 4.抽象链表

qsort函数里它有一个函数指针类型的形式参数，那个函数指针指向的那个函数我们就称它为回调函数。

#### 回调函数

允许通过函数指针调用未来才会实现的代码，这个就叫回调函数；

示例：DoCompareObject

凡是回调函数它都会需要依赖后续的设计，否则你不知道它调用哪一个。你传哪个函数的入口地址给它，它就调用哪一个对吧。而这个函数本身还是你未来才会实现的，就相对于qsort那个函数的设计和编写的那个实现而言，DoCompareObject这个函数实现是远远在它未来之后，所以对qsort来说它会调用你未来才会实现的DoCompareObject替你排序未来才会实现的数组，qsort本身只能完成排序的基本动作，它不知道你的数组是什么样子，它只知道你的数组的入口地址在哪里，你的数组里包含多少个元素，你的数组每个元素的尺寸是多少，所有这些还是你在调用qsort的时候告诉它的，其次它也不知道怎么比较元素的关系，怎么比较也是你告诉它的。你写一个比较函数，把这个函数的入口地址给它，它就调用你的函数，替你比较你的数据，**这是非常重要的一个设计**。回调函数的作用就体现在这里！

**回调函数参数**

有的时候我们需要在回调函数和主调函数之间产生一个很特殊的信息的交互，这种东西我们称它为附加的信息，那传多少个呢？

我们有一个通用型的数据抽象类型，void * ，ADT嘛，就用它来表达这个附加的参数，如果传的附加信息是一个，我们就直接传这个附加信息或这个附加信息的地址，如果这个附加信息和void * 尺寸刚好一样，你就不用传它的地址了，直接传它就可以了。附加信息如果是一个，很典型，我用一个ADT代替它，如果附加信息是两个或者多个呢，就把附加信息做成一个结构体，然后传那个结构体的地址，转换成ADT。所以一个ADT事实上就可以传递所有的东西。

如果我们使用这个链表来保存的是一些整数，实际上是可以把这个int直接转换成void * （在32位系统和编译器下两者尺寸一致）就存在data字段里，这个时候我们的data字段它并不指向任意的有意义的存储区，它其实原始意义就是一个整数，结果被我们当成void * 存在data字段里面了，所以在这种时候，如果我需要销毁这个链表的结点，那么data字段是不需要去管理它的，也就是说这个时候你是不可以销毁data字段所指向的那个目标数据区域的，那个并不是我们真正内存分配出来的存储区域，所以当我们设计抽象链表的时候就需要考虑到这一点。

**数据对象的存储与删除**

删除链表结点时，其中的目标数据对象是否需要删除？

**如果链表结点存储的是指针，就需要删除；否则不需要**

**设计抽象链表时，并不了解结点实际存储的数据是否为指针，因而无法确定结点数据操作逻辑**。这点特别需要注意。

#### 实例

当我遍历链表的时候我只知道我要做一件事，但是这件事情具体做什么，其实我不清楚，至少我在实现这个函数的时候还不清楚，也就是说有些信息在我实现这个函数的时候是未知的，怎么办呢？凡是未知的东西都应该用量来代替，就像我们使用量来代替一个具体的数一样，你不知道那个数是什么，没关系，我们操纵的是这个量，你不知道操作是什么，没关系，我们使用一个函数指针，就这个意思。

所以我们使用一个回调函数来提供这个结点数据的具体的操作方法。

```c++
编写函数，遍历链表，结点数据的具体操作方法目前未知，由未
来的回调函数提供
typedef void ( * MANIPULATE_OBJECT )( ADT e );
void LlTraverse( PLIST list, MANIPULATE_OBJECT manipulate )
// 注意：平时我们用参数的名字，不管形式参数还是实际参数的名字还是变量的名字，我们平时都使用名词对吧，这个bool量偶尔会使用形容词，在这里，我们使用的是动词，因为它是函数指针类型的变量。所以它往往代表一个动作，所以我们使用一个动词，这是可以的。
{
 PNODE t = list->head;
 if( !list )
 {
 cout << "LlTraverse: Parameter illegal." << endl;
 exit(1);
 }
 while( t )
 {
 if( manipulate ) /* 通过函数指针调用实际函数操纵目标数据对象 */
 ( *manipulate )( t->data ); 
 t = t->next;
 } }

// 因为我在LlTranverse这个函数里提供了一个回调函数，这实际上就意味着我们这个LlTranverse可以在遍历的时候执行你想要它做的操作，你想要它打印，你就写一个打印函数作为实际参数传给LlTranverse，让manipulate指向这个打印函数，它就会打印；如果你想求和，那么你写一个求和的函数传给manipulate。
//按照这样的程序设计，LlTranverse这个函数它的适用性显然要比之前那个方式要灵活得多，至少在LlTranverse函数内部没有对PtTransformIntoString函数的调用，这就意味着对LlTranverse来讲，它不需要知道PPOINT、点库的任何细节，管你是点库还是什么库，尤其是注意到，一旦形成一个抽象的链表库的话，那么我们的data字段它压根就不是PPOINT类型的，它是ADT类型的，完全把它抽象化了，你想用的时候把PPOINT转换成ADT，然后在内部再重新把ADT转换成PPOINT回去，它是按照这样的方式将链表库和点库完全给独立开来的。数据结构，他们互相不使用了，算法，它们互相之间也不使用了。这样不就独立了嘛，点库是点库，抽象链表库是链表库，这样我们的抽象链表库的应用场合也就不再局限于点库了。
```

#### 回调函数参数使用

```c++
typedef void ( * MANIPULATE_OBJECT )( ADT e, ADT tag );
/* 链表遍历函数 */
void LlTraverse( PLIST list, MANIPULATE_OBJECT manipulate, ADT tag )
{
 PNODE t = list->head;
 if( !list )
 { 
 cout << "LlTraverse: Parameter illegal." << endl;
 exit(1);
 }
 while( t )
 {
 if( manipulate )
 ( *manipulate )( t->data, tag ); 
 t = t->next;
 } }
//第三个参数ADT tag，LlTraverse并没有使用而是传给manipulate使用
```



```c++
/* 点数据到字符串的转换函数，最终程序员任意定义 */
/* 参数 format 表示点数据对象的转换格式 */
/* 其中只能包含两个格式码 %d，其他内容任意 */
/* 例如格式“(%d,%d)”或“[%4d, %4d]”等 */
char * PtTransformIntoString( const char * format, PPOINT point )
{
 char buf[BUFSIZ];
 //定义一个buf，缓冲区
 if( point )
 {
 sprintf( buf, format, point->x, point->y );
 //按照它的那个format传进来的格式生成它对应的字符串
 return DuplicateString( buf );
 //然后返回这个字符串
 }
 else
 return "NULL";
}
```

```c++
/* 回调函数 DoPrintObject */
void DoPrintObject( ADT e, ADT tag )
{
 printf( PtTransformIntoString( (const char *)tag, (PPOINT)e ) );
 //ADT转为相应的类型
 printf( " -> " );
}
/* 回调函数参数的意义 */
/* 调用遍历函数时将点数据的输出格式传递给遍历函数 */
/* 再由遍历函数传递给回调 */
LlTraverse( list, DoPrintObject, "(%d,%d)" );

//第三个为回调函数参数
//当你想“（%d，%d）”格式调用它的时候，那么你就按照这个格式(%d,%d)传一个字符串进去，这个就是它的第三个参数，附近参数。
```

---使用抽象的链表库存储我们抽象的点库，注意抽象的链表库是我写的，抽象的点库可能是张三写的，你呢，要使用我和张三写的那段程序代码来实现你的程序，那么当你想按照一个特定格式输出这些点信息的时候，我们就调用LlTraverse这个函数，传递抽象的链表，传递回调函数，传打印的格式。

注意："(%d,%d)"不能写在DoPrintObject里面，写进去那只能做小括号对了，不能做中括号对了[%d,%d]、尖括号对等。

所以可以看到：**用一个附近参数作为回调函数的主调函数和回调函数两者信息交互的一个关键点**。

**回调函数参数的重要意义**

程序的参与者：抽象链表的设计者、点库的设计者、最终使用前两者的第三方程序员。只有使用抽象链表库来存储点的那个程序员他才知道抽象链表库的接口是什么，点库的接口是什么，但是对应抽象链表库的实现是什么，点库的实现是什么，第三个程序员也一样不知道。他不需要知道，反正能用就行了对吧。抽象的目的就体现在这里，我让这些模块尽可能独立，你能用就行了，你压根就不需要知道它内部的实现细节。

所以总结其优势：**三者完全不了解其他人的实现细节**

**容器与容器中的对象**

抽象链表作为一个容器和容器中的一个对象我就把它独立开了、分离开了。

容器：能够容纳其他数据对象集合的东西

**两者完全无关，即容器与容器中容纳的数据对象完全独立，**这个就叫抽象。

**抽象链表事实上可以存储任意类型的数据对象**

#### 数据对象的存储与删除

在编写程序的时候需要特别注意的：

第一，你链表中的那个data域是不是一个指针？

第二，data域是否真正指向存在的目标数据对象？如果不指向怎么办？如果指向怎么办？是否需要指向一个真正存在的目标数据对象？这个目标数据对象是你动态分配的还是你静态分配的。这些都需要你在使用抽象链表库的时候明确的。

第三，如果节点要被删除的话，data域所指向的一个目标数据对象是否需要被删除？链表这节点被删除了，data域所指向的目标数据对象是不是需要删除。就像我们前面讲的，如果我是把一个int直接转换成void * 存在data域里面的，那我这个节点被删除的时候目标数据对象不存在，所以不需要删除。那个data字段它真的指向目标数据对象，当我删除这个节点的时候，那个目标数据对象是不是一定需要删除，虽然在大部分情况下真需要删除，但是并不意味着每次总是这样，并不意味着一定需要删除，**这个地方一定需要注意，编程的时候要非常小心**。

第四，如果需要删除，如何删除？

第五，抽象链表的设计者能不能完成这样的删除任务？如果能，你就删就行了。如果你不能，你怎么办？这点你写程序的时候要时刻注意到。

```c++
typedef void ( * DESTROY_OBJECT )( ADT e );
//销毁目标数据对象的一个函数指针类型，传递一个哑型指针ADT e，用来代表待销毁的那个目标数据对象的地址。
void LlDelete( PLIST list, unsigned int pos, DESTROY_OBJECT destroy )
//使用一个回调函数作为它的函数参数
{
 // ……
 if( pos == 0 )
 {
 // ……
 if( destroy )
 ( *destroy )( t->data );
 // ……
 }
 else if( pos < list->count )
 {
 // ……
 if( destroy )
 ( *destroy )( t->data );
 // ……
 } }
//destroy如果你传的是一个非0值，不是NULL的一个值，那么我们就调用destroy所指向的那个目标销毁函数，销毁它的目标数据对象。如果传了一个NULL，我就不销毁，很明确吧。
```

```c++
若需要删除目标数据对象，实现下述代码
void DoDestroyObject( ADT e )
{
 delete (PPOINT)e;
}
/* 调用 DoDestroyObject 函数释放 data 域指向的存储空间 */
LlDelete( list, 1, DoDestroyObject );

若不需要删除目标数据对象，实现下述代码
LlDelete( list, 1, NULL );
```

最后，我们的抽象链表库该怎么设计？

设计不依赖所存储的具体数据类型的抽象链表

```c
typedef struct LIST * PLIST;
typedef int ( * COMPARE_OBJECT )( CADT e1, CADT e2 );
typedef void ( * DESTROY_OBJECT )( ADT e );
typedef void ( * MANIPULATE_OBJECT )( ADT e, ADT tag );
PLIST LlCreate();
void LlDestroy( PLIST list, DESTROY_OBJECT destroy );
void LlAppend( PLIST list, ADT object );
void LlInsert( PLIST list, ADT object, unsigned int pos );
void LlDelete( PLIST list, unsigned int pos, DESTROY_OBJECT destroy );
void LlClear( PLIST list, DESTROY_OBJECT destroy );
void LlTraverse( PLIST list, MANIPULATE_OBJECT manipulate, ADT tag );
bool LlSearch( PLIST list, ADT object, COMPARE_OBJECT compare );
unsigned int LlGetCount( PLIST list );
bool LlIsEmpty( PLIST list );
```

作业1： **实现动态数组库**（学了操作符重载这个就更简单了）

作业2：**实现抽象链表库**

## 九.类与对象

### 1.程序抽象与面向对象

```c++
抽象数据类型：设计能够存储二维平面上点的抽象数据类型
/* 点库接口“point.h”*/
struct POINT;
typedef struct POINT * PPOINT;
PPOINT PtCreate( int x, int y );
void PtDestroy( PPOINT point );
void PtGetValue( POINT point, int * x, int * y );
void PtSetValue( PPOINT point, int x, int y );
bool PtCompare( PPOINT point1, PPOINT point2 );
char * PtTransformIntoString( PPOINT point );
void PtPrint( PPOINT point );
```

前面设计的程序代码有个小问题，问题在哪里呢？问题就在你只能定义指向这个结构体的指针，你并不能够定义这个结构体类型的变量。因为我们这个结构体的类型是未知的，我们仅仅声明了它，并没有定义它。所以你是不可以使用POINT这个结构体来定义变量的，你只能定义PPOINT类型的变量，也就是指向这个结构体的指针。也就是说，像这样一个库的接口使用其实是受限的。

 **类与对象的概念与意义**

接上面，第二，虽然我们将这个结构体的声明和这个结构体所能够具有的方法也就是它的行为实际上封装在一个抽象的点库里面，属性和行为从我们实现角度来讲，似乎是统一的。但我们其实并没有办法要求程序员对所有的库的结构按照一个特定的方式这样组织和使用，比如，他有可能把那个结构体的定义抽取出来然后放到了头文件里，这样的话他不就可以用了嘛。

我们按照这样一个实现完成了这样一个抽象库的表达，我们将它的属性也就是这个结构体所具有的数据的那些成员信息和在这些信息上边所能够进行的操作把它统一地封装在我们的源文件里，而在我们的接口上面只提供它的型的一个描述---一个简单的描述，而不是内部的实现细节，不是类型的实现细节，只有类型的简单描述，以及可以在这个型上所进行的一种操作。当然这里我们使用的是指向这个结构体的指针。我们希望达到的目标就是：**属性和行为的辩证统一**。每一个库都按照这样一个方法来实现，那我就会说在我们程序中结构体和结构体中所具有的方法，我们这个抽象的数据结构和我们数据结构上可以进行的操作集全部封装成了一个单一的库。可是在结构化的程序设计里面这样的属性和行为统一并不是特别的完美无缺。因为实际上，我们的操作集和我们的抽象数据结构仍然是分裂的，虽然我们表达在了同一个头文件里，这种分裂会导致用户也就是库的使用者在理解整个程序代码的时候出现问题，尤其当你把很多个这样的结构体混杂在一起的时候，很多个这样的抽象数据型封装在一个单一的库的时候，属性和行为上边就有可能在理解这个库的代码的时候会带来额外的负担。

所以说当我们想表达这个数据封装和信息隐藏概念的时候，如果你没有这样的一个类的概念，你就没有办法清晰的定义，这是我们前面特别谈到的。最重要的一个地方就是我们怎么才能够通过一种特殊的机制将这样一个抽象的数据类型的数据封装和信息隐藏很好的利用起来，同时又让它的属性和行为在语言的实现的概念上完成辩证统一，实现这一点就是面向对象技术。

**程序抽象**

－数据封装、信息隐藏

－如果没有类的概念，无法定义非指针量，且控制性不佳

**对象的概念与意义**

－量（对象首先要表达的一个概念就是量，它仍然是一个我们说的变量和常量）

－（这样的量和它的行为应该统一地组织在一起）同时增强对象行为的主动性（我们不是在一定对象上施加一个操作，比如将，我们的PtDestroy，我是要销毁一个特定的点，那么我们就要传那个点的指针给PtDestroy函数，这样的一个销毁动作从行为角度来讲，它实际上是被动的，因为我要传一个参数进去给PtDestroy函数，让PtDestroy负责销毁它，我们希望所表达的是这个对象的行为主动性，也就是说，我们希望是一个点对象它自己发出一个销毁动作，然后释放它自己。这个就叫**对象行为的主动性**。

这个思考方法和结构化程序的思考方法是有很大不同的：一个是被动性的思维，一个是主动性的思维；从程序设计这个角度来讲，一个是被动式的思维模式，一个是主动式的思维模式。

那么很自然地我们就想，如果我们有这样一个接口库

```c++
// 想象的代码，非C++标准实现
struct POINT
{
 int x, y; // 公开量，不符合数据信息隐藏规则
 // x和y两个数据成员
 Create( int x, int y );
 void Destroy();
 void GetValue( int * x, int * y );
 void SetValue( int x, int y );
 bool Compare( const POINT* point );
 char* TransformIntoString();
 void Print();
}
//当你使用一个struct结构体关键字来定义对象的时候，这里面所有的成员都是工开的，除非你限定它，否则他们都是公开的，x和y外界可见，你没有做到数据封装和信息隐藏，虽然能编译能运行。
```

那我们整个程序的架构就算相当完整了。我把这个点库所有的数据和它的操作集封装在一起，全都放在它的结构体的内部，这样的话不就完成了数据和代码它的属性和行为的有效地统一了么。我们想要的就是这样一个机制，这样的一个机制就叫面向对象技术。

### 2.类类型

我们需要的就是能够对程序的访问和控制加以限制的特殊数据结构。这样的特殊的数据结构我们就称它为类类型。

#### 类的声明与定义

类的声明：仅声明类的存在，没有提供细节

-关键字：class     -示例：class A;

这种声明我们俗称前置声明

类定义
－一般定义格式
－类成员：数据与函数
－三个保留字顺序任意
－public：其后成员公开
－protected：其后成员有限公开（在自己这个结构体或这个类的内部都是可以自由访问的，**但是外界想访问它是有一个限制条件的，只有这个类的派生类才能访问它**）
－private：其后成员私有，仅本对象可直接访问

**注意**：这个三个关键字定义的顺序没有要求，都可以放在前面，而且每一个关键字都可以出现很多次。C++语言规定，我们class定义的类类型里，没有访问控制的成员和成员函数（前面没有关键字）缺省是私有的，也就是缺省是private的。如果你使用struct关键字来定义类类型，那么缺省的这样的数据成员和成员函数就是public的。这是struct和class最重要的区别。

```c++
class A {
public:
 成员类型 成员名称;
protected:
 成员类型 成员名称;
private:
 成员类型 成员名称;
};
//public/protected/private:这样的控制规则，我们称它为访问控制，你把这个访问控制规则去掉，你就会发现这个类的定义和我们结构体的定义就没差别。实际上，在C++代码里面，使用struct一样可以定义类，它们唯一的差别就体现在它的访问控制上，尤其是它的缺省的访问控制上面，
```

#### 示例

```c++
/* 点类库接口“point.h”*/
class Point
{
public:
 Point( int x, int y );
 ~Point();
 void GetValue( int * x, int * y );
 void SetValue( int x, int y );
 bool Compare( const Point & point );
 char* TransformIntoString();
 void Print();
private:
 int x, y;
};
//我们将它的成员x和y完全定义为私有的，外界是不可以访问的，我即使把它写在这个点库里面，放在“point.h”这个头文件里，一旦包含了这个“.h”这个头文件，从理论上来讲，它就能够看到这个class定义里全部的细节，它实际上是能够看到这两个成员x和y的，但是因为访问规则的限制，导致在外界，也就是class Point这个类的外界，没有权利去访问它。
我们通过这点达到了数据封装与信息隐藏的目的。同时因为我们将这些数据成员和数据成员上面所应该具有的操作集，统一地封装在这个class Point这个类的内部，从而完美地实现了属性和行为的统一。为什么我们要引入面向对象，就是这个原因。
```

**圆类库**

```c++
设计表示二维平面上圆的类类型
/* 圆类库接口“circle.h”*/
class Circle
{
public:
 void GetOrigin( double * x, double * y );
 void SetOrigin( double x, double y );
 double GetRadius();
 void SetRadius( double r );
 double GetPerimeter();
 double GetArea();
private:
 double r, x, y;
};
```

```c++
/* 圆类库实现“circle.cpp”*/
#include "circle.h"
const double pi = 3.141592653589793;
void Circle::GetOrigin( double * x, double * y )
//怎么表达这个函数是从属于一个特定类的信息呢？使用类名加::，::为解析操作符。
{
 *x = this->x;
 *y = this->y;
 //为了区分我们的参数和我们的类的数据成员，所以C++给我们的对象提供了一个this指针；
 //this关键字它指代这个对象本身，这个对象在哪里呢？你这么想，当我这个程序在运行的时候，这个成员函数将会由某一个对象来发起，注意这个操作是主动性的，这个函数必须是在一个对象上调用，发起调用的那个对象当然是属于我们这个Circle类的，它是谁呢？我们就用this指针指向它。this指针也就代替了那个对象自身。
}
void Circle::SetOrigin( double x, double y )
{
 this->x = x;
 this->y = y;
}
```

**this指针：指向当前对象的指针，由系统自动定义**。



#### 关于类声明与定义的说明

```c++
仅限于函数原型使用类类型的声明
不能用于定义类的数据成员
示 例
class B;//类类型的前置声明，没有定义它
class A {
public:
	void func( B b ); // 正确
    //A类的成员函数可以带有B类的形式参数，你不能作为函数定义的参数，因为真正到函数定义就必须使用那个类的对象了，所以那个仅有类类型的声明是不够的，但在函数原型里面可以只有类类型的声明。
private:
	B b; // 错误
    //这一点是和函数实现里面那个形式参数一样，你是不能够定义它的数据对象的。因为你要定义这个数据对象，就涉及到对这个数据对象进行内存分配，而内存分配的模式实际上我们是不知道的，只有类的声明的不知道的，必须要有定义。所以类类型的声明是不能用于定义类的数据成员的。
};
class B{ … };
```

### 3.对象

怎么使用类类型来定义我们的对象

#### 对象的定义与使用

正常情况下边，我们用class定义的类和用struct定义的类和struct定义的结构体，在数据的存储表示上面，实际上是非常类似的。那么其实就可以像结构体一样，定义和使用对象。当然在外界只能使用对象的公开成员。

**对象的定义**

－像结构体一样定义和使用对象及其公开的成员

－私有成员不可在对象外部直接访问

```c++
对象示例
/* 源文件“main.cpp”*/
int main()
{
Circle circle;
circle.SetOrigin( 0.0, 0.0 );
circle.SetRadius( 1.0 );
 cout << "Perimeter: " << circle.GetPerimeter() << endl;
 cout << "Area: " << circle.GetArea() << endl;
 return 0;
};
```

补充：在早期的C++实现里面，其实是没有C++编译器的，这样的代码都要转换成C的结构。然后调用C的编译器来编译我们的程序。像这样的函数调用：circle.SetOrigin(0.0,0.0)它实际上将会转换成SetOrigin(this,0.0,0.0)，它会按照这样的模式来调到C的编译器来编译我们的程序。当然了，它有能够区分Circle类的SetOrigin和另外一个类的同样同名的函数，它能够区分这一点就可以了。this指针的重要性就体现在这个地方。

#### 对象的构造

**非常重要！！！**

从某种程度来讲，构造就是初始化。要创建一个对象，我们就是要构造这个对象，构造这个对象那么你就要给它设定一个初始的值。因为在内存里边分配一段存储空间，要存储这个数据对象，这个内存一分配出来，里面一定是有数据的，要么是有意义的数据，要么是无意义的位序列。如果你没有对它进行初始化，这就意味着这样一个对象一开始的值是不可信的，你不知道它是什么，从某种程度上来讲，构造的目的就是为了让这个对象在构造的一瞬间就应该具有一个**有意义的数据**。就是从这一点上来说，构造就是初始化。

```
在这点上我之前理解一直有偏差，这是个类对象，不是普遍的变量，不算int a = 10这种初始化，脑海中不要想成是 定义了一个A类，然后 A a = xx 这种初始化；类的对象在第一章就说到了它是属性和行为的集合，你对这样一个集合初始化说白了就是对其成员（属性）进行初始化，行为是操作是方法不需要初始化的。
```

> ---百度知道：你只要定义了对象，就会分配内存，不管有没有初始化。 没有初始化的变量的值是该变量所分配到的内存中的数据，是一个不确定的值。
>
> 没有加static，默认为auto 型，此时，不给初值，变量的初值是随机的；如果加了static不给初值，变量的初值是默认的 0。
>
> 不能说不赋初值就不行，对于局部变量，不赋初值的话，其实里面存的是一个随机的值，谁也不知道是多少。事实上，如果使用未初始化的局部变量，编译器一般会给出警告。

**对象构造的意义**

－构造就是初始化，其目的就是在**定义对象时初始化其数据成员**

**对象构造的技术手段：使用构造函数**

－与类类型同名，没有返回值类型（包括**void**类型），即名字前面啥都没有。

－构造函数允许重载

－**构造函数可以带缺省参数，但是不建议**（你在声明这个构造函数的时候可以为这个构造函数的某些参数定义一个缺省的值，就是当你没有传递这个参数的时候，编译器就自动地传递一个缺省的参数进去，实际编程不建议这样写，它会影响你判断这个构造函数真实的参数到底有几个，从源代码级别你是看不出来的，比如，如果一个构造函数有两个参数，它的第二个参数是缺省的，当你只传一个参数构造这个对象的时候，仅仅看它的源代码你实际上不知道这个构造函数到底是一个单参数的版本还是一个双参数的版本，如果你这个类同时还提供一个单参数的构造函数，两者就有可能混淆。不仅你会混淆，编译器也会混淆。另外，**如果带缺省参数，必须是这些参数列表中的最后几个**。

－**至少公开一个构造函数**（因为构造这个对象是在类的外部去做的，在程序运行的时候这个对象需要构造出来，它可能是在全局的堆里构造的，也可能是在函数的栈上构造的，也可能是动态构造的，不管哪种构造模式都需要在类的外部调用它的构造函数对这个类的对象进行初始化，所以说你要想在外界构造这个对象，那你必须公开一个构造函数，外界可用）。实际上，构造函数你写在public里可用，写在protected里也是可以的，写在private里也是可以的。但是你要想让外界能够构造这个对象必须至少公开一个构造函数。后面会讲到一个很特殊的例子，就告诉大家如果我有一个对象，我就不想从外界构造它呢？那么你就可以将它的全部的构造函数都写在private后面，让外界不能构造这个类的对象，**所以一般来讲至少公开一个构造函数，但并不绝对**。

－只能由系统在**创建对象时自动调用**，程序其他部分不能直接调用（从实现这个角度来讲，我们不能够在这个类的外部来调用它的构造函数吗？当然不是，有的面向对象语言就允许你主动地调用构造函数，但是对于C++代码来讲，它是不可以的）

```c++
设计表示二维平面上圆的类类型
/* 圆类库接口“circle.h”*/
class Circle
{
public:
 Circle();
 //Circle( double r, double x = 0.0, double y = 0.0 ); // 缺省参数，不建议
 Circle( double r, double x, double y );
 ……
private:
 double r, x, y;
};
```

```c++
/* 圆类库实现“circle.cpp”*/
Circle::Circle()
{
 r = 0.0, x = 0.0, y = 0.0;
}
Circle::Circle( double r, double x, double y )
{
 this->r = r, this->x = x, this->y = y;
}
/* 主程序“main.cpp” */
int main()
{
 double r = 1.0, x = 0.0, y = 0.0;
 Circle circle( r, x, y );
 //实际上C++编译器在看到这段代码的时候，它就会为我们分配一个Circle类的存储空间，也就是为我们定义好这个对象，然后会调用构造函数，将r、x、y三个值写进去。
 //即构造的时候同时初始化
}
```

> 定义对象时初始化的两种方式：
>
> ```c++
> ClassTest ct1("ab");  // 直接初始化
> ClassTest ct2 = "ab"; // 直接初始化
> // 使用第一种更好
> ```

如果类里面没有明确的构造函数，其实是可以的，如果你真的没有定义这个对象的构造函数，那么编译器会自动地为我们创建一个**缺省的构造函数**，并且自动调用，**缺省的构造函数本身是没有参数的，函数体里也没有任何代码，空的**！它什么都不做，就**只是自动地完成构造函数的逻辑。它其实就是分配好空间**。如果定义了构造函数，编译器就不再替你生成一个缺省的构造函数，所以如果你生成的构造函数是带有参数的版本，并且这些参数没有全部设置为缺省参数的话，那就意味着缺少一个不带参数的构造函数版本，某些时候可能会导致问题。

```c++
缺省构造函数调用示例
－正确示例：Circle circle;
//自动替我们调用缺省的构造函数
－错误示例：Circle circle(); 
－在构造函数无参数时，不能使用函数形式构造对象。原因？
  这在C++的编译器里是没法通过的
```

**拷贝构造函数**

拷贝构造函数用于构造已有对象的副本；（它将完成从一个对象拷贝到另外一个对象上的任务，拷贝构造必须要求已有对象才能创建它的副本）

拷贝构造函数单参数（它接受某一个对象进来，然后才能拷贝它），**接受的格式是固定的**必须是本类的某一个**常对象的一个引用**（比如如果是个Circle类，你传过来的应该是const Circle&，对const Circle类的对象的一个引用）；

如未定义，系统自动产生一个缺省拷贝构造函数；

**缺省拷贝构造函数为位拷贝**（浅拷贝，即把那个对象的**内存区域**一个字节一个字节完全地搬到另外一个对象里，不管那个字节里面的信息是什么意思，全部拷贝过去就行了，即只拷贝指针的四个字节，不拷贝字节所指向的数据对象），如需深拷贝（例如成员为指针），需自行定义。

> “浅拷贝”即将被拷贝对象的数据成员的值一一赋值给新创建的对象，若该类的数据成员中有指针成员，则会使得新的对象的指针所指向的地址与被拷贝对象的指针所指向的地址相同;

---为啥是浅拷贝呢，你想啊，如果我这一个类的数据成员中有一个指针，这个指针指向一个动态分配的目标数据对象，当我拷贝这个对象的时候，你是把那个指针所指向的目标数据对象拷贝到这个类的新副本里面去了呢还是仅仅是把那个指针的值拷贝过去了呢？浅**拷贝仅仅能够完成这个指针值的拷贝**，它不能够完成指针所指向的目标数据对象的拷贝。

> 如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。

```c++
/* 圆类库接口“circle.h”*/
class Circle
{
public:
 Circle( const Circle & that );
 ……
private:
 double r, x, y;
};
/* 圆类库实现“circle.cpp”*/
Circle::Circle( const Circle & that )
{
 this->r = that.r;
 this->x = that.x;
 this->y = that.y
```

在构造一个对象的时候，我们可以在构造函数的开头，也就是构造函数的头部定义它的初始化列表，基本的模式如下：

```c++
初始化列表的格式
class A
{
public:
 A( int a );
private:
 int a;
};
class B
{
public:
 B( int a, int b );
private:
 A a;
 int b;
};
A::A( int a ) : a(a)
{}
//(a)前面的a就是这个A类的那个成员的名字，括号里面的a就是构造这个对象的时候对它进行初始化的时候传给它的形式参数；即一个是成员一个是形式参数。
B::B( int a, int b ) : a(a), b(b)
{}
//a(a)这个两个参数可以名字不一样，这里不需要用this，写了编译器就通不过了，实际上编译器能知道这个名字a是写在小括号对里边还是在小括号对的前边，所以它就知道这个a就代表着这个类A中的成员还是它的形式参数。

```

**初始化列表的目的与意义**

－在构造对象时，**同步构造内部对象**

－**部分成员（常量与引用）只能初始化，不能赋值**

－部分成员（某个类的对象）如果赋值，将导致两次构造（因为你在构造这个对象的时候，如果这个对象的某一个数据成员，是另外一个类(B)的对象，你构造这个对象（类B的）的时候它分配整个对象的存储空间，然后对它进行初始化，**当你没有把这个类（B）的对象在初始化列表里面写出来的时候，它就会缺省的构造它，也就是调用（B类）缺省的构造函数去初始化这个对象**，然后它执行你的构造函数的函数体，发现里边还要构造一次它，你这个函数体里面调用了它的数据成员的那个类（A）的构造函数去构造那个数据成员啊，所以它就会再构造一次那个对象，又为它初始化了一遍；这个显然浪费了程序的执行时间，降低了程序运行的效率，所以如果你的类里它的某些数据成员是其它类的对象，那么这些数据对象都应该在这个类的构造函数初始化列表里边对它进行构造，而不要写在构造函数的函数体里）

​	· 在分配内存时，调用缺省构造函数构造，然后执行构造函数函数体内的赋值语句再次构造，效率不佳
​	· 若类没有缺省构造函数，则会导致问题（你定义了一个带参数版本的构造函数，没有定义缺省的构造函数，但是你已经有构造函数了，系统就不会为你自动生成缺省的构造函数；所以在这种情况下边，它就会调用缺省构造函数去构造你的那个对象的啊，但是你又不存在缺省构造函数，那么系统就会导致问题）

> [c++构造函数（初始化式）被忽略的东西](https://blog.csdn.net/gaotengguojianhong/article/details/7058111)
>
> ---内部使用Ctrl+鼠标点击来跳转
>
> 不管是在c++,还是c#，或是java中，当人们一提到构造函数是，马上就回有人回答，是用来初始化成员变量的，没错，但是殊不知，后面却隐含了很多东西。
>
> 首先：构造函数用初始化式列表与在函数体里面直接初始化有什么不同。
>
> 我先简单说一下初始化式，可能有人已经忘了什么是构造函数的初始化式。其实初始化式就是一个以冒号开始，接着是一个以逗号分隔的数据成员列表，**每个数据成员后面跟着一个放在圆括号里的初始化式**。而初始化式**只能在构造函数的定义中而不能再声明中指定**（因为初始化是构造时同步完成的，声明不能构造）。如：
>
> ```c++
> class A{
>   public: int a,b;
>   public: string c;
>   A(const string &s):a(3),b(4),c(s){ }
>   //这里是定义不是声明，有{}没有分号结尾
>   //用形参s初始化对象c
> };
> ```
>
> 我们也可以由下面的方式进行成员变量的初始化：
>
> ```c++
> class A{
>   public: int a,b;
>   public: string c;
>   A(const string &s){ a = 3;b = 4;c = s}
> };
> ```
>
> 那么上面两个有什么区别呢？
> 我们先说一下，构造函数的执行过程分为两个阶段：（1）初始化阶段；（2）普通计算阶段。
> 普通计算阶段是由构造函数的函数体内的语句来构成。
> 那么我们来分析一下第二种方式的初始化：
> 这个构造函数在给类A的成员变量赋值之前，**第一步要进行初始化变量c。所以这个构造函数使用了内部隐式的string类的构造函数对c进行初始化。当我们执行到普通计算阶段时，又对c进行了赋值。**
> 那么什么样的构造函数必须使用初始化式来对成员变量进行赋值呢？
> 我这里给出两种，一种是const，另一种是引用类型。
> 为什么呢？我们可以想一想const变量要求在声明的时候就进行初始化，而如果我们采用第二种方式的话，在构造函数的第二个阶段，又会对const变量赋一次值，而这又违反了const变量的性质。关于引用类型的探讨留给读者。
>
> 定义引用类型时：
>
> 将引用绑定到初始化对象；
>
> 因此定义引用类型时必须有初始值对象（必须为左值）
>
> 如果不提供初始左值的话，默认构造器无法生成左值。

注意事项

－**成员初始化按照成员定义顺序，而不是初始化列表里面的那个说明的顺序**（比如你定义的类，它第一个成员是a，第二个成员是b，第三个成员是c，构造的时候就是按abc顺序构造的，假如初始化列表是bac的顺序，它先看到b，再看到a，就会把a跳过去，因为a的构造的时机已经被你错过了，**前面就认为它是缺省构造，它就不管了**，直接去构造c，这样就会导致a没有被正确的构造）

－必须保持初始化列表和成员定义的顺序一致性，但允许跳过部分成员；否则后续成员可能不会正确初始化

---构造函数的初始化列表最主要的一个目的，就是当我们在创建这个对象，我们要对它进行初始化，**我们希望的就是能够同步地初始化它的全部的数据对象**，为什么要初始化列表呢？你把这些内部对象的那个初始化动作写在那个构造函数体里边不行么？大部分时候是行的，有些时候是不行的，因为两者的实现策略是不一样的。你把那个代码写在构造函数的函数体里边，那就意味着这些代码将是在这个对象被构造完成之后去调用的；而你写在这个构造函数的初始化列表里面，它将是在构造那个对象的瞬间去对它进行初始化的。还记得以前我们讲过，初始化和赋值之间的差异吗？这一点在构造函数初始化列表和构造函数体内部代码之间体现的情况是一样的。

#### 对象的析构

构造是决定我们这个数据对象的初始化，当我们这个程序运行到某一时刻或者程序结束的时候，这些对象生命期结束了。我们就要销毁它，销毁这个动作，不管是你主动地去销毁，你调用free或者调用delete去主动地销毁你动态分配的内存，还是由系统自动地去销毁，都涉及到这个数据对象进行一系列的清楚工作，我们要在对象的生命期结束的时候清楚它。

对象析构的意义

－**析构就是终止化，在对象生命期结束时清除它**

对象析构的技术手段：使用析构函数

－与类类型同名，前有“~”记号，无返回值类型（包括void类
型），无参数

－**析构函数必须是公开的**（因为当你想要销毁这个对象的时候，它可能会被使用delete这样的操作符来调用的，不管怎样，它都需要使用这个类的析构函数去销毁它，**那肯定是在这个类的外部调用析构函数**，不公开就没有办法销毁这个对象。同样析构函数一样可以设为私有或保护的，在这个类或派生类外部就没有权利去析构我们的对象，这样的程序代码也是存在的）

－可以由系统在销毁对象时自动调用，也可以由程序其他部分直接调用，但两者（系统调用和程序员主动调用）工作原理不同，因为**我们主动调用析构函数并不涉及到销毁这个对象所分配的那个内存，仅仅是销毁它里面的数据**。

－**每个类只能有一个析构函数**

－若未定义，系统会自动产生一个缺省析构函数，该函数无代码（系统给出的析构函数作用一般是释放定义对象时系统分配的对象空间；如果你声明动态内存的话，必须要显示的释放，
其他的是编译器处理）

总结前面我们就知道了：在类的声明里面有三个缺省的函数，缺省的构造函数、缺省的拷贝构造函数、缺省的析构函数；实际上还有第四个缺省的函数，接下来会讲到。

继续看圆类库接口

```c++
设计表示二维平面上圆的类类型
/* 圆类库接口“circle.h”*/
class Circle
{
public:
 Circle();
 Circle( double r, double x, double y );
 ……
~Circle();
//因为我们这个对象里没有任何动态内存分配的数据，所以析构函数你不写，系统自动生成的这个析构函数就够用。你写了，其实代码里我也不知道要写什么，什么其实都不用写，空着就可以了。但是你一定要实现它对吧，你不能只声明不实现它，那个不成，只声明不实现就意味着不能调用。实现方式如下：
A::~A() {

...

}
private:
 double r, x, y;
};
```

**定义析构函数的目的**

－用于释放对象中动态分配内存的目标数据对象

就像拷贝构造函数一样，缺省的，它只能完成浅拷贝，它缺省给你提供的那个析构函数只能完成浅层的释放，它不能完成深层的释放。

所以如果**你的对象里边有一个数据成员，它是一个指针**，指向一个目标数据对象，而那个目标数据对象是你动态分配的，并且你这个对象负有销毁它的义务。**那么你就应该写一个析构函数，在这个析构函数体内部销毁那个目标数据对象**。

```c++
使用示例
class A{
public:
	A( int x );
 	~A();
private:
 	int * p;
};
A::A( int x )
{
 p = new int;
 *p = x;
}
A::~A()
{
 delete p, p = NULL;
 //delete 释放new分配的单个对象指针指向的内存
}
//如果你没写这个析构函数，编译器自动生成的那个缺省析构函数，就什么代码都没有，就意味着它没有销毁p所指向的那个目标数据对象，而直接把这个对象本身销毁了，这叫导致了内存泄漏。指针没了，内存空间数据还在，那段内存空间就再也不能用了。

补充：
//一般操作系统会管理内存，程序运行的内存由操作系统分配，泄露的内存会在程序结束时回收。如果操作系统本身有问题，重启应当能解决内存泄露（除非操作系统启动代码就有问题）
//因为你占用的是操作系统分配的程序的虚拟内存地址，不是内存条的
//这段内存不能用了是指如果别的程序又分配到这个内存，它不能被使用了。
```

#### 对象数组

对象数组

－可以像普通数组一样定义和使用（也就是一个数组的每一个元素都是一个类的一个对象，我们可以定义一个类的很多个对象，然后构造成一个数组，这是没问题的）

对象数组的初始化

－当构造函数单参数时，像普通数组一样构造所有元素

就是初始化符号，后面花括号对，后面跟着一个值、一个值，逗号分隔开，系统自动替你将这样一个值转换成类的那样一个对象。其实就是完成一个类型转换，这就是单参数构造函数的意义，它看上去就像一个类型转换一样，它实际上就是类型转换。

－当构造函数多参数时，使用下述方法构造

```c++
Circle circles[2] = { Circle(1.0, 0.0, 0.0), Circle(2.0, 1.0, 1.0) };

//多参数时，你不知道这个逗号分隔开的这些数据成员到底是第一个元素还是第二个元素，所以就必须调用类的构造函数
```

### 4.类与对象的成员

#### 内联函数

**目的：程序优化，展开函数代码而不是调用**（和整个程序的gon功能和整个程序的实现本身它实际上是没有关系的，所以没有内联函数对程序来讲是没有关系的，就是程序运行的效率可能会低一些，其它没有任何影响）

---就是说，如果我有一个函数，它代码量其实很短，如果你每次都调用这个函数，由于函数调用是需要开销的，所以实际上在程序运行的时候会很不经济，从执行时间，也就是效率这个角度来讲，它实际上是调用函数还不如直接编写函数体内部的代码，直接执行它，内联函数就是做这个事情。**它就将这段代码直接展开到那个函数调用的地方，不进行函数调用**！从而提高了我们的程序效率。

**内联函数使用的注意事项**

－在函数定义前添加inline关键字，仅在函数原型前使用此关
键字无效（因为inline本身只和这个函数的定义有关，和它的原型其实没关系）
－编译器必须能看见内联函数的代码才能在编译期展开，因而
**内联函数必须实现在头文件中**（这也就意味着在大多数情况下，你的内联函数必须写在头文件里，工程项目包含很多文件，如果其它的源文件要使用这个内联函数，你要保证这个代码能够展开到另外一个文件里去，那么这个内联函数的实现你必须写在头文件里）
－在类定义中**给出了函数体的成员函数自动成为内联函数**（要在类定义中给出函数体的时候，比如你在类的定义里，实现一个函数，你不需要写它的函数原型---后面不是分号，而是直接跟着花括号体把它的函数实现代码都写在类里边，你前面不用写inline它也是inline）
－函数体代码量较大，或包含循环，不要使用内联（体量大使用内联的效果会导致我们整个程序的代码空间急剧膨胀，你程序效率可能是经济的，但是整个程序的空间是不经济的，所以并不是一个好的选择）
－构造函数和析构函数有可能隐含附加操作，**慎用内联**
－**内联函数仅是建议**，编译器会自主选择是否内联（你写了inline表示你建议编译器将这个函数实现为内联函数，编译器听不听你的它自己有自主决定权，比如代码体量很大时，编译器认为这个函数不适合作内联函数，它就不会inline）

注意：函数调用开销是远远大于函数本身的。

#### 常数据成员

**常数据成员：值在程序运行期间不可变**

－定义格式：const 类型 数据成员名称;

**－必须初始化：只能通过构造函数中的初始化列表进行**（类定义外）

```c++
使用示例
 class A
 {
public:
	A( int a );
private:
 	const int num;
    //不可以对它赋值，那么对它设定值的唯一一个机会就在初始化的那一瞬间
};
A::A( int a ) : num(a) { …… }
// 初始化列表如果写在类外只能写在源文件中，不能写在头文件中，否则会出现重复定义问题。初始化列表只能写在构造函数定义中不是声明，要么在类构造中写，要么写在源文件中，经测试正确。
```

#### 常成员函数

我在一个类里，定义了一个函数，它需要读取这个类中的数据，同时我们明确地知道这个成员函数是不会修改成员的数据的，那么这一点函数在实现的语义来讲，我们有必要把它实现成一个常函数。(只负责读取不能修改)

**常成员函数：不能修改对象成员值的函数**

－定义格式：类型 成员函数名称(参数列表)  const;（因为const是左结合的，所以你不能写在函数原型前面，只能写在函数原型的后边）

**－常成员函数不能调用类中非常成员函数**（因为非常成员函数它就有可能修改成员属性的值，所以你调用它就有可能打破常成员函数的语义，编译器本身不允许你做这样的调用）

**－静态成员函数不能定义为常成员函数**

> 原因：

**－如果对象为常量，则只能调用其常成员函数**（它的非常成员函数你都没有权利访问的）

​		正是在这个角度上来讲，如果你定义了一个类的类型，并且你知道未来你会用这个类类型定义一个常对象，那么这个类类型的接口里边，那些凡是不需要修改成员的属性值的，这样的函数都应该定义成常函数

```c++
使用示例
class Circle{
public:
double GetArea() const;
 ……
};
double Circle::GetArea() const{ …… }
//如果函数的原型或者实现时有一个没写const，编译器会认为这是两个不同的函数。所以要写就都写。
//一旦一个函数不需要修改成员变量的值，或者不能修改成员变量的值，那么就应该把它定义成常函数
```

#### 静态数据成员

**静态数据成员只有一份，由该类所有对象共享**（普通的数据成员，每一个对象都有自己的独立的一份，你用这个类类型定义一个对象，它就结构了一份它的全部数据成员，再定义一个对象，又构造一份，这两者是不一样的，它是两个物体，两个对象，两份数据，如果你要求一个特定的数据成员，在这个类中所有对象上都一样，就一份，那就应该使用静态数据成员）

－声明格式：static 类型 静态数据成员名称;
－仅声明，**不在类的对象上分配存储空间**（它是单独分配的，但是访问规则仍然是属于这个类的，**你要通过类名去解析**）
－定义格式：类型 类名称::静态数据成员名称 = 初始值;
－必须在**外部初始化**，初始化动作与访问控制无关（也就是说不管你是声明为public，还是protected，还是private都应该在这个类的外部单独地对它进行初始化，而不能在类的内部对它进行初始化）

```c++
示 例
class A {
private:
static int count;
};
int A::count = 0;
//初始化时不需要加static进行修饰
//初始化动作应该放在源文件而不是头文件里，因为它相当于一个变量的定义
//为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。
```

#### 静态成员函数

定义静态成员函数的目的仍然是**在一个类而不是在一个对象上面对它进行调用**，它就是未来**访问类的静态的成员而设置的**。

定义了一个静态数据成员，你要想访问这个类的静态数据成员，那么使用静态的成员函数是一个非常恰当的方式。如果你要访问这个类的非静态的数据成员，那么你必须提供这个非静态的数据成员到底是属于哪一个对象的，也就是说，你必须提供一个对象或者一个对象的指针或者一个对象的引用。

```c++
class A {
public:
 	static int f();
 	static int g( const A & a );
private:
	static int count;
	int num;
};
```

```c++
int A::count = 0;
int A::f()
{
 return count;
}
int A::g( const A & a )
{
 return a.num; 
 //num为非静态数据成员，这里提供了一个对象的引用访问它，这里传了一个const A的一个引用
 //因为静态成员函数并没有缺省的this指针
}
```

静态的数据成员和静态的成员函数非常非常有用，在我们的编程中，频繁地需要设计一个很特殊的程序功能。就是什么呢？**存在着某一个类的单一的共享对象**，这样的共享对象它是全局的，在整个程序中，它只能存在一个，并被整个程序中的所有的模块所共享。这样的一个东西，我们称它为是一个**单子**（singleton）。那么我们的编程呢，就必须能够保证这样的一个单子：①全局就存在一个②在全局的任何一个地方都能够访问到它，也就是说我们一定要有一个全局的访问策略，保证在程序代码的任何地方只要需要就能访问到它。操纵的那唯一一个数据对象，这个数据对象就叫单子。

单子模式呢，有很多种实现策略。

```c++
class Singleton
{
public:
 static Singleton * Get() { if (!_s) _s = new Singleton; return _s; }
 // 静态成员函数，对象不存在时构造，否则返回之，保证唯一性
 int GetData() { return ++a; }
 //来返回我们的验证数据看看对不对
private: // 私有构造和析构函数，禁止在外部构造和析构本类的对象
 Singleton() { a = 0; }
 Singleton( const Singleton & that ); // 只声明不实现，禁止拷贝和赋值构造
 Singleton & operator=( const Singleton & that );//赋值的重载构造函数
 ~Singleton(); // 只声明不实现，禁止析构
    
只声明而不实现，这就意味着这样的拷贝函数不仅外界不可以调用我们自己也是不会调用的，因为没有它的实现代码，你一调用编译器就报错，着实际上意味这我们通过这种手段保证我们这个单子模式它是一个不可拷贝对象，这个语义是非重要的，因为如果你允许这个对象可以被拷贝，那就意味着这个单子就不再单了，只声明而不实现它的拷贝构造函数和赋值构造函数就能让这个单子对象不可拷贝，从某种程度上来讲也保证我们的单子模式的唯一性。
接下来，我们要保证怎么真正地构造这个对象，你没有公开的构造函数，外界就不能调用它，那我们这个对象什么时候被构造出来呢？因为单子又不是无子，它总归要有一个子。那么就提供一个公共的Get函数。用这个Get函数来构造这个对象。因为这个Get函数是我们类的一个成员函数，当我们调用这个公开的Get函数的时候，那么它就会执行它的内部代码，而这个内部代码又在这个类的内部，所以它可以调用这个类的私有的构造函数去替我们构造它。在这里我们就可以用一个new操作符调用私有的构造函数去构造我们的这个对象，然后我们返回它构造出来的这个对象，构造出来的这个对象保存在什么地方，这是一个需要特别注意的问题。因为我们时刻要记录构造的对象分配的内存地址在哪里，这个指针必须要保存。所以我们要在这个类的Singleton里面定义一个私有的数据字段，是一个指向Singleton的指针来保存我们构造出来的这个类的，单子对象到底存在哪里，因为这个类中保存的单子就一份，所以这个指针_s应该只有一份，前面要加上static关键字，保证_s是指向本类唯一的对象的那个唯一的指针。
private:
 static Singleton * _s; // 静态数据成员，指向本类唯一对象的指针
 int a; // 作为我们的验证数据
};
Singleton * Singleton::_s = NULL; // 定义于源文件中
// 使用方法：以Singleton::Get()->GetData()方式直接访问，唯一的方式
Singleton::Get()
//我们得到这个指针之后就可以引领这个指针所指向的那个目标对象，就是Singleton的一个对象，然后调用它的GetData返回它对应的实际的那个验证数据递增以后的值。

在这里面我仅仅是写了一个析构函数的声明，所以我没有销毁在构造函数中分配的那个指针所指向的目标数据对象的内存，当程序结束的时候，绝大多数的操作系统都会自动地释放动态分配的内存，我们可以不实现它，大部分时候都没问题，但是偶尔，真的没有析构函数它确实有可能导致问题的，因为我们这里面毕竟有一个指针，指向一个动态分配的内存。
因为这个静态成员是从属于一个特定的类的，而不从属于那个类的某一个对象，所以要想解析这个静态数据成员那么前面必须加上类名Singleton::_s，初始化为NULL。
```

我们定义的这个单子模式里面，因为要求这样的数据对象，全局只能构造一个唯一的副本，这就意味着它的构造函数不能公开。

------

上述就是我们单子模式的第一版，没有析构。没有析构当然可能导致问题的。

```c++
class Singleton
{
public: // 静态成员函数，对象不存在时构造，否则返回之，保证唯一性
 static Singleton * Get() { if (!_s) _s = new Singleton; return _s; }
 int GetData() { return ++a; }
private: // 私有构造和析构函数，禁止在外部构造和析构本类的对象
 Singleton() { a = 0; }
 Singleton( const Singleton & that ); // 只声明不实现，禁止拷贝和赋值构造
 Singleton & operator=( const Singleton & that );
 // 析构函数实现为private，在外部是不能够调用的
 // 错误析构函数，即便访问控制改为public也不行，因为   delete操作符本身需要调用析构函数，Singleton::_s它是指向Singleton的一个指针，要销毁这个_s所指向的那个目标对象，目标对象就是Singleton，所以你就必须调用这个Singleton的析构函数才能够销毁它嘛。所以你在这个类的析构函数里边，调用这个类的析构函数本身是不可以的。
 // 另外非静态函数不能释放静态指针成员，否则在某些Linux系统下可能导致系统崩溃
 ~Singleton() { if(Singleton::_s) { delete Singleton::_s, Singleton::_s = NULL; } }
private:
 static Singleton * _s; // 静态数据成员，指向本类唯一对象的指针
 int a; // 验证数据
};
```

我们需要析构，上面的又不对，怎么办呢？这里有一个方案，我们希望这个析构函数它能正确地被调用，不是不实现它，但是我需要它在某一个恰当的时机能够被调用，那么什么样一个时机被调用呢？就是程序完全结束之前，所有的动态分配的静态量都应该销毁它们指向的目标数据对象，那么我们就想了一个很巧妙的一个技巧，使用到了**嵌套类**的概念，如果我在一个类的内部还定义另外一个类，那么这样一个类就从属于这个类，这个叫嵌套类。

```c++
class Singleton
{
public: // 静态成员函数，对象不存在时构造，否则返回之，保证唯一性
 static Singleton * Get() { if (!_s) _s = new Singleton; return _s; }
 int GetData() { return ++a; }
private: // 私有构造函数，禁止在外部构造本类的对象
 Singleton() { a = 0; }
 Singleton( const Singleton & that ); // 只声明不实现，禁止拷贝和赋值构造
 Singleton & operator=( const Singleton & that );
public: // 在部分系统下使用private亦可，系统简单释放全部内存，并不调用它
 ~Singleton() { } // 因此，如果函数非空（如需数据持久化），有可能导致问题
private:
 static Singleton * _s; // 静态数据成员，指向本类唯一对象的指针
 // Destroyer类的唯一任务是删除单子
 class Destroyer{
 public:
 ~Destroyer() { if(Singleton::_s) { delete Singleton::_s, Singleton::_s = NULL; } }
 };
 static Destroyer _d; // 程序结束时，由操作系统负责替我们销毁，在销毁它的时候操作系统就会调用静态成员_d的析构函数,而这个析构函数就会替我们销毁_s所指向的那个静态的Singleton那个单子对象，这个过程是自动的。
 int a; // 验证数据
};

这个析构也是有点问题的，一，这个销毁只能在程序结束的时候进行，因为它是自动进行的，什么时候_d需要被销毁，单子才能够销毁。销毁的时机我们别无选择；二，有些编译器在程序结束的时候，因为优化的目的，所有的资源都会直接返还给操作系统，也就是说，这样对象你不销毁其实问题也不大，所以它可能压根就不销毁_d，它不销毁_d，那么就不会销毁_s所指向的Singleton。如果你的单子模式中，它的析构函数里面写了一些特殊的代码，那么这个类可能会有问题。
假设Singleton是一个实际应用的类，它会一自己其它附加的信息专门去做某些特定的事情，那么这样一个析构函数因为要被外界调用，所以我需要把它变成public，同时呢，比如我这个类里面有一些数据，需要在这个单子对象被销毁的时候完成它的数据持久化，那么如果我把这段代码写在了Singleton的析构函数里，要确保这个Singleton的这个析构函数能够被调用，有些编译器，程序结束了，你所有动态分配的量不管三七二十一全返还给操作系统算了，根本就不用管，所以这个析构函数它压根就不调用，根本不管这个单一的一个对象，要不要销毁，它不释放_s,Singleton这个析构函数就不会被调用，你的数据持久化代码如果写在析构函数里它就不会被执行，你的程序语义就会有问题。
所以这个析构的方式是正确的，但是在某些特殊的情况下，我们的程序可能不像我们所期望的那么工作。
```

我们再想一个方案

```c++
class Singleton
{
public: // 静态成员函数，对象不存在时构造，否则返回之，保证唯一性
 static Singleton * Get() { if (!_s) _s = new Singleton; return _s; }
 // 不调用析构函数，Release调用时机由程序员确定
 static void Release() { if(_s) { free(_s), _s = NULL; } }
 int GetData() { return ++a; }
private: // 私有构造和析构函数，禁止在外部构造和析构本类的对象
 Singleton() { a = 0; }
 Singleton( const Singleton & that ); // 只声明不实现，禁止拷贝和赋值构造
 Singleton & operator=( const Singleton & that );
 ~Singleton();
private:
 static Singleton * _s; // 静态数据成员，指向本类唯一对象的指针
 int a; // 验证数据
};
```

不实现析构，我真释放那怎么办呢？我写一个public函数，自己写一个释放函数，因为要操纵的是静态对象，所以我们静态函数static void Release() 释放那个静态的对象。奇怪的是这个对象是new出来的，销毁的时候没有delete，而是free。当我们调用free的时候，它简单地清空那一片存储区，而不调用那个类的析构函数，如果你delete，它要作的事情就是调用那个目标对象的析构函数，然后清空那段内存，把那段内存还给操作系统，如果你free，它就不调用那个类的析构函数，直接返还那段内存给操作系统，这样我就能保证这一段内存区域，能够完整地正确的返还给操作系统，即使它是new出来的。也就是说，在某些特殊的时候，new和free一样是可以配对的。所以如果你要对它做数据持久化操作，简单，在free这个函数前完成它的持久化就行了。这就意味着有了release这个函数，那么你在任何时候想析构这个单子对象，就可以析构这个单子对象，调用它Singleton::Release() 它就会销毁那个单子对象。当你再次调用Singleton::Get() 的时候它就会再次创建一个单子对象，这个时候你要注意，销毁的那个单子对象和新创建的那个单子对象是两个不同的对象，它们存续的时间是不同的。虽然这两个单子对象在程序中都保证在它们存在的那段时间里它们都是唯一的，但它们仍然是两个不同的单子对象，当然也有可能放在内存的不同的地方。所以要特别区注意这个问题。

这个实现也会有一个小问题，如果程序员忘了调用Release怎么办，那就没有被释放嘛。所以如果你要保证在程序结束的时候要销毁整个程序中出现的所有单子对象（可能每一个类一个单子对象），那么你必须在程序结束之前最终要写一个清楚的一个函数来销毁所有的单子，你如果忘了写它，那这些对象就都没有被清楚，就有可能导致问题。所以我们使用一个新的结构来实现它。这个单子类和原来那个单子类实现有很大的差别了。它代码很短，但是可以解决原来那些问题。

```c++
class Singleton
{
public: // 静态成员函数中的静态变量，保证唯一性
 static Singleton & Get() { static Singleton _s; return _s; }
 int GetData() { return ++a; }
private: // 私有构造和析构函数，禁止在外部构造和析构本类的对象
 Singleton() { a = 0; }
 Singleton( const Singleton & that );
 Singleton & operator=( const Singleton & that );
 ~Singleton() { }
private:
 int a; // 验证数据
};
// 本实现没有动态内存分配，因而无需销毁单子对象
// 使用方法：定义引用或以Singleton::Get().GetData()方式直接访问
Singleton & sing = Singleton::Get();
//定义一个引用的别名，这个初始化动作既不会发生值的拷贝，也不会发生赋值，既然什么都不发生，我们引用的就是那个唯一的单子量。
int n = sing.GetData();

虽说这是一个不太好的方式，如果真是一个单子，其实建议同学们不要定义这样的量，即使是引用量，也不要定义它，每次都是Singleton::Get去得到它。这样的话，我们保证访问的就是那个唯一的静态局部量。而且在源代码级别能够看到它是完全唯一的。
```

没有指向单子类静态单子的一个指针，因为以前所有的构造和析构的问题，都是因为分配了一个动态内存区域所导致的，所以我们就不要指针了。那我们这个单子在哪里实现呢，那么我们就要在Get那个函数里边定义和实现它。所以我将在这个函数内部，定义一个静态的单子对象_s，使用它的无参数版本对它进行初始化。return _s 返回在这个Get函数内部定义的静态局部变量 _s ，不管这个静态局部变量是定义在普通函数里还是定义在成员函数里，所有的静态变量都将像全局变量一样分配存储空间在整个程序运行期间一直维持不变，我们返回的就是 _s ，不管你调用多少次Get，返回的都是它，这不就是单子了吗。尤其你考虑到，我们的构造函数全私有的，还好几个没实现，那不就是一定是这个样子吗。你只能通过Get得到那个单子，Get得到的就是唯一的那个静态局部量 _s 嘛，那不就是单子嘛。所以Get函数返回的就是 static Singleton 的一个引用。

#### 静态常数据成员

它混合了常数据成员和静态数据成员的两个特征。它的值不仅是在程序运行期间是不可以改变的，且每一个类只有唯一的一份。

**－定义格式：static const 类型 数据成员名称;**

**－初始化：只能在类的外部初始化**（有例外，数据是整型量或整型量存储的，比如int、bool、char、枚举型）

```c++
使用示例
class A {
private:
 static const int count;
};
const int A::count = 10;
//两个const都不能省略，而static只需在类的数据成员地方写上就行了
```

> 1、自定义类型（string等内置类型以及使用class定义的类等）
>
>    必须放在类外初始化，不可以放在xxx.h文件中，可以不加static修饰
>
> 2、基本数据类型(int char bool等)
>
>    可以在类内部进行初始化（唯一一个可以在类内进行初始化的）
>
> ```c++
> //example.h
> class Example{
> #include <string>
> using namespace std;
> 
> class Example{
> public:
>     Example(int a);
> public:
>     static int si;
>     const int ci;	//常成员变量，在构造函数的初始化列表中初始化
>     static const int scd = 1;
>     //static const int sci;
>     static const string scs;	//类类型的静态常量，必须在类外初始化
> };
> ```
>
> ```c++
> //example.cpp
> #include <iostream>
> #include "static_test.h"
> 
> int Example::si = 10;
> //const int Example::sci = 19;
> const string Example::scs = "zs";
> Example::Example(int a) : ci(a) {} 
> //对常成员变量ci进行初始化
> ```
>
> ```c++
> #include <iostream>
> #include "static_test.h"
> using namespace std;
> 
> int main()
> {
>     Example e(3);
>     cout << e.scd << "\n" << e.ci << "\n" << e.si << endl;
>     return 0;
> }
> ```
>
> 

#### 友元函数与友元类

友元就是朋友，有些特定的类在外界，有些函数或者另外一个类想使用它，不是想使用它的公开数据和公开成员，是想使用它的隐私数据和隐私成员。

友元：慎用！破坏类数据封装与信息隐藏

－类的友元可以访问该类对象的私有与保护成员
－**友元可以是函数、其他类成员函数，也可以是类**
－定义格式：friend 函数或类声明;
－两个类的友元关系不可逆，除非互为友元

```c++
使用示例
class Circle
{
 friend double Get_Radius(); // 友元函数
 friend class Globe; // 将Globe类所有成员函数声明为友元类
// 只能写在这个类的定义里。同时这个写法不需要加访问控制在前面，它只是一个声明，它不是类的成员，所以访问控制作用不到它上面。
private:
double radius;
};
```

虽然慎用，但是很多时候，在某些特定的场合下，你不使用这个东西，编程实际上是极其不方便的，所有呢，我们又离不开它。

### 5.继承

#### 继承与派生

继承的基本概念

把所有这些类共性都抽取出来，形成一个抽象的桌子（餐桌、写字台、床头柜），同时它们都从原来那个桌子继承下来，这是一个**非常重要的一个概念**。继承就构造了我们整个类库的各个类之间的层次关系。所谓继承就体现在这里。

餐桌是从桌子继承下来的，所以称餐桌是桌子的派生类，而那个抽象的桌子就是基类（父类）。

－类类型：描述分类的概念
－继承：**描述类之间的血缘（继承）关系**
－基类、派生类
－父类、子类（不恰当的概念；因为在类库层次下，有的时候我们说子类可能是另外一个词，叫subclass，翻译出来也叫子类，它这个写法和它的意义，和我们讲继承的时候这个子类是不一样的，所以未来不引起混淆，最好使用基类和派生类这个概念，一个叫base，一个叫derived，来描述类的继承和层次）

也就是说，在解决实际问题的时候，我声明了这么多类，我们既把它分解开，同时又形成继承的层次，这样的话，构造的类库的框架，它是立体的，它才能够完整地描述我们现实世界中的问题。因为我们现实中的事物事实上是普遍联系的，它们互相之间是构成一个复杂的网状连接关系的。所以没有继承，没有面向对象技术，它实际上就是不完整的，功能是极度受限的。

继承的意义

－派生类拥有基类的全部属性与行为（想取消是不可能的，只能添加新的功能，不能取消已有的功能）
－派生类可以增加新的属性与行为，而不能删除原有的属性和行为（这是继承本身特殊的要求）

#### 单继承

单继承的基本语法格式

－class 派生类名称 : 派生类型保留字 基类名称 { … };

派生类型保留字

－public：基类的public、protected成员在派生类中保持，private成员在派生类中不可见（属于基类隐私）

​		如果你的派生类型是public，称之为公有派生，从基类继承下来的属性尽可能地保留了基类的访问控制规则，原来是public还是public，原来是protected还是，原来是private，那是它的隐私，派生类是没有权利访问基类的私有数据的。

－protected：基类的private成员在派生类中不可见，public、
protected成员在派生类中变为protected成员

－private：基类的private成员在派生类中不可见，public、
protected成员在派生类中变为private成员

所以真实继承的时候，大部分情况下我们使用的都是public。

－在设计类的时候，因为我们需要频繁地在派生类里边访问基类的数据对象，如果每次都是使用存取函数，那个基类里提供的那个公有的存取函数来访问基类的那个对象，很多时候它是不方便的，即使那些函数被你定义成内联的，它也可能是不方便的，所以在这种情况下，我们在定义类的层次的时候，未来解决问题的方便，不用private定义基类的私有数据，而是使用protected定义基类的数据。（设计类时若需要使用继承机制，建议将派生类需要频繁使用的基类数据成员设为protected的）

从某种程度上来讲，它打破了这个类的私有规则，这个方式不是完美无缺的，它实际上是有一点小问题的，可是为了解决问题的方便，很多时候我们习惯于这么做。

**函数覆盖于二义性**

继承的时候有可能导致基类的成员函数和派生类的成员函数具有同名的情况，在这种情况下就有可能发生函数的覆盖，调用的时候有可能会发生二义性，我们在编程的时候必须要能够处理它。

```c++
class Point { void Print(); };
class Point3D: public Point { void Print(); };
Point pt( 1, 2 );
Point3D pt3d( 1, 2, 3 );

调用示例
－pt.Print()：调用Point类的Print成员函数
－pt3d.Print()：调用Point3D类的Print成员函数(继承下来的print函数没有被调用)
－Point类的Print成员函数在Point3D类中仍存在，但被新类中的同名函数覆盖
－访问规则（解析）：pt3d.Point::Print()
```

#### 多继承

C++本身它还提供了特殊的多继承的机制

```c++
多继承的基本语法格式
class 派生类名称: 派生类型保留字 基类名称1, 派生类型保留字 基类
名称2, … { … };
多继承示例
class A { … }; class B { … };
class C: public A, protected B { … };
//在C类里边上来就会放A类的一个存储空间，接下来放B类的存储空间，B类的存储空间是什么呢？B类的存储空间上来就是A类的存储空间，然后是B类新添加的数据成员，在此之后才是C类自己定义的数据成员；所以这里面有A类的数据成员的两个副本，而且第一个副本是公有派生下来的，第二个副本是保护派生下来的，访问控制还不一样，所以这种情况下取的是A类第一个副本呢还是第二个副本呢，你编程的时候就需要特别小心；另外还得问了，保存A类的两个副本有意义吗？大部分情况下，在C类保存A类的两个副本是没有意义的，所以多继承问题很多。
//A类和B类的私有成员在C类里都看不见
class A { … }; class B: public A { … };
class C: public A, protected B { … };
```

多重继承导致的问题比它能够带来的好处还要多，所以我们一定要慎用。理论上一个单继承能够解决我们任何问题，所以使用多继承在绝大多数情况下，其实是毫无必要的，所以不建议同学们在实际编程的时候使用多继承的机制。

它导致的问题就是：

​		一个派生类里面可能包含很多个基类的副本，这些基类副本的位置你没有办法去决定它，因为对于一个单继承来讲，它一个基类的一个数据对象，它的存储布局基本是这样一个模式，按照它的数据成员的顺序，一个接着一个分配好，放在那个地方，构造这个对象的时候就按照这个方式来构造，当我派生的时候，首先会继承基类这些数据成员，它的架构，包括它的存储布局，一模一样地全都继承下来，然后在后边继续添加自己的数据，这就形成一个非常明确不断扩展的数据存储布局；

​		如果多继承，那么它的第二个基类就只能写在第一个基类的后边，第三个基类就写在第二个的后边，这个存储布局，你看上去也是顺序的，但是如果它（注：指基类）有多个副本，就有可能导致它（注：指派生类）在后续某个位置还有基类的数据，访问的时候是非常讨厌的，操作起来很麻烦，一不注意就能搞错，所以大部分情况下我们应该慎用它。

```c++
派生类成员函数名称与基类相同
class A { public: void f(); };
class B { public: void f(); };
class C: public A, public B { public: void f(); };
C c;
调用示例
－c.f()：调用C类的成员函数
－c.A::f()：调用C类继承自A类的函数
－c.B::f()：调用C类继承自B类的函数
//名解析一样是可以工作，但是肯定不像单继承那么方便
```



#### 虚继承

一旦在一个多继承下，派生类就可能保留基类的很多个副本，那我们怎么限制这一点，让它只保留基类的唯一一个副本呢？后续的同样的副本我都删掉了，我不要了，那我们怎么保证这一点呢？那么我们就需要虚继承。

**虚拟继承的目的**

－取消多继承时派生类中公共基类的多个副本，只保留一份

－格式：派生时使用关键字virtual

```c++
使用示例：D中只有A的一份副本
class A { public: void f(); };
class B: virtual public A { public: void f(); };
//virtual写在virtual public A前就表示B类的这一个类的对象上，所有的A类的副本只有一个
class C: virtual public A { public: void f(); };
//C类上所有的A类的副本只有一个
class D: public B, public C { public: void f(); };
//当它继承C类的时候，发现D类已经有了一个A类的副本，那么这个继承的A类的副本就不要了
//virtual 和 pubic这种写法，前后颠倒没关系，它只和多继承有关，对于单继承，因为所有的继承都是单一的一条线，所以它不会产生多继承的情况，基类的副本不会有两个，那么虚继承它就不需要
//你写了虚继承，对C++来讲，需要做一些额外的操作，这个额外的操作实际上是会降低我们程序的效率的
```

#### 派生类的构造函数与析构函数

构造函数的执行顺序

－调用基类的构造函数，调用顺序与基类在派生类中的继承顺序相同（B继承A，C继承B，先调A的构造函数，再调B类的，然后才调C类的构造函数）
－调用派生类新增对象成员的构造函数，调用顺序与其在派生类中的定义顺序相同（如果派生类里你增加了一个数据对象，这个数据对象本身是类的一个对象，那么这个对象也有构造函数）
－调用派生类自己的构造函数

​		如果这些量写在初始化列表里边，它就用初始化列表里面的数据去构造它，最后调用我们的构造函数的函数体。这是派生类的构造函数的执行顺序。

析构函数的执行顺序

－调用派生类的析构函数（先把派生类的新增那些东西给它消掉）
－调用派生类新增对象成员的析构函数，调用顺序与其在派生类中的定义顺序相反（abc都是类的对象，构造的时候按这个顺序，析构的时候就是cba的顺序，一个接着一个来，当把所有这些新增数据成员全部析构之后，它才能调用基类的析构函数）
－调用基类的析构函数，调用顺序与基类在派生类中的继承顺序相反（如果它的继承层次是A、B、C，那么它析构的时候就是C、B、A）

#### 类的赋值兼容性

非常重要！！！因为我们在写面向对象的程序的时候，我们实际上是建构了一个类库的层次，而我们操纵这个类库层次的时候，我们往往会使用指向基类的一个指针或者是一个基类的一个引用。

**公有派生时，任何基类对象可以出现的位置都可以使用派生类对象代替**（这保证了广泛的赋值兼容性，为我们编程提供了极大的灵活性，这是必不可少的一个东西）

涉及到三种情况：

－将派生类对象赋值给基类对象，这个时候它仅赋值它的基类部分，可以赋值但有些信息丢了

－用派生类对象初始化基类对象引用，仅能操作它的基类部分(一样的，一个基类的一个引用它也只能引用它的基类的那一部分的数据，我把一个派生类的对象初始化给它，那它引用的仍然是它的基类的那一小部分，所有的派生类数据它是访问不到的)

－使指向基类的指针指向派生类对象，仅能引领它的基类部分

也就是说，不管怎样，当你把一个派生类的对象赋值为基类对象的时候，要么是赋值基类的部分，要么是只能操作那一部分，要么是只能引领它的那一部分。派生类的那个部分都没有办法去处理的。

保护派生与私有派生本身因为它的访问控制原因不可以直接赋值，所以这种时候它就完全打破了我们类继承的层次它的编程的灵活性，我们在设计这个类库继承层次的时候需要的就是这个**将派生类的对象或派生类的引用或者指向派生类的指针来赋值给一个基类的对象、一个基类的引用，一个指向基类的指针**，如果缺了这个类的赋值兼容性，那么实际上，面向对象的这个继承的架构它的好处已经取消了一大部分，所以真正派生的时候使用保护派生和私有派生场合是极少极少的。

**－尽量不要使用保护派生与私有派生**

所以我们总结：你应该单继承、公有派生。这是写面向对象程序中保证自己不犯错误的最简单的方式。反正这种方式能够解决任何问题，那不就行了嘛。

```c++
#include <iostream> 
#include <string> 
using namespace std; 
class Base 
{ 
public: 
 Base(string s) : str_a(s) { } 
 Base(const Base & that) { str_a = that.str_a; } 
 void Print() const { cout << "In base: " << str_a << endl; } 
protected: 
 string str_a; 
}; 
class Derived : public Base
{ 
public: 
 Derived(string s1,string s2) : Base(s1), str_b(s2) { } 
 // 调用基类构造函数初始化
 // 派生类的形参传给Base(s1)，s1作为Base的形参通过初始化列表构造出str_a
 void Print() const { cout << "In derived: " << str_a + " " + str_b << endl; } 
protected: 
 string str_b; 
};
```

重要的事说三遍：我们的派生类构造函数里，首先要构造它的基类的部分，而这个基类的构造函数怎么构造呢？**就应该写在这个构造函数的初始化列表里，要写在这个类的构造函数的初始化列表里，要写在这个类的构造函数的初始化列表里**。

基类部分构造完，然后构造派生类的自有对象 str_b （注：string是标准模板库里为我们提供的一个类——string类），str_b 倒是可以写在花括号体内，但是会导致两次构造。

> 同样，对派生类进行拷贝构造时，如果想让基类的成员也同时拷贝，就一定要在派生类拷贝构造函数初始化列表中显示调用基类拷贝构造函数。

```c++
int main() 
{ 
 Derived d1( "Hello", "World" ); 
 Base b1( d1 ); // 拷贝构造，派生类至基类，仅复制基类部分
 d1.Print(); // Hello World
 b1.Print(); // Hello
 Base & b2 = d1; // 引用，不调用拷贝构造函数，仅访问基类部分
 d1.Print(); // Hello World
 b2.Print(); // Hello
 Base * b3 = &d1; // 指针，不调用拷贝构造函数，仅引领基类部分
 d1.Print();
 b3->Print(); 
 return 1; 
}
```

### 6.多态

多态其实就是一种物体的几种不同的形态，所以叫多态。听上去很高级，多态是非常重要的一个概念，**想写好程序，不理解多态性肯定是不行的**。但实际上，这个概念我们一直在用，而我们压根就没有注意到。

首先，你从小学开始，你用到的那个操作就是多态的，比如说加法，开始学1+1=2，后来你学1.0+2.0=3.0，先学了整数加法后来你学了小数加法，后来学了整数和小数的加法，再后来你又学了代数的加法，又学会抽象代数的加法，所有的这些操作，这个加法操作本身实际上就是多态的。就一个加法符号，我们其实把它理解成多态的一个加法操作，它在整数加法，小数加法，代数加法，它的做法可能都是不一样的，这个其实就叫多态，到我们计算机里边，那更是完全不一样了，因为整数加法指令是整数加法指令，小数加法指令是小数加法指令，那是两个不同的指令，同样的一个加法操作，是会翻译成两条不同指令的，压根就不是一回事，所以那个加法一定是个多态的。

多态性

－目的：让不同对象在接收到相同消息时能够进行不同的响应
－现象：对应同样成员函数名称，它在不同的基类和派生类里面执行不同函数体

#### 多态性的实现

－虚函数：使用virtual关键字声明**成员函数**（就让成员函数成为多态的；注意**多态性只影响函数**，数据成员不存在多态这个概念，因为成员函数对应的是操作，成员函数将成为一个虚函数，维持它的多态性，这个维持是指从这个类把这个函数定义成虚函数之后就开始了，它的派生类里不管这个同名的函数有没有写virtual，它也是virtual的，也就是说一日为virtual终生为virtual，）

－声明格式：virtual 函数返回值 函数名称(参数列表);

在函数实现的时候不需要写virtual。

非虚函数示例：处理的是一个银行的账户（银行账户分两类，一个是储蓄账户，定期存款啊、活期存款啊；另一个是给予你做结算的目的的，主要是企业在用的那种结算的账户，和储蓄账户不一样）

```c++
// 头文件
//它们两个是不同的账户，但是它们是相关的，所以我们要定义一个账户的基类。
#include <iostream>
using namespace std;
class Account
{
public:
 Account( double d ) : _balance(d) { }
 //构造函数直接写函数体的也被内联了
 double GetBalance() const;
 void PrintBalance() const;
private:
 double _balance;
 //表示这个账户的余额
};
inline double Account::GetBalance() const
{
 return _balance;
}
```

```c++
class CheckingAccount : public Account
{
public:
 CheckingAccount(double d) : Account(d) { }
 void PrintBalance() const;
};
class SavingsAccount : public Account
{
public:
 SavingsAccount(double d) : Account(d) { }
 void PrintBalance() const;
};
```

```c++
// 源文件
void Account::PrintBalance() const
{
 cerr << "Error. Balance not available for base type." << endl; 
}
//标准账户因为它是一个抽象的账户，所以实际上我们在Account这个账户上PrintBalance想打印余额实际上是不可以打印的。所以我们cerr直接向标准错误流里输出“余额不可用”信息就完了。
void CheckingAccount::PrintBalance() const
{
 cout << "Checking account balance: " << GetBalance() << endl; }
void SavingsAccount::PrintBalance() const
{
 cout << "Savings account balance: " << GetBalance() << endl; }
```

接下来看看怎么使用

```c++
int main()
{
 CheckingAccount * checking = new CheckingAccount( 100.00 ) ;
 SavingsAccount * savings = new SavingsAccount( 1000.00 );
 Account * account = checking;
 //用结算账户初始化我们的一个抽象账户
 //checking为指向派生类的指针，赋值给指向基类的指针
 account->PrintBalance();
 account = savings;
 account->PrintBalance();
 delete checking;
 delete savings; 
 return 0; 
}
//显然打印出来的都是cerr的信息
//但是我们要的是如果account是一个指向基类的指针，那么当我们用它指向派生类的时候，我们应该调用派生类的那个成员函数，把它的余额打印出来。而不是调用基类的那个函数。当在非虚函数情况下，这个工作是做不了的，所以我们必须使用虚函数。
```

虚函数示例

```c++
// 头文件
#include <iostream>
using namespace std;
class Account
{
public:
 Account( double d ) : _balance(d) { }
 double GetBalance() const;
 virtual void PrintBalance() const;
 //并不需要改变_balance的值，所以它本身是个const
private:
 double _balance;
};
inline double Account::GetBalance() const
{
 return _balance;
}
```

```c++
class CheckingAccount : public Account
{
public:
 CheckingAccount(double d) : Account(d) { }
 virtual void PrintBalance() const;
 //虽然不加virtual它也是virtual了，但是建议写上，这样一看就很清楚了
};
class SavingsAccount : public Account
{
public:
 SavingsAccount(double d) : Account(d) { }
 virtual void PrintBalance() const;
};
```

这样按之前的主函数调用就可以实现我们想要的功能了。

account是个基类指针，如果它指向基类，它就调用基类的PrintBalance，如果指向派生类就调用派生类的函数，不管哪个派生类是CheckingAccount还是SavingsAccount，总之那个派生类是哪一个它就调用哪一个类的对应虚函数。很明确吧，这个就叫自适应。它能够自动适应它所指向的目标类。它自然就体现出了多态。**这就是虚函数最重要的一个地方**。

另外，如果基类里有一个虚函数，你的派生类里不想动它，你可以不写，因为派生类自动地能够继承基类的全部数据对象和成员函数，所以那个基类的虚函数自动地在你的派生类中就存在了。

在C++里这是怎么实现的呢？

​		C++代码里边它会为每一个这样的类的一个对象，维持着一个虚拟表，我们称为虚拟表的指针，用一个虚拟表的指针指向这样的一个虚表，每一个虚表里就会记录你这个类所实现的所有的虚函数的入口地址，当它是一个基类的时候，它就把基类的虚函数的入口地址写进去，如果它是派生类，它就把派生类的虚拟函数的基地址写进去。当你构造的是一个派生类的对象的时候，它写的实际上是派生类的那个虚函数的入口地址，所以即使你是使用一个指向基类的指针指向这个派生类的对象，当它调用那个虚函数的时候，它一查那个虚拟表，查到的依然是派生类的那个虚函数的入口地址，所以我们指向基类的那个指针才能够调用派生类的虚函数。

通过示例可以发现：

关于多态【接口和实现分离，父类指针指向子类的实例，然后通过父类指针调用子类的成员函数，这样可以让父类指针拥有多种形态，所以称之为多态】

#### 纯虚函数

刚才的那个例子，Account账户本身实际上充当的是一个抽象的账户，也就是说实际上在它里面打印一个余额是没有意义的，因为不管怎样，它要么是结算账户要么是储蓄账户，实际程序运行过程中不存在既不属于储蓄账户也不属于结算账户的抽象账户，我们也许会有一个这样的指针也许会有这样一个引用量，但是一定没有真实的Account账户的存在，我们不会构造它的，这点很重要！我们要构造的要么是结算账户要么是储蓄账户，不会构造一个抽象的Account账户，它只是表达我们整个类库设计的时候最顶层的抽象的一个模式，表示所有的账户类的最顶层的共性。所以为它实现PrintBalance是没有意义的，就像我们的代码中，我实际上是向标准错误流里输出一串信息，并不是真正地输出它的账户余额信息。

明确了这一点，我们就不该实现基类的这个函数，实现了也没有意义，反正我们也不会调用它，那么怎么办呢？

​		C++为我们提供了一个纯虚函数的机制来实现它。

**纯虚函数**

－充当占位函数，没有任何实现

－派生类负责实现其具体功能

－声明格式：virtual void f( int x ) = 0;（初始化为0其实就是个NULL，就表示这个函数将没有任何实现，这个函数没有代码体，但不是只声明不定义，只声明不定义它也叫没有，但是编译器---如果你调用它的时候，就会告诉你它有问题，因为那个函数不存在，调用就出错，编译通不过；纯虚函数编译器也会告诉你不能调用，但是实际上这个函数的指针是存在的，在这个对象的虚拟表里边，f这个函数的虚拟表指针---虚函数指针是存在的，只不过那里被填了0，表示这个函数入口地址是0，函数本身不存在，但是这个指针是存在的）

**抽象类**

－所有带有纯虚函数的类在C++里都叫纯虚类，更一般地我们其实应该称它为抽象的类。因为我们绝不可能构造这样类的一个对象。语言机制不允许的，因为里面有一个函数没实现。这样的话就是一个抽象的一个类。

－最主要的目的是作为类继承层次的上层，一般来讲是最上层，也可能如果下一层需要抽象，它还可以是个抽象类。也就是说，它往往都位于类库层次的顶层。它形成的是一个抽象的机制，它不承担实际的工作，这个就叫抽象类。**对于类库的程序设计是非常非常有用的**！

**虚析构函数**

**－保持多态性需要虚析构函数，以保证能够正确释放对象**（保持整个类的多态性的一个最基本的需要，我们需要用到它，如果是一个非虚的，它实际上就和特定的类是相关的了，**当你在指向基类的一个指针上，去销毁它的派生类的那个对象的时候**，那么实际上是没有办法正确销毁的，所以析构函数往往都是虚的）---保证指向基类的指针能够操作派生类的对象的销毁

示例：

```c++
// “Point.h”
#include <iostream>
using namespace std;
class Point
{
public: 
 Point() { }
 virtual void Print() const = 0;
// virtual ~Point();
};

//真正抽象的一个点应该是0维的点，所有的属性都不存在。那么对于这样的一个类来讲，如果我想定义它的一个Print成员函数，显然我不知道该写什么，其实就是我什么都不应该写，我把Print定义成纯虚函数，这样Point就是一个纯虚类，它就是足够抽象的一个顶层逻辑。所有的点都将从我们的class Point派生下去。对于点库的继承层次来讲，Point就是它们唯一的根。
```

```c++
class Point2D : virtual public Point
//虚继承，单根的话，virtual不写也没问题
{
public: 
 Point2D( int x = 0, int y = 0 ) : _x(x), _y(y) { }
 Point2D( const Point2D& pt2d ) : _x(pt2d._x), _y(pt2d._y) { }
 int GetX() const { return _x; }
 void SetX( int x ) { _x = x; }
 int GetY() const { return _y; }
 void SetY( int y ) { _y = y; }
 virtual void Print() const;
protected:
 int _x, _y;
};
```

```c++
class Point3D: virtual public Point2D
{
public:
 Point3D( int x = 0, int y = 0, int z = 0 ) : Point2D(x,y), _z(z) { }
 Point3D( const Point3D& pt3d ) : Point2D(pt3d._x, pt3d._y), _z(pt3d._z) { }
 //这个地方写成Point2D(pt3d)更好理解，是对的；上面那个也是对的，不好理解
 int GetZ() const { return _z; }
 void SetZ( int z ) { _z = z; }
 virtual void Print() const;
protected:
 int _z;
};
```

```c++
// “point.cpp”
void Point2D::Print() const
{
 cout << "( " << _x << ", " << _y << " )";
}
void Point3D::Print() const
{
 cout << "( " << _x << ", " << _y << ", " << _z << " )";
}
// “main.cpp”
int main()
{
 Point * pt1 = new Point2D( 1, 2 );
 //创建一个二维的点对象，它的内存是动态分配的，把它的地址传给pt1。
 Point * pt2 = new Point3D( 1, 2, 3 );
 pt1->Print();
 pt2->Print();
}
//如果写了虚析构函数，那么你在pt1上面删除和pt2上面删除都是它对应的二维点和三维点的那个对象。
//派生类虚函数实现的时候const也得加上，老师课件里没有，编译出错
```

## 十.操作符重载

### 1.四则运算符重载

```c++
设计一个数偶类，定义专用的四则运算
// 数偶是一个包含两个元素的特殊的数据结构，这样的两个数据我们往往是以成对的方式来操纵和访问的。在C++的标准模板库里，事实上替我们提供了一个类似的概念，它称之为pair，我们这里使用Couple。
//四则运算加减乘除余总共5个，这里只以+和*举例说明
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b) { }
 Couple operator+( const Couple & c );
 //operator+就是这个加法操作符的函数的名字，+前要有operator表示它是一个操作符，括号里要提供这个操作符的参数，对加法来讲，它实际上是带了两个成员，左操作数就是this指针所指向的那个对象，而右操作数就是我们提供的这个参数。
 Couple operator*( const Couple & c );
private:
 int _a, _b;
};
```

```c++
Couple Couple::operator+( const Couple & c )
{
 Couple _t( this->_a + c._a, this->_b + c._b );// 构造一个新的Couple对象
 return _t; // 返回这个对象
}
Couple Couple::operator*( const Couple & c )
{
 Couple _t( this->_a * c._a, this->_b * c._b );
 return _t;
}
int main()
{
 Couple a( 1, 2 ), b( 3, 4 ), c, d;
 c = a + b; // 等价于 c = a.operator+(b) ==> c( 4, 6 )，括号里的参数b当然接受的实际上是b的一个常引用
 d = a + b + c; // 等价于 d = a.operator+(b).operator+(c) ==> d( 8, 12 )
 c = a * b; // 等价于 c = a.operator*(b) ==> c( 3, 8 )
 return 0;
}

//在c++的内部实现中，加法操作并没有应用到我们自己定义的Couple类上，我们要想让加法能够在我们的Couple类上工作，那么我们就必须在Couple类上重载operator+；如果你提供一个成员函数名字叫Add，可以不，可以。但是我们有了重载的加法操作，我就可以让Couple这两个对象看上去就像普通的数学运算一样，就用数学的加法就把它们加在一起了。这多方便啊，对于这个对象的使用者，对于这个类的使用者来讲，你这个类库的架构别人用起来就非常方便。重载操作符的目的其实就在这里，
```

**问题一：假设需要数偶倍乘运算（标量运算），将整数k同时乘到两个成员上。如何实现？**

为什么要用标量乘，因为我要模拟两个同样的数偶的加法。

```c++
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b) { }
 Couple operator*( const int & k );
private:
 int _a, _b;
};
Couple Couple::operator*( const int & k )
{
 Couple _t( this->_a * k, this->_b * k );
 return _t;
 // 这里为啥是const int & k 其实前面引用那部分我也提到了“初始化常量引用时允许用任意表达式作为初始值”
}
```

```c++
int main()
{
 int k = 3;
 Couple a( 1, 2 ), b( 3, 4 ), c, d;
 c = a + b; // 等价于 c = a.operator+(b) ==> c( 4, 6 )
 d = a + b + c; // 等价于 d = a.operator+(b).operator+(c) ==> d( 8, 12 )
 c = a * b; // 等价于 c = a.operator*(b) ==> c( 3, 8 )
 c = c * k; // 等价于 c = c.operator*(k) ==> c( 9, 24 )
 d = d * 2; // 等价于 d = d.operator*(2) ==> d( 16, 24 )
 return 0;
}
```

**问题二：参数必须是Couple类对象的常引用吗？**

- 可以不使用引用，但会产生对象拷贝动作，降低效率（如果你不使用引用，就会产生一个值传递，在C++语言里实际上就两种参数传递方式，一个值传递，一个引用传递，一个值传递就会产生一个拷贝动作，它要把实际参数的值拷贝给形式参数嘛，值拷贝动作，当数据对象很小的时候没关系，如果是个大对象，这个拷贝就会极大地消耗CPU的时间，降低程序效率)
- **可以不是常引用，但无法限制函数内部对参数的修改**（在这个函数体内部就有可能**通过那个引用修改那个目标对象的值**，不是常引用是有可能修改目标对象的值的，这是一个非常重要的设定；如果你的成员函数里并不需要修改目标对象的值，这个引用就必须设定成const Couple，而不能设定为Couple&）
- （可不可以使用指针作为函数参数呢？）可以使用指针，但与常规数学公式使用方式不符（真实的操作符重载我们从不传递指针，它和数学语义不吻合，这在重载操作符中是大忌）

**问题三：返回值必须是Couple类的对象吗？返回引用是否可行？**

- 可以返回引用，但必须是全局对象或通过参数传递进去的Couple对象的
  引用，不能引用函数内部的局部变量（在函数内部可以访问的并且在这个函数结束之后仍然存在的一个对象）
- **不建议使用引用类型的返回值** （普通四则运算不建议）
- 需要将右操作数累加到左操作数上并返回左操作数时就应该使用引用作为函数的返回值了，此时应该重载加赋等操作符，减赋、乘赋、除赋与余赋类似

**问题四：四则运算符必须重载为成员函数吗？**

​		不。可以重载为类的友元函数或普通函数。注意：普通函数无法访问类的私有成员。

​		**建议重载为友元函数**

**重载为友元函数**

优势：显式具有**双操作数**（左右操作数你都要作为参数传进去），且**格式一致**（成员函数的时候左操作数为指针，右操作数为引用，现在变为双操作数都是以引用的形式传进去）；操作不局限于当前对象本身，且**不要求左操作数必须为本类的对象**

劣势：显式具有双操作数，不能省略左操作数

```c++
class Couple
{
public:
 Couple( int a = 0, int b = 0 ) : _a(a), _b(b) { }
 friend Couple operator+( const Couple & c1, const Couple & c2 );
 friend Couple operator*( const Couple & c1, const Couple & c2 );
 friend Couple operator*(const Couple & c, const int & k );
 friend Couple operator*( const int & k, const Couple & c );
private:
 int _a, _b;
};
//重载的操作符不并天然地支持我们的乘法交换律
```

```c++
Couple operator+( const Couple & c1, const Couple & c2 )
{
 Couple _t(c1._a + c2._a, c1._b + c2._b );
 return _t;
}
Couple operator*( const Couple & c1, const Couple & c2 )
{
 Couple _t( c1._a * c2._a, c1._b * c2._b );
 return _t;
}
Couple operator*( const Couple & c, const int & k )
{
 Couple _t( c._a * k, c._b * k );
 return _t;
}
Couple Couple::operator*( const int & k, const Couple & c )
{
 Couple _t( k * c._a, k * c._b );
 return _t;
}
```

```c++
int main()
{
 int k = 3;
 Couple a( 1, 2 ), b( 3, 4 ), c, d;
 c = a + b; // 等价于 c = operator+(a, b) ==> c( 4, 6 )
 d = a + b + c; // 等价于 d = operator+(operator+(a, b), c) ==> d( 8, 12 )
 c = a * b; // 等价于 c = operator*(a, b) ==> c( 3, 8 )
 c = k * c; // 等价于 c = operator*(k, c) ==> c( 9, 24 )
 d = 2 * d; // 等价于 d = operator*(2, d) ==> d( 16, 24 )
 return 0;
}
```

数偶倍乘运算重载的说明

- 应重载为类的友元函数
- 若非友元函数，当倍数为左操作数时，无法解析乘法运算，编译会出错
- 将左操作数k转换为Couple类的对象可以解决上述问题，但意义已不同
- 上述转换要求提供一个单参数的从整数到Couple类的构造函数，如果使用explicit修饰该构造函数，隐式类型转换会被禁止；虽然即使不禁止，很多编译器也不进行此转换
- 左右操作数不可互换，重载函数必须提供两个版本，它们的函数签名不同



## 十一.泛型编程

### 1.泛型编程概览

1）什么是泛型编程

---泛型就是通用型式

---编写不依赖数据对象型式的代码就是泛型编程（你写的程序代码和你想要操纵的那个数据对象的具体型式相对无关，那么你写的这段代码就称为泛型的代码，你处理的型，当然也就是所谓的泛型）。

2）为什么需要泛型编程

前面讨论的C++的语言规范里，我们使用面向对象的技术，有继承，有多态，可以解决很多现实世界中的问题，但是，在纯粹的面向对象编程里，涉及到几个问题，这几个问题不太好解决。

一个是函数重载的问题，第二个是相似类的定义问题，第三个是型号式兼容性。在这里，需要补充两个知识，一个是异常处理机制，一个是运行期的型式信息。

3）怎样进行泛型编程

泛型编程最主要的技术手段就是：模板与型式参数化。

1.**函数重载问题**

设计函数，求两个数据对象的较小者

**注意**：并没有说数据对象具体是什么型

所以，如果你编写这样一段程序代码，那么事实上你将提供很多个函数，因为重载机制，所以处理不同型的这样的函数可以命名成一样的。

如果你有一个类A，那么你要为A类提供一个Min()版本，如果你还有一个类B，还要为B类提供一个Min()版本。

```c++
//为明确规定参数型式，因C/C++的强型式检查特性，必须为不同型式的参数分别实现，没完没了。。。
//函数重载数目巨大，并且永不完备。。。
class A;
const A & Min(const A & a, const A & b);
class B;
const B & Min(const B & a, const B & b);
```

**解决方案：使用C的含参宏**

在引入C++以前，我们怎么解决函数重载问题呢？在C++以前，C是怎么解决函数重载问题的呢？因为C不支持函数重载，所以它提供了含参宏，这是一种很巧妙的方案。

宏，尤其是含参宏，它是型式无关的。所以它在某种程度上起到了函数重载的类似效果。

**缺点**：

---无型式检查，无法在编译期检查程序错误。

---宏文本替换时，要注意操作符优先级，错误的宏文本有可能导致问题

**结论**：

---（从函数重载角度上讲）需要一种机制，能够在语法层面解决宏的问题

2**.相似类定义问题**

动态数组类

---定义存储整数的动态数组类

---定义存储浮点数的动态数组类

---定义存储某类对象的动态数组类

---定义存储某类对象指针的动态数组类

......

结论：

---需要一种机制，能够在语法层面解决相似类的重复定义问题，降低编程工作量。

3.**型式兼容性问题**

C型式转换：(T)x

---不安全

---内建型式（int、double）对象转换安全性基本保证

---类对象转换可能导致无法控制的严重后果

C++型式转换：T(x)

看上去让这个型式转换变成像一个函数一样。事实上它就是一个函数。

对于一个特定的型，我们可能需要一个单参数的构造函数和重载的型式转换操作符，才能完成这样的一个型式转换。

**同样，C++的型式转换依然不安全**。

如果你未实现这样的型式转换，那么它的转换本身就不存在。对于你自己定义的一个特定的类，如果你没有实现单参数构造函数，如果你没有重载型式转换操作符，这样的转换可能就是无法工作的。所以它一样也是不太方便的。

**类库架构**

---（从类库架构的角度上来讲）类的继承和多态频繁要求能够通过基类的指针或引用访问派生类的对象。(这是类库层次的基本要求)

---（所以）需要沿着类的继承层次，频繁进行对象的型式转换。（这是必须的）

而前面两种转换，它在很多情况下效果不令人满意。

**存在的问题**

---（所以）C/C++已有型式转换为静态转换，不能适应指针或引用的多态性。

---型式转换本身必须能够适应全部型式，并能自如操作；然而很不幸，型式无穷尽，程序员无法编写完备的型式转换代码。

所以我们需要一种很特殊的机制，能够来保持我们的型式兼容性。

**保证型式兼容性的机制**

---（这样的一种机制）必须能确保型式转换操作本身是合法有效的，并且在失败的时候通知用户。

---（为了让这样一种机制能够工作，我们需要两个特别的技术手段），①：需要在运行期维持对象的型式信息（run-time-type information，RTTI，运行期型式信息），②：转换结果的确认，通过转换操作的返回值确认结果，或者在失败时触发特定信号（或者给出一个特定的返回值来标记它），后者需要使用异常处理机制。

如果是一个指向对象的指针，当它转换失败的时候，我们简单的传递一个空指针就OK了；但是如果是一个引用，当它转换失败的时候，我们没有办法返回一个空引用，所以这个时候就需要使用异常处理机制。

从实现策略角度来讲，完成这样的型式兼容性的一个最基本的技术，就是我们这一讲要讨论的**模板与型式参数化**。

### 2.异常处理机制（非常重要）

1）异常处理机制的基本概念

异常的定义：程序中可以检测的运行不正常的情况

示例：被0除、数组越界、存储空间不足等。

**一个健壮的程序这些问题都必须处理**，早期我们是怎么写程序呢，我们可以写一个if判断它，当它出错的时候我们就做特定的处理，我们还可以写什么呢，我们还可以使用断言来处理这个问题。到了C++里边，为了和面向对象类库的架构相兼容，它提供了异常处理机制。允许你定义异常类，给了你一个更灵活的处理异常的技术手段。

**异常处理的基本流程**

---某段程序代码在执行操作时发生特殊情况，引发一个特定的异常

---另一段程序代码捕获该异常并处理它

异常的引发

异常的捕获

异常类与异常对象

异常处理策略

异常描述规范





[https://blog.csdn.net/gaotengguojianhong/article/details/7058111]: 